Module(body=[ImportFrom(module='etna.metrics', names=[alias(name='mae')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='mape')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='medae')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='mse')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='msle')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='r2_score')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='sign')], level=0), ImportFrom(module='etna.metrics', names=[alias(name='smape')], level=0), ImportFrom(module='etna.metrics.base', names=[alias(name='Metric')], level=0), ImportFrom(module='etna.metrics.base', names=[alias(name='MetricAggregationMode')], level=0), ClassDef(name='MAE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mean absolute error metric with multi-segment computation support.\n\n    .. math::\n        MAE(y\\_true, y\\_pred) = \\frac{\\sum_{i=0}^{n-1}{\\mid y\\_true_i - y\\_pred_i \\mid}}{n}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='mae', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='MSE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mean squared error metric with multi-segment computation support.\n\n    .. math::\n        MSE(y\\_true, y\\_pred) = \\frac{\\sum_{i=0}^{n-1}{(y\\_true_i - y\\_pred_i)^2}}{n}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='mse', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='R2', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Coefficient of determination metric with multi-segment computation support.\n\n    .. math::\n        R^2(y\\_true, y\\_pred) = 1 - \\frac{\\sum_{i=0}^{n-1}{(y\\_true_i - y\\_pred_i)^2}}{\\sum_{i=0}^{n-1}{(y\\_true_i - \\overline{y\\_true})^2}}\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='r2_score', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=True))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='MAPE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mean absolute percentage error metric with multi-segment computation support.\n\n    .. math::\n       MAPE(y\\_true, y\\_pred) = \\frac{1}{n}\\cdot\\frac{\\sum_{i=0}^{n-1}{\\mid y\\_true_i - y\\_pred_i\\mid}}{\\mid y\\_true_i \\mid + \\epsilon}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='mape', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='SMAPE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Symmetric mean absolute percentage error metric with multi-segment computation support.\n\n    .. math::\n       SMAPE(y\\_true, y\\_pred) = \\frac{2 \\cdot 100 \\%}{n}\\cdot\\frac{\\sum_{i=0}^{n-1}{\\mid y\\_true_i - y\\_pred_i\\mid}}{\\mid y\\_true_i \\mid + \\mid y\\_pred_i \\mid}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='smape', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='MedAE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Median absolute error metric with multi-segment computation support.\n\n    .. math::\n       MedAE(y\\_true, y\\_pred) = median(\\mid y\\_true_1 - y\\_pred_1 \\mid, \\cdots, \\mid y\\_true_n - y\\_pred_n \\mid)\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='medae', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='MSLE', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mean squared logarithmic error metric with multi-segment computation support.\n\n    .. math::\n       MSLE(y\\_true, y\\_pred) = \\frac{1}{n}\\cdot\\sum_{i=0}^{n - 1}{(ln(1 + y\\_true_i) - ln(1 + y\\_pred_i))^2}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='msle', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), ClassDef(name='Sign', bases=[Name(id='Metric', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Sign error metric with multi-segment computation support.\n\n    .. math::\n        Sign(y\\_true, y\\_pred) = \\frac{1}{n}\\cdot\\sum_{i=0}^{n - 1}{sign(y\\_true_i - y\\_pred_i)}\n\n    Notes\n    -----\n    You can read more about logic of multi-segment metrics in Metric docs.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='sign', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=None))], decorator_list=[Name(id='property', ctx=Load())], returns=Constant(value=None))], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='MAE'), Constant(value='MSE'), Constant(value='R2'), Constant(value='MSLE'), Constant(value='MAPE'), Constant(value='SMAPE'), Constant(value='MedAE'), Constant(value='Sign')], ctx=Load()))], type_ignores=[])