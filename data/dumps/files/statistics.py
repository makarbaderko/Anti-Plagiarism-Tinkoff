Module(body=[ImportFrom(module='abc', names=[alias(name='ABC')], level=0), ImportFrom(module='abc', names=[alias(name='abstractmethod')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), Import(names=[alias(name='bottleneck', asname='bn')]), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.transforms.base', names=[alias(name='Transform')], level=0), ClassDef(name='WindowStatisticsTransform', bases=[Name(id='Transform', ctx=Load()), Name(id='ABC', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='WindowStatisticsTransform handles computation of statistical features on windows.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='out_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=1), Constant(value=1), Constant(value=0)]), body=[Expr(value=Constant(value="Init WindowStatisticsTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        out_column: str\n            result column name\n        window: int\n            size of window to aggregate, if -1 is set all history is used\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column_name', ctx=Store())], value=Name(id='out_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load()))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fits transform.')), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='WindowStatisticsTransform')), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Aggregate targets from given series.')), Pass()], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='transform', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Compute feature's value.\n\n        Parameters\n        ----------\n        df: pd.DataFrame\n            dataframe to generate features for\n\n        Returns\n        -------\n        result: pd.DataFrame\n            dataframe with results\n        ")), Assign(targets=[Name(id='history', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Load())), orelse=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load()), attr='get_level_values', ctx=Load()), args=[Constant(value='segment')], keywords=[]), attr='unique', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='df_slice', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Slice(), Subscript(value=Attribute(value=Name(id='pd', ctx=Load()), attr='IndexSlice', ctx=Load()), slice=Tuple(elts=[Slice(), Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), attr='sort_index', ctx=Load()), args=[], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='df_slice', ctx=Load()), attr='values', ctx=Load()), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='x', ctx=Load()), BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='empty', ctx=Load()), args=[Tuple(elts=[BinOp(left=Name(id='history', ctx=Load()), op=Sub(), right=Constant(value=1)), Subscript(value=Attribute(value=Name(id='x', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load())], keywords=[]), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='nan', ctx=Load()))], keywords=[keyword(arg='axis', value=Constant(value=0))])), Assign(targets=[Name(id='isnan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='isnan', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Name(id='isnan', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='lib', ctx=Load()), attr='stride_tricks', ctx=Load()), attr='sliding_window_view', ctx=Load()), args=[Name(id='isnan', ctx=Load())], keywords=[keyword(arg='window_shape', value=Tuple(elts=[Name(id='history', ctx=Load()), Constant(value=1)], ctx=Load()))]), slice=Tuple(elts=[Slice(), Slice(), Slice(step=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Load()))], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='isnan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='squeeze', ctx=Load()), args=[Name(id='isnan', ctx=Load())], keywords=[keyword(arg='axis', value=UnaryOp(op=USub(), operand=Constant(value=1)))])), Assign(targets=[Name(id='non_nan_per_window_counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nansum', ctx=Load()), args=[UnaryOp(op=Invert(), operand=Name(id='isnan', ctx=Load()))], keywords=[keyword(arg='axis', value=Constant(value=2))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='lib', ctx=Load()), attr='stride_tricks', ctx=Load()), attr='sliding_window_view', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='window_shape', value=Tuple(elts=[Name(id='history', ctx=Load()), Constant(value=1)], ctx=Load()))]), slice=Tuple(elts=[Slice(), Slice(), Slice(step=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Load()))], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='squeeze', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='axis', value=UnaryOp(op=USub(), operand=Constant(value=1)))])), Assign(targets=[Name(id='y', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_aggregate', ctx=Load()), args=[], keywords=[keyword(arg='series', value=Name(id='x', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='non_nan_per_window_counts', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Load())]), ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='nan', ctx=Load())), Assign(targets=[Name(id='y', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='nan_to_num', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[keyword(arg='copy', value=Constant(value=False)), keyword(arg='nan', value=Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Load()))]), slice=Slice(step=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='join', ctx=Load()), args=[Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[keyword(arg='columns', value=Call(func=Attribute(value=Attribute(value=Name(id='pd', ctx=Load()), attr='MultiIndex', ctx=Load()), attr='from_product', ctx=Load()), args=[List(elts=[Name(id='segments', ctx=Load()), List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column_name', ctx=Load())], ctx=Load())], ctx=Load())], keywords=[])), keyword(arg='index', value=Attribute(value=Name(id='df', ctx=Load()), attr='index', ctx=Load()))])], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='sort_index', ctx=Load()), args=[], keywords=[keyword(arg='axis', value=Constant(value=1))])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], decorator_list=[]), ClassDef(name='MeanTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MeanTransform computes average value for given window.\n\n    .. math::\n       MeanTransform(x_t) = \\sum_{i=1}^{window}{x_{t - i}\\cdot\\alpha^{i - 1}}\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MeanTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        alpha: float\n            autoregressive coefficient\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha_range', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='transform', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Compute feature's value.\n\n        Parameters\n        ----------\n        df: pd.DataFrame\n            dataframe to generate features for\n\n        Returns\n        -------\n        result: pd.DataFrame\n            dataframe with results\n        ")), Assign(targets=[Name(id='window', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Load()), ops=[NotEq()], comparators=[UnaryOp(op=USub(), operand=Constant(value=1))]), body=Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Load()), orelse=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[]))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha_range', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[ListComp(elt=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='alpha', ctx=Load()), op=Pow(), right=Name(id='i', ctx=Load())), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='window', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha_range', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='expand_dims', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha_range', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=0))])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='transform', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute weighted average for window series.')), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Tuple(elts=[Subscript(value=Attribute(value=Name(id='series', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Attribute(value=Name(id='series', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load())], keywords=[])), For(target=Name(id='segment', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='mean', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='mean', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load())], ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmean', ctx=Load()), args=[BinOp(left=Subscript(value=Name(id='series', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load())], ctx=Load()), ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha_range', ctx=Load()))], keywords=[keyword(arg='axis', value=Constant(value=1))]))], orelse=[]), Return(value=Name(id='mean', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='StdTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='StdTransform computes std value for given window.\n\n    Notes\n    -----\n    Note that ``pd.Series([1]).std()`` is ``np.nan``.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='ddof', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None), Constant(value=1)]), body=[Expr(value=Constant(value="Init StdTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ddof:\n            delta degrees of freedom; the divisor used in calculations is N - ddof, where N is the number of elements\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ddof', ctx=Store())], value=Name(id='ddof', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute std over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanstd', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2)), keyword(arg='ddof', value=Attribute(value=Name(id='self', ctx=Load()), attr='ddof', ctx=Load()))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='QuantileTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='QuantileTransform computes quantile value for given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='quantile', annotation=Name(id='float', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init QuantileTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        quantile: float\n            quantile to calculate\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantile', ctx=Store())], value=Name(id='quantile', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute quantile over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='apply_along_axis', ctx=Load()), args=[Attribute(value=Name(id='np', ctx=Load()), attr='nanquantile', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2)), keyword(arg='arr', value=Name(id='series', ctx=Load())), keyword(arg='q', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantile', ctx=Load()))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='MinTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MinTransform computes min value for given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MinTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute min over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmin', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='MaxTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MaxTransform computes max value for given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MaxTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute max over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmax', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='MedianTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MedianTransform computes median value for given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MedianTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute median over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmedian', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='MADTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MADTransform computes Mean Absolute Deviation over the window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MADTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute MAD over the series.')), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmean', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='expand_dims', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[keyword(arg='axis', value=UnaryOp(op=USub(), operand=Constant(value=1)))])), Assign(targets=[Name(id='mad', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Tuple(elts=[Subscript(value=Attribute(value=Name(id='series', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()), Subscript(value=Attribute(value=Name(id='series', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=1), ctx=Load())], ctx=Load())], keywords=[])), For(target=Name(id='segment', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='mad', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=1), ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='ad', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Subscript(value=Name(id='series', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load())], ctx=Load()), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='mean', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load())], ctx=Load()), ctx=Load()))], keywords=[])), Assign(targets=[Subscript(value=Name(id='mad', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load())], ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmean', ctx=Load()), args=[Name(id='ad', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))]))], orelse=[]), Return(value=Name(id='mad', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='MinMaxDifferenceTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='MinMaxDifferenceTransform computes difference between max and min values for given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init MaxTransform.\n\n        Parameters\n        ----------\n        in_column: str\n            name of processed column\n        window: int\n            size of window to aggregate\n        seasonality: int\n            seasonality of lags to compute window's aggregation with\n        min_periods: int\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna: float\n            value to fill results NaNs with\n        out_column: str, optional\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute max over the series.')), Assign(targets=[Name(id='max_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmax', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Assign(targets=[Name(id='min_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nanmin', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Name(id='max_values', ctx=Load()), op=Sub(), right=Name(id='min_values', ctx=Load()))), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='SumTransform', bases=[Name(id='WindowStatisticsTransform', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='SumTransform computes sum of values over given window.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='in_column', annotation=Name(id='str', ctx=Load())), arg(arg='window', annotation=Name(id='int', ctx=Load())), arg(arg='seasonality', annotation=Name(id='int', ctx=Load())), arg(arg='min_periods', annotation=Name(id='int', ctx=Load())), arg(arg='fillna', annotation=Name(id='float', ctx=Load())), arg(arg='out_column', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=None)]), body=[Expr(value=Constant(value="Init SumTransform.\n\n        Parameters\n        ----------\n        in_column:\n            name of processed column\n        window:\n            size of window to aggregate, if window == -1 compute rolling sum all over the given series\n        seasonality:\n            seasonality of lags to compute window's aggregation with\n        min_periods:\n            min number of targets in window to compute aggregation;\n            if there is less than ``min_periods`` number of targets return None\n        fillna:\n            value to fill results NaNs with\n        out_column:\n            result column name. If not given use ``self.__repr__()``\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='in_column', ctx=Store())], value=Name(id='in_column', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='window', ctx=Store())], value=Name(id='window', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='min_periods', ctx=Store())], value=Name(id='min_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fillna', ctx=Store())], value=Name(id='fillna', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Store())], value=Name(id='out_column', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='in_column', value=Name(id='in_column', ctx=Load())), keyword(arg='out_column', value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='out_column', ctx=Load()), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='__repr__', ctx=Load()), args=[], keywords=[]))), keyword(arg='window', value=Name(id='window', ctx=Load())), keyword(arg='seasonality', value=Name(id='seasonality', ctx=Load())), keyword(arg='min_periods', value=Name(id='min_periods', ctx=Load())), keyword(arg='fillna', value=Name(id='fillna', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_aggregate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute sum over the series.')), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='bn', ctx=Load()), attr='nansum', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=2))])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='MedianTransform'), Constant(value='MaxTransform'), Constant(value='MinTransform'), Constant(value='QuantileTransform'), Constant(value='StdTransform'), Constant(value='MeanTransform'), Constant(value='WindowStatisticsTransform'), Constant(value='MADTransform'), Constant(value='MinMaxDifferenceTransform'), Constant(value='SumTransform')], ctx=Load()))], type_ignores=[])