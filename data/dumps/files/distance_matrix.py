Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.clustering.distances.base', names=[alias(name='Distance')], level=0), ImportFrom(module='etna.core', names=[alias(name='BaseMixin')], level=0), ImportFrom(module='etna.loggers', names=[alias(name='tslogger')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[ImportFrom(module='etna.datasets', names=[alias(name='TSDataset')], level=0)], orelse=[]), ClassDef(name='DistanceMatrix', bases=[Name(id='BaseMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='DistanceMatrix computes distance matrix from TSDataset.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='distance', annotation=Name(id='Distance', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Init DistanceMatrix.\n\n        Parameters\n        ----------\n        distance:\n            class for distance measurement\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='distance', ctx=Store())], value=Name(id='distance', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='matrix', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='series', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='segment2idx', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='idx2segment', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='str', ctx=Load())], ctx=Load()), ctx=Load()), value=Dict(keys=[], values=[]), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='_validate_dataset', args=arguments(posonlyargs=[], args=[arg(arg='ts', annotation=Constant(value='TSDataset'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check that dataset does not contain NaNs.')), For(target=Name(id='segment', ctx=Store()), iter=Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load()), body=[Assign(targets=[Name(id='series', ctx=Store())], value=Subscript(value=Name(id='ts', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='first_valid_index', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='last_valid_index', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='series', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))]), attr='last_valid_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='series_length', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='last_valid_index', ctx=Load()), op=Sub(), right=Name(id='first_valid_index', ctx=Load())), op=Add(), right=Constant(value=1))), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='series', ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[NotEq()], comparators=[Name(id='series_length', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Timeseries contains NaN values, which will be dropped. If it is not desirable behaviour, handle them manually.')])], keywords=[])), Break()], orelse=[])], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_get_series', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Constant(value='TSDataset'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Parse given TSDataset and get timestamp-indexed segment series.\n        Build mapping from segment to idx in matrix and vice versa.\n        ')), Assign(targets=[Name(id='series_list', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='segment', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='segment2idx', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Store())], value=Name(id='i', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='idx2segment', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Store())], value=Name(id='segment', ctx=Load())), Assign(targets=[Name(id='series', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='ts', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='series_list', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='series', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='series_list', ctx=Load())], keywords=[])), Return(value=Name(id='series_list', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), ctx=Load())), FunctionDef(name='_compute_dist', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute distance from idx-th series to other ones.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Something went wrong during getting the series from dataset!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='distances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[ListComp(elt=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='distance', ctx=Load()), args=[Subscript(value=Name(id='series', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Load()), Subscript(value=Name(id='series', ctx=Load()), slice=Name(id='j', ctx=Load()), ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='distances', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_compute_dist_matrix', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='series', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute distance matrix for given series.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Something went wrong during getting the series from dataset!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='distances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='empty', ctx=Load()), args=[], keywords=[keyword(arg='shape', value=Tuple(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load())], ctx=Load()))])), Assign(targets=[Name(id='logging_freq', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Constant(value=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load()), op=FloorDiv(), right=Constant(value=10))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tslogger', ctx=Load()), attr='log', ctx=Load()), args=[JoinedStr(values=[Constant(value='Calculating distance matrix...')])], keywords=[])), For(target=Name(id='idx', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='distances', ctx=Load()), slice=Name(id='idx', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_dist', ctx=Load()), args=[], keywords=[keyword(arg='series', value=Name(id='series', ctx=Load())), keyword(arg='idx', value=Name(id='idx', ctx=Load()))])), If(test=Compare(left=BinOp(left=BinOp(left=Name(id='idx', ctx=Load()), op=Add(), right=Constant(value=1)), op=Mod(), right=Name(id='logging_freq', ctx=Load())), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='tslogger', ctx=Load()), attr='log', ctx=Load()), args=[JoinedStr(values=[Constant(value='Done '), FormattedValue(value=BinOp(left=Name(id='idx', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1), Constant(value=' out of '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='series_number', ctx=Load()), conversion=-1), Constant(value=' ')])], keywords=[]))], orelse=[])], orelse=[]), Return(value=Name(id='distances', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Constant(value='TSDataset'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit distance matrix: get timeseries from ts and compute pairwise distances.\n\n        Parameters\n        ----------\n        ts:\n            TSDataset with timeseries\n\n        Returns\n        -------\n        self:\n            fitted DistanceMatrix object\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_dataset', ctx=Load()), args=[Name(id='ts', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='series', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_series', ctx=Load()), args=[Name(id='ts', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_dist_matrix', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='series', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='DistanceMatrix')), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get distance matrix.\n\n        Returns\n        -------\n        np.ndarray:\n            2D array with distances between series\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='matrix', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='DistanceMatrix is not fitted! Fit the DistanceMatrix before calling predict method!')], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='matrix', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='fit_predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Constant(value='TSDataset'))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute distance matrix and return it.\n\n        Parameters\n        ----------\n        ts:\n           TSDataset with timeseries to compute matrix with\n\n        Returns\n        -------\n        np.ndarray:\n            2D array with distances between series\n        ')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='ts', ctx=Load())], keywords=[]), attr='predict', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='DistanceMatrix')], ctx=Load()))], type_ignores=[])