Module(body=[Expr(value=Constant(value='\nMIT LICENCE\n\nCopyright (c) 2016 Maximilian Christ, Blue Yonder GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the "Software"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n')), ImportFrom(module='builtins', names=[alias(name='str')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='scipy', names=[alias(name='stats')], level=0), Import(names=[alias(name='warnings')]), FunctionDef(name='target_binary_feature_binary_test', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Calculate the feature significance of a binary feature to a binary target as a p-value.\n    Use the two-sided univariate fisher test from :func:`~scipy.stats.fisher_exact` for this.\n\n    :param x: the binary feature vector\n    :type x: pandas.Series\n\n    :param y: the binary target vector\n    :type y: pandas.Series\n\n    :return: the p-value of the feature significance test. Lower p-values indicate a higher feature significance\n    :rtype: float\n\n    :raise: ``ValueError`` if the target or the feature is not binary.\n    ')), Expr(value=Call(func=Name(id='__check_if_pandas_series', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_check_for_nans', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='__check_for_binary_feature', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='__check_for_binary_target', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='x0', ctx=Store()), Name(id='x1', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='unique', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='values', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='y0', ctx=Store()), Name(id='y1', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='unique', ctx=Load()), args=[Attribute(value=Name(id='y', ctx=Load()), attr='values', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n_y1_x0', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sum', ctx=Load()), args=[Compare(left=Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x0', ctx=Load())]), ctx=Load()), ops=[Eq()], comparators=[Name(id='y1', ctx=Load())])], keywords=[])), Assign(targets=[Name(id='n_y0_x0', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x0', ctx=Load())]), ctx=Load())], keywords=[]), op=Sub(), right=Name(id='n_y1_x0', ctx=Load()))), Assign(targets=[Name(id='n_y1_x1', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sum', ctx=Load()), args=[Compare(left=Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x1', ctx=Load())]), ctx=Load()), ops=[Eq()], comparators=[Name(id='y1', ctx=Load())])], keywords=[])), Assign(targets=[Name(id='n_y0_x1', ctx=Store())], value=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x1', ctx=Load())]), ctx=Load())], keywords=[]), op=Sub(), right=Name(id='n_y1_x1', ctx=Load()))), Assign(targets=[Name(id='table', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[List(elts=[Name(id='n_y1_x1', ctx=Load()), Name(id='n_y1_x0', ctx=Load())], ctx=Load()), List(elts=[Name(id='n_y0_x1', ctx=Load()), Name(id='n_y0_x0', ctx=Load())], ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='oddsratio', ctx=Store()), Name(id='p_value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='stats', ctx=Load()), attr='fisher_exact', ctx=Load()), args=[Name(id='table', ctx=Load())], keywords=[keyword(arg='alternative', value=Constant(value='two-sided'))])), Return(value=Name(id='p_value', ctx=Load()))], decorator_list=[]), FunctionDef(name='target_binary_feature_real_test', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y'), arg(arg='test')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Calculate the feature significance of a real-valued feature to a binary target as a p-value.\n    Use either the `Mann-Whitney U` or `Kolmogorov Smirnov` from  :func:`~scipy.stats.mannwhitneyu` or\n    :func:`~scipy.stats.ks_2samp` for this.\n\n    :param x: the real-valued feature vector\n    :type x: pandas.Series\n\n    :param y: the binary target vector\n    :type y: pandas.Series\n\n    :param test: The significance test to be used. Either ``'mann'`` for the Mann-Whitney-U test\n                 or ``'smir'`` for the Kolmogorov-Smirnov test\n    :type test: str\n\n    :return: the p-value of the feature significance test. Lower p-values indicate a higher feature significance\n    :rtype: float\n\n    :raise: ``ValueError`` if the target is not binary.\n    ")), Expr(value=Call(func=Name(id='__check_if_pandas_series', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_check_for_nans', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='__check_for_binary_target', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='y0', ctx=Store()), Name(id='y1', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='unique', ctx=Load()), args=[Attribute(value=Name(id='y', ctx=Load()), attr='values', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_y1', ctx=Store())], value=Subscript(value=Name(id='x', ctx=Load()), slice=Compare(left=Name(id='y', ctx=Load()), ops=[Eq()], comparators=[Name(id='y1', ctx=Load())]), ctx=Load())), Assign(targets=[Name(id='x_y0', ctx=Store())], value=Subscript(value=Name(id='x', ctx=Load()), slice=Compare(left=Name(id='y', ctx=Load()), ops=[Eq()], comparators=[Name(id='y0', ctx=Load())]), ctx=Load())), If(test=Compare(left=Name(id='test', ctx=Load()), ops=[Eq()], comparators=[Constant(value='mann')]), body=[Assign(targets=[Tuple(elts=[Name(id='U', ctx=Store()), Name(id='p_mannwhitu', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='stats', ctx=Load()), attr='mannwhitneyu', ctx=Load()), args=[Name(id='x_y1', ctx=Load()), Name(id='x_y0', ctx=Load())], keywords=[keyword(arg='use_continuity', value=Constant(value=True)), keyword(arg='alternative', value=Constant(value='two-sided'))])), Return(value=Name(id='p_mannwhitu', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='test', ctx=Load()), ops=[Eq()], comparators=[Constant(value='smir')]), body=[Assign(targets=[Tuple(elts=[Name(id='KS', ctx=Store()), Name(id='p_ks', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='stats', ctx=Load()), attr='ks_2samp', ctx=Load()), args=[Name(id='x_y1', ctx=Load()), Name(id='x_y0', ctx=Load())], keywords=[])), Return(value=Name(id='p_ks', ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=Constant(value='Please use a valid entry for test_for_binary_target_real_feature. '), op=Add(), right=Constant(value="Valid entries are 'mann' and 'smir'."))], keywords=[]))])])], decorator_list=[]), FunctionDef(name='target_real_feature_binary_test', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Calculate the feature significance of a binary feature to a real-valued target as a p-value.\n    Use the `Kolmogorov-Smirnov` test from from :func:`~scipy.stats.ks_2samp` for this.\n\n    :param x: the binary feature vector\n    :type x: pandas.Series\n\n    :param y: the real-valued target vector\n    :type y: pandas.Series\n\n    :return: the p-value of the feature significance test. Lower p-values indicate a higher feature significance.\n    :rtype: float\n\n    :raise: ``ValueError`` if the feature is not binary.\n    ')), Expr(value=Call(func=Name(id='__check_if_pandas_series', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_check_for_nans', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='__check_for_binary_feature', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='x0', ctx=Store()), Name(id='x1', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='unique', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='values', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_x1', ctx=Store())], value=Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x1', ctx=Load())]), ctx=Load())), Assign(targets=[Name(id='y_x0', ctx=Store())], value=Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='x', ctx=Load()), ops=[Eq()], comparators=[Name(id='x0', ctx=Load())]), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='KS', ctx=Store()), Name(id='p_value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='stats', ctx=Load()), attr='ks_2samp', ctx=Load()), args=[Name(id='y_x1', ctx=Load()), Name(id='y_x0', ctx=Load())], keywords=[])), Return(value=Name(id='p_value', ctx=Load()))], decorator_list=[]), FunctionDef(name='target_real_feature_real_test', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n    Calculate the feature significance of a real-valued feature to a real-valued target as a p-value.\n    Use `Kendall's tau` from :func:`~scipy.stats.kendalltau` for this.\n\n    :param x: the real-valued feature vector\n    :type x: pandas.Series\n\n    :param y: the real-valued target vector\n    :type y: pandas.Series\n\n    :return: the p-value of the feature significance test. Lower p-values indicate a higher feature significance.\n    :rtype: float\n    ")), Expr(value=Call(func=Name(id='__check_if_pandas_series', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='_check_for_nans', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tau', ctx=Store()), Name(id='p_value', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='stats', ctx=Load()), attr='kendalltau', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[keyword(arg='method', value=Constant(value='asymptotic'))])), Return(value=Name(id='p_value', ctx=Load()))], decorator_list=[]), FunctionDef(name='__check_if_pandas_series', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to check if both x and y are pandas.Series. If not, raises a ``TypeError``.\n\n    :param x: the first object to check.\n    :type x: Any\n\n    :param y: the second object to check.\n    :type y: Any\n\n    :return: None\n    :rtype: None\n\n    :raise: ``TypeError`` if one of the objects is not a pandas.Series.\n    ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='x', ctx=Load()), Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='x should be a pandas Series')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='y', ctx=Load()), Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Constant(value='y should be a pandas Series')], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='y', ctx=Load()), attr='index', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='index', ctx=Load())], keywords=[])])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='X and y need to have the same index!')], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__check_for_binary_target', args=arguments(posonlyargs=[], args=[arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to check if a target column is binary.\n    Checks if only the values true and false (or 0 and 1) are present in the values.\n\n    :param y: the values to check for.\n    :type y: pandas.Series or numpy.array\n\n    :return: None\n    :rtype: None\n\n    :raises: ``ValueError`` if the values are not binary.\n    ')), If(test=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Set(elts=[Constant(value=0), Constant(value=1)])])), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])], keywords=[]), ops=[Gt()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Target is not binary!')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=Constant(value='The binary target should have values 1 and 0 (or True and False). Instead found'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])], keywords=[])), Name(id='RuntimeWarning', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='__check_for_binary_feature', args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to check if a feature column is binary.\n    Checks if only the values true and false (or 0 and 1) are present in the values.\n\n    :param y: the values to check for.\n    :type y: pandas.Series or numpy.array\n\n    :return: None\n    :rtype: None\n\n    :raises: ``ValueError`` if the values are not binary.\n    ')), If(test=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Set(elts=[Constant(value=0), Constant(value=1)])])), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]), ops=[Gt()], comparators=[Constant(value=2)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='[target_binary_feature_binary_test] Feature is not binary!')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Constant(value='A binary feature should have only values 1 and 0 (incl. True and False). Instead found '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='set', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[])), op=Add(), right=Constant(value=" in feature ''")), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load())], keywords=[])), op=Add(), right=Constant(value="''.")), Name(id='RuntimeWarning', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='_check_for_nans', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n    Helper function to check if target or feature contains NaNs.\n    :param x: A feature\n    :type x: pandas.Series\n    :param y: The target\n    :type y: pandas.Series\n    :raises: `ValueError` if target or feature contains NaNs.\n    ')), If(test=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='isnan', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='values', ctx=Load())], keywords=[]), attr='any', ctx=Load()), args=[], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Feature {} contains NaN values'), attr='format', ctx=Load()), args=[Attribute(value=Name(id='x', ctx=Load()), attr='name', ctx=Load())], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='isnan', ctx=Load()), args=[Attribute(value=Name(id='y', ctx=Load()), attr='values', ctx=Load())], keywords=[]), attr='any', ctx=Load()), args=[], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Target contains NaN values')], keywords=[]))], orelse=[])])], decorator_list=[])], type_ignores=[])