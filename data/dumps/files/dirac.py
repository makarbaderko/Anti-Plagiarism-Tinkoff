Module(body=[ImportFrom(module='collections', names=[alias(name='OrderedDict')], level=0), Import(names=[alias(name='torch')]), ImportFrom(module='probabilistic_embeddings.config', names=[alias(name='prepare_config')], level=0), ImportFrom(module='common', names=[alias(name='DistributionBase'), alias(name='BatchNormNormalizer')], level=1), ClassDef(name='DiracDistribution', bases=[Name(id='DistributionBase', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Single-point distribution with infinity density in one point and zero in others.')), FunctionDef(name='get_default_config', args=arguments(posonlyargs=[], args=[arg(arg='dim'), arg(arg='spherical')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=512), Constant(value=False)]), body=[Expr(value=Constant(value='Get distribution parameters.\n\n        Args:\n            dim: Point dimension.\n            spherical: Whether distribution is on sphere or R^n.\n        ')), Return(value=Call(func=Name(id='OrderedDict', ctx=Load()), args=[List(elts=[Tuple(elts=[Constant(value='dim'), Name(id='dim', ctx=Load())], ctx=Load()), Tuple(elts=[Constant(value='spherical'), Name(id='spherical', ctx=Load())], ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='config')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Store())], value=Call(func=Name(id='prepare_config', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='config', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='dim', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Point dimension.')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), slice=Constant(value='dim'), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='is_spherical', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether distribution is on sphere or R^n.')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), slice=Constant(value='spherical'), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='has_confidences', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether distribution has builtin confidence estimation or not.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='num_parameters', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Number of distribution parameters.')), Return(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), slice=Constant(value='dim'), ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())]), FunctionDef(name='unpack_parameters', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns dict with distribution parameters.')), Return(value=Dict(keys=[Constant(value='mean')], values=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])]))], decorator_list=[]), FunctionDef(name='pack_parameters', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns vector from parameters dict.')), Assign(targets=[Name(id='keys', ctx=Store())], value=Set(elts=[Constant(value='mean')])), If(test=Compare(left=Call(func=Name(id='set', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='keys', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Expected dict with keys {}.'), attr='format', ctx=Load()), args=[Name(id='keys', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Subscript(value=Name(id='parameters', ctx=Load()), slice=Constant(value='mean'), ctx=Load()), attr='shape', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='dim', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Parameters dim mismatch.')], keywords=[]))], orelse=[]), Return(value=Subscript(value=Name(id='parameters', ctx=Load()), slice=Constant(value='mean'), ctx=Load()))], decorator_list=[]), FunctionDef(name='make_normalizer', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Create and return normalization layer.')), Return(value=Call(func=Name(id='BatchNormNormalizer', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='num_parameters', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='sample', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters'), arg(arg='size')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Sample from distributions.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n            size: Sample size (output shape without dimension). Parameters must be broadcastable to the given size.\n              If not provided, output shape will be consistent with parameters.\n\n        Returns:\n            Tuple of:\n                - Samples with shape (..., D).\n                - Choosen components with shape (...).\n        ')), If(test=Compare(left=Name(id='size', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='size', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='parameters', ctx=Load()), attr='shape', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='means', ctx=Load()), attr='broadcast_to', ctx=Load()), args=[BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Name(id='size', ctx=Load())], keywords=[]), op=Add(), right=List(elts=[Attribute(value=Name(id='self', ctx=Load()), attr='dim', ctx=Load())], ctx=Load()))], keywords=[])), Assign(targets=[Name(id='components', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='size', ctx=Load())], keywords=[keyword(arg='dtype', value=Attribute(value=Name(id='torch', ctx=Load()), attr='long', ctx=Load())), keyword(arg='device', value=Attribute(value=Name(id='parameters', ctx=Load()), attr='device', ctx=Load()))])), Return(value=Tuple(elts=[Name(id='means', ctx=Load()), Name(id='components', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='mean', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Extract mean for each distribution.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n\n        Returns:\n            Distribution means with shape (..., D).\n        ')), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='parameters', ctx=Load()), attr='shape', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Unexpected number of parameters: {} != {}.'), attr='format', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='parameters', ctx=Load()), attr='shape', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='num_parameters', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='means', ctx=Store())], value=IfExp(test=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_config', ctx=Load()), slice=Constant(value='spherical'), ctx=Load()), body=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='nn', ctx=Load()), attr='functional', ctx=Load()), attr='normalize', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[keyword(arg='dim', value=UnaryOp(op=USub(), operand=Constant(value=1)))]), orelse=Name(id='parameters', ctx=Load()))), Return(value=Name(id='means', ctx=Load()))], decorator_list=[]), FunctionDef(name='modes', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get modes of distributions.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n\n        Returns:\n            Tuple of mode log probabilities with shape (..., C) and modes with shape (..., C, D).\n        ')), Assign(targets=[Name(id='modes', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[]), attr='unsqueeze', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=2))], keywords=[])), Assign(targets=[Name(id='log_probs', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='zeros_like', ctx=Load()), args=[Subscript(value=Name(id='modes', ctx=Load()), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='log_probs', ctx=Load()), Name(id='modes', ctx=Load())], ctx=Load()))], decorator_list=[]), FunctionDef(name='confidences', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get confidence score for each element of the batch.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n\n        Returns:\n            Confidences with shape (...).\n        ')), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value="Dirac distribution doesn't have confidence.")], keywords=[]))], decorator_list=[]), FunctionDef(name='prior_kld', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get KL-divergence between distributions and prior.\n\n        Is not defined for dirac.\n        ')), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value='KLD is meaningless for dirac distribution.')], keywords=[]))], decorator_list=[]), FunctionDef(name='logpdf', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute log density for all points.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n            points: Points for density evaluation with shape (..., D).\n\n        Returns:\n            Log probabilities with shape (...).\n        ')), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value="Logpdf can't be estimated for Dirac density since it can be infinity.")], keywords=[]))], decorator_list=[]), FunctionDef(name='logmls', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters1'), arg(arg='parameters2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute Log Mutual Likelihood Score (MLS) for pairs of distributions.\n\n        Args:\n            parameters1: Distribution parameters with shape (..., K).\n            parameters2: Distribution parameters with shape (..., K).\n\n        Returns:\n            MLS scores with shape (...).\n        ')), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value="MLS can't be estimated for Dirac density since it can be infinity.")], keywords=[]))], decorator_list=[]), FunctionDef(name='pdf_product', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters1'), arg(arg='paramaters2')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Compute product of two densities.\n\n        Returns:\n            Tuple of new distribution class and it's parameters.\n        ")), Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Constant(value="PDF product can't be estimated for Dirac density since it is unstable.")], keywords=[]))], decorator_list=[]), FunctionDef(name='statistics', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute useful statistics for logging.\n\n        Args:\n            parameters: Distribution parameters with shape (..., K).\n\n        Returns:\n            Dictionary with floating-point statistics values.\n        ')), Return(value=Dict(keys=[], values=[]))], decorator_list=[])], decorator_list=[])], type_ignores=[])