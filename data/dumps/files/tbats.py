Module(body=[ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='tbats.abstract', names=[alias(name='ContextInterface')], level=0), ImportFrom(module='tbats.abstract', names=[alias(name='Estimator')], level=0), ImportFrom(module='tbats.bats', names=[alias(name='BATS')], level=0), ImportFrom(module='tbats.tbats', names=[alias(name='TBATS')], level=0), ImportFrom(module='tbats.tbats.Model', names=[alias(name='Model')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.utils', names=[alias(name='determine_num_steps')], level=0), ClassDef(name='_TBATSAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='model', annotation=Name(id='Estimator', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Name(id='model', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='freq', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='infer_freq', ctx=Load()), args=[Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())], keywords=[keyword(arg='warn', value=Constant(value=False))])), If(test=Compare(left=Name(id='freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't determine frequency of a given dataframe")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="It is not possible to make in-sample predictions with BATS/TBATS model! In-sample predictions aren't supported by current implementation.")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='steps_to_forecast', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), Assign(targets=[Name(id='steps_to_skip', ctx=Store())], value=BinOp(left=Name(id='steps_to_forecast', ctx=Load()), op=Sub(), right=Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()))), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), If(test=Name(id='prediction_interval', ctx=Load()), body=[For(target=Name(id='quantile', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='pred', ctx=Store()), Name(id='confidence_intervals', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='steps_to_forecast', ctx=Load())), keyword(arg='confidence_level', value=Name(id='quantile', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load())), If(test=Compare(left=Name(id='quantile', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Constant(value=1), op=Div(), right=Constant(value=2))]), body=[Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='confidence_intervals', ctx=Load()), slice=Constant(value='lower_bound'), ctx=Load()))], orelse=[Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='confidence_intervals', ctx=Load()), slice=Constant(value='upper_bound'), ctx=Load()))])], orelse=[])], orelse=[Assign(targets=[Name(id='pred', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='steps_to_forecast', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load()))]), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='y_pred', ctx=Load()), attr='iloc', ctx=Load()), slice=Slice(lower=Name(id='steps_to_skip', ctx=Load())), ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Method predict isn't currently implemented!")], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal :py:class:`tbats.tbats.Model` model that was fitted inside etna class.\n\n        Returns\n        -------\n        :\n           Internal model\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()))], decorator_list=[], returns=Name(id='Model', ctx=Load()))], decorator_list=[]), ClassDef(name='BATSModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding segment interval BATS model.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='use_box_cox', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='show_warnings', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='str', ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Expr(value=Constant(value="Create BATSModel with given parameters.\n\n        Parameters\n        ----------\n        use_box_cox: bool or None, optional (default=None)\n            If Box-Cox transformation of original series should be applied.\n            When None both cases shall be considered and better is selected by AIC.\n        box_cox_bounds: tuple, shape=(2,), optional (default=(0, 1))\n            Minimal and maximal Box-Cox parameter values.\n        use_trend: bool or None, optional (default=None)\n            Indicates whether to include a trend or not.\n            When None both cases shall be considered and better is selected by AIC.\n        use_damped_trend: bool or None, optional (default=None)\n            Indicates whether to include a damping parameter in the trend or not.\n            Applies only when trend is used.\n            When None both cases shall be considered and better is selected by AIC.\n        seasonal_periods: iterable or array-like of int values, optional (default=None)\n            Length of each of the periods (amount of observations in each period).\n            BATS accepts only int values here.\n            When None or empty array, non-seasonal model shall be fitted.\n        use_arma_errors: bool, optional (default=True)\n            When True BATS will try to improve the model by modelling residuals with ARMA.\n            Best model will be selected by AIC.\n            If False, ARMA residuals modeling will not be considered.\n        show_warnings: bool, optional (default=True)\n            If warnings should be shown or not.\n            Also see Model.warnings variable that contains all model related warnings.\n        n_jobs: int, optional (default=None)\n            How many jobs to run in parallel when fitting BATS model.\n            When not provided BATS shall try to utilize all available cpu cores.\n        multiprocessing_start_method: str, optional (default='spawn')\n            How threads should be started.\n            See https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\n        context: abstract.ContextInterface, optional (default=None)\n            For advanced users only. Provide this to override default behaviors\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='BATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='use_box_cox', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_errors', ctx=Load())), keyword(arg='show_warnings', value=Name(id='show_warnings', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='context', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='TBATSModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding segment interval TBATS model.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='use_box_cox', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='show_warnings', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='str', ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Expr(value=Constant(value="Create TBATSModel with given parameters.\n\n        Parameters\n        ----------\n        use_box_cox: bool or None, optional (default=None)\n            If Box-Cox transformation of original series should be applied.\n            When None both cases shall be considered and better is selected by AIC.\n        box_cox_bounds: tuple, shape=(2,), optional (default=(0, 1))\n            Minimal and maximal Box-Cox parameter values.\n        use_trend: bool or None, optional (default=None)\n            Indicates whether to include a trend or not.\n            When None both cases shall be considered and better is selected by AIC.\n        use_damped_trend: bool or None, optional (default=None)\n            Indicates whether to include a damping parameter in the trend or not.\n            Applies only when trend is used.\n            When None both cases shall be considered and better is selected by AIC.\n        seasonal_periods: iterable or array-like of floats, optional (default=None)\n            Length of each of the periods (amount of observations in each period).\n            TBATS accepts int and float values here.\n            When None or empty array, non-seasonal model shall be fitted.\n        use_arma_errors: bool, optional (default=True)\n            When True BATS will try to improve the model by modelling residuals with ARMA.\n            Best model will be selected by AIC.\n            If False, ARMA residuals modeling will not be considered.\n        show_warnings: bool, optional (default=True)\n            If warnings should be shown or not.\n            Also see Model.warnings variable that contains all model related warnings.\n        n_jobs: int, optional (default=None)\n            How many jobs to run in parallel when fitting BATS model.\n            When not provided BATS shall try to utilize all available cpu cores.\n        multiprocessing_start_method: str, optional (default='spawn')\n            How threads should be started.\n            See https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\n        context: abstract.ContextInterface, optional (default=None)\n            For advanced users only. Provide this to override default behaviors\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='TBATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='use_box_cox', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_errors', ctx=Load())), keyword(arg='show_warnings', value=Name(id='show_warnings', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='context', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])