Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='statsmodels.tsa.holtwinters', names=[alias(name='ExponentialSmoothing')], level=0), ImportFrom(module='statsmodels.tsa.holtwinters.results', names=[alias(name='HoltWintersResultsWrapper')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='NonPredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='NonPredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ClassDef(name='_HoltWintersAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Class for holding Holt-Winters' exponential smoothing model.\n\n    Notes\n    -----\n    We use :py:class:`statsmodels.tsa.holtwinters.ExponentialSmoothing` model from statsmodels package.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='damped_trend', annotation=Name(id='bool', ctx=Load())), arg(arg='seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='initialization_method', annotation=Name(id='str', ctx=Load())), arg(arg='initial_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='initial_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='initial_seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_boxcox', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='bounds', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missing', annotation=Name(id='str', ctx=Load())), arg(arg='smoothing_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='damping_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='fit_kwargs'), defaults=[Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='estimated'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Init Holt-Winters\' model with given params.\n\n        Parameters\n        ----------\n        trend:\n            Type of trend component. One of:\n\n            * \'add\'\n\n            * \'mul\'\n\n            * \'additive\'\n\n            * \'multiplicative\'\n\n            * None\n\n        damped_trend:\n            Should the trend component be damped.\n        seasonal:\n            Type of seasonal component. One of:\n\n            * \'add\'\n\n            * \'mul\'\n\n            * \'additive\'\n\n            * \'multiplicative\'\n\n            * None\n\n        seasonal_periods:\n            The number of periods in a complete seasonal cycle, e.g., 4 for\n            quarterly data or 7 for daily data with a weekly cycle.\n        initialization_method:\n            Method for initialize the recursions. One of:\n\n            * None\n\n            * \'estimated\'\n\n            * \'heuristic\'\n\n            * \'legacy-heuristic\'\n\n            * \'known\'\n\n            None defaults to the pre-0.12 behavior where initial values\n            are passed as part of ``fit``. If any of the other values are\n            passed, then the initial values must also be set when constructing\n            the model. If \'known\' initialization is used, then ``initial_level``\n            must be passed, as well as ``initial_trend`` and ``initial_seasonal`` if\n            applicable. Default is \'estimated\'. "legacy-heuristic" uses the same\n            values that were used in statsmodels 0.11 and earlier.\n        initial_level:\n            The initial level component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        initial_trend:\n            The initial trend component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        initial_seasonal:\n            The initial seasonal component. An array of length `seasonal`\n            or length ``seasonal - 1`` (in which case the last initial value\n            is computed to make the average effect zero). Only used if\n            initialization is \'known\'. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        use_boxcox: {True, False, \'log\', float}, optional\n            Should the Box-Cox transform be applied to the data first? One of:\n\n            * True\n\n            * False\n\n            * \'log\': apply log\n\n            * float: lambda value\n\n        bounds:\n            An dictionary containing bounds for the parameters in the model,\n            excluding the initial values if estimated. The keys of the dictionary\n            are the variable names, e.g., smoothing_level or initial_slope.\n            The initial seasonal variables are labeled initial_seasonal.<j>\n            for j=0,...,m-1 where m is the number of period in a full season.\n            Use None to indicate a non-binding constraint, e.g., (0, None)\n            constrains a parameter to be non-negative.\n        dates:\n            An array-like object of datetime objects. If a Pandas object is given\n            for endog, it is assumed to have a DateIndex.\n        freq:\n            The frequency of the time-series. A Pandas offset or \'B\', \'D\', \'W\',\n            \'M\', \'A\', or \'Q\'. This is optional if dates are given.\n        missing:\n            Available options are \'none\', \'drop\', and \'raise\'. If \'none\', no nan\n            checking is done. If \'drop\', any observations with nans are dropped.\n            If \'raise\', an error is raised. Default is \'none\'.\n        smoothing_level:\n            The alpha value of the simple exponential smoothing, if the value\n            is set then this value will be used as the value.\n        smoothing_trend:\n            The beta value of the Holt\'s trend method, if the value is\n            set then this value will be used as the value.\n        smoothing_seasonal:\n            The gamma value of the holt winters seasonal method, if the value\n            is set then this value will be used as the value.\n        damping_trend:\n            The phi value of the damped method, if the value is\n            set then this value will be used as the value.\n        fit_kwargs:\n            Additional parameters for calling :py:meth:`statsmodels.tsa.holtwinters.ExponentialSmoothing.fit`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='damped_trend', ctx=Store())], value=Name(id='damped_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal', ctx=Store())], value=Name(id='seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_periods', ctx=Store())], value=Name(id='seasonal_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initialization_method', ctx=Store())], value=Name(id='initialization_method', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_level', ctx=Store())], value=Name(id='initial_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_trend', ctx=Store())], value=Name(id='initial_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_seasonal', ctx=Store())], value=Name(id='initial_seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_boxcox', ctx=Store())], value=Name(id='use_boxcox', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bounds', ctx=Store())], value=Name(id='bounds', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_level', ctx=Store())], value=Name(id='smoothing_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_trend', ctx=Store())], value=Name(id='smoothing_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_seasonal', ctx=Store())], value=Name(id='smoothing_seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='damping_trend', ctx=Store())], value=Name(id='damping_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fit_kwargs', ctx=Store())], value=Name(id='fit_kwargs', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ExponentialSmoothing', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='HoltWintersResultsWrapper', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Fit Holt-Winters' model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        regressors:\n            List of the columns with regressors(ignored in this model)\n        Returns\n        -------\n        :\n            Fitted model\n        ")), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='targets', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='targets', ctx=Load()), attr='index', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Call(func=Name(id='ExponentialSmoothing', ctx=Load()), args=[], keywords=[keyword(arg='endog', value=Name(id='targets', ctx=Load())), keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='damped_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='damped_trend', ctx=Load())), keyword(arg='seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal', ctx=Load())), keyword(arg='seasonal_periods', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_periods', ctx=Load())), keyword(arg='initialization_method', value=Attribute(value=Name(id='self', ctx=Load()), attr='initialization_method', ctx=Load())), keyword(arg='initial_level', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_level', ctx=Load())), keyword(arg='initial_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_trend', ctx=Load())), keyword(arg='initial_seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_seasonal', ctx=Load())), keyword(arg='use_boxcox', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_boxcox', ctx=Load())), keyword(arg='bounds', value=Attribute(value=Name(id='self', ctx=Load()), attr='bounds', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='fit', ctx=Load()), args=[], keywords=[keyword(arg='smoothing_level', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_level', ctx=Load())), keyword(arg='smoothing_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_trend', ctx=Load())), keyword(arg='smoothing_seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_seasonal', ctx=Load())), keyword(arg='damping_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='damping_trend', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='fit_kwargs', ctx=Load()))])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_HoltWintersAdapter')), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Compute predictions from a Holt-Winters' model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n\n        Returns\n        -------\n        :\n            Array with predictions\n        ")), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='This model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='forecast', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Load()), attr='predict', ctx=Load()), args=[], keywords=[keyword(arg='start', value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])), keyword(arg='end', value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Attribute(value=Name(id='forecast', ctx=Load()), attr='values', ctx=Load())), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_check_df', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='columns', ctx=Store())], value=Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load())), Assign(targets=[Name(id='columns_not_used', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='columns', ctx=Load())], keywords=[]), attr='difference', ctx=Load()), args=[Set(elts=[Constant(value='target'), Constant(value='timestamp')])], keywords=[])), If(test=Name(id='columns_not_used', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='This model does not work with exogenous features and regressors.\n '), FormattedValue(value=Name(id='columns_not_used', ctx=Load()), conversion=-1), Constant(value=' will be dropped')]))]))], orelse=[])], decorator_list=[]), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get :py:class:`statsmodels.tsa.holtwinters.results.HoltWintersResultsWrapper` model that was fitted inside etna class.\n\n        Returns\n        -------\n        :\n           Internal model\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_result', ctx=Load()))], decorator_list=[], returns=Name(id='HoltWintersResultsWrapper', ctx=Load()))], decorator_list=[]), ClassDef(name='HoltWintersModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="\n    Holt-Winters' etna model.\n\n    Notes\n    -----\n    We use :py:class:`statsmodels.tsa.holtwinters.ExponentialSmoothing` model from statsmodels package.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='damped_trend', annotation=Name(id='bool', ctx=Load())), arg(arg='seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='initialization_method', annotation=Name(id='str', ctx=Load())), arg(arg='initial_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='initial_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='initial_seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_boxcox', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='bool', ctx=Load()), Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='bounds', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missing', annotation=Name(id='str', ctx=Load())), arg(arg='smoothing_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_seasonal', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='damping_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='fit_kwargs'), defaults=[Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='estimated'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Init Holt-Winters\' model with given params.\n\n        Parameters\n        ----------\n        trend:\n            Type of trend component. One of:\n\n            * \'add\'\n\n            * \'mul\'\n\n            * \'additive\'\n\n            * \'multiplicative\'\n\n            * None\n\n        damped_trend:\n            Should the trend component be damped.\n        seasonal:\n            Type of seasonal component. One of:\n\n            * \'add\'\n\n            * \'mul\'\n\n            * \'additive\'\n\n            * \'multiplicative\'\n\n            * None\n\n        seasonal_periods:\n            The number of periods in a complete seasonal cycle, e.g., 4 for\n            quarterly data or 7 for daily data with a weekly cycle.\n        initialization_method:\n            Method for initialize the recursions. One of:\n\n            * None\n\n            * \'estimated\'\n\n            * \'heuristic\'\n\n            * \'legacy-heuristic\'\n\n            * \'known\'\n\n            None defaults to the pre-0.12 behavior where initial values\n            are passed as part of ``fit``. If any of the other values are\n            passed, then the initial values must also be set when constructing\n            the model. If \'known\' initialization is used, then ``initial_level``\n            must be passed, as well as ``initial_trend`` and ``initial_seasonal`` if\n            applicable. Default is \'estimated\'. "legacy-heuristic" uses the same\n            values that were used in statsmodels 0.11 and earlier.\n        initial_level:\n            The initial level component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        initial_trend:\n            The initial trend component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        initial_seasonal:\n            The initial seasonal component. An array of length `seasonal`\n            or length ``seasonal - 1`` (in which case the last initial value\n            is computed to make the average effect zero). Only used if\n            initialization is \'known\'. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        use_boxcox: {True, False, \'log\', float}, optional\n            Should the Box-Cox transform be applied to the data first? One of:\n\n            * True\n\n            * False\n\n            * \'log\': apply log\n\n            * float: lambda value\n\n        bounds:\n            An dictionary containing bounds for the parameters in the model,\n            excluding the initial values if estimated. The keys of the dictionary\n            are the variable names, e.g., smoothing_level or initial_slope.\n            The initial seasonal variables are labeled initial_seasonal.<j>\n            for j=0,...,m-1 where m is the number of period in a full season.\n            Use None to indicate a non-binding constraint, e.g., (0, None)\n            constrains a parameter to be non-negative.\n        dates:\n            An array-like object of datetime objects. If a Pandas object is given\n            for endog, it is assumed to have a DateIndex.\n        freq:\n            The frequency of the time-series. A Pandas offset or \'B\', \'D\', \'W\',\n            \'M\', \'A\', or \'Q\'. This is optional if dates are given.\n        missing:\n            Available options are \'none\', \'drop\', and \'raise\'. If \'none\', no nan\n            checking is done. If \'drop\', any observations with nans are dropped.\n            If \'raise\', an error is raised. Default is \'none\'.\n        smoothing_level:\n            The alpha value of the simple exponential smoothing, if the value\n            is set then this value will be used as the value.\n        smoothing_trend:\n            The beta value of the Holt\'s trend method, if the value is\n            set then this value will be used as the value.\n        smoothing_seasonal:\n            The gamma value of the holt winters seasonal method, if the value\n            is set then this value will be used as the value.\n        damping_trend:\n            The phi value of the damped method, if the value is\n            set then this value will be used as the value.\n        fit_kwargs:\n            Additional parameters for calling :py:meth:`statsmodels.tsa.holtwinters.ExponentialSmoothing.fit`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='damped_trend', ctx=Store())], value=Name(id='damped_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal', ctx=Store())], value=Name(id='seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_periods', ctx=Store())], value=Name(id='seasonal_periods', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initialization_method', ctx=Store())], value=Name(id='initialization_method', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_level', ctx=Store())], value=Name(id='initial_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_trend', ctx=Store())], value=Name(id='initial_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_seasonal', ctx=Store())], value=Name(id='initial_seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_boxcox', ctx=Store())], value=Name(id='use_boxcox', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='bounds', ctx=Store())], value=Name(id='bounds', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_level', ctx=Store())], value=Name(id='smoothing_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_trend', ctx=Store())], value=Name(id='smoothing_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_seasonal', ctx=Store())], value=Name(id='smoothing_seasonal', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='damping_trend', ctx=Store())], value=Name(id='damping_trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='fit_kwargs', ctx=Store())], value=Name(id='fit_kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_HoltWintersAdapter', ctx=Load()), args=[], keywords=[keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='damped_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='damped_trend', ctx=Load())), keyword(arg='seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal', ctx=Load())), keyword(arg='seasonal_periods', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_periods', ctx=Load())), keyword(arg='initialization_method', value=Attribute(value=Name(id='self', ctx=Load()), attr='initialization_method', ctx=Load())), keyword(arg='initial_level', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_level', ctx=Load())), keyword(arg='initial_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_trend', ctx=Load())), keyword(arg='initial_seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='initial_seasonal', ctx=Load())), keyword(arg='use_boxcox', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_boxcox', ctx=Load())), keyword(arg='bounds', value=Attribute(value=Name(id='self', ctx=Load()), attr='bounds', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load())), keyword(arg='smoothing_level', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_level', ctx=Load())), keyword(arg='smoothing_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_trend', ctx=Load())), keyword(arg='smoothing_seasonal', value=Attribute(value=Name(id='self', ctx=Load()), attr='smoothing_seasonal', ctx=Load())), keyword(arg='damping_trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='damping_trend', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='fit_kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='HoltModel', bases=[Name(id='HoltWintersModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Holt etna model.\n\n    Restricted version of HoltWinters model.\n\n    Notes\n    -----\n    We use :py:class:`statsmodels.tsa.holtwinters.ExponentialSmoothing` model from statsmodels package.\n    They implement :py:class:`statsmodels.tsa.holtwinters.Holt` model\n    as a restricted version of :py:class:`~statsmodels.tsa.holtwinters.ExponentialSmoothing` model.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='exponential', annotation=Name(id='bool', ctx=Load())), arg(arg='damped_trend', annotation=Name(id='bool', ctx=Load())), arg(arg='initialization_method', annotation=Name(id='str', ctx=Load())), arg(arg='initial_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='initial_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='damping_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='fit_kwargs'), defaults=[Constant(value=False), Constant(value=False), Constant(value='estimated'), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Init Holt model with given params.\n\n        Parameters\n        ----------\n        exponential:\n            Type of trend component. One of:\n\n            * False: additive trend\n\n            * True: multiplicative trend\n\n        damped_trend:\n            Should the trend component be damped.\n        initialization_method:\n            Method for initialize the recursions. One of:\n\n            * None\n\n            * \'estimated\'\n\n            * \'heuristic\'\n\n            * \'legacy-heuristic\'\n\n            * \'known\'\n\n            None defaults to the pre-0.12 behavior where initial values\n            are passed as part of ``fit``. If any of the other values are\n            passed, then the initial values must also be set when constructing\n            the model. If \'known\' initialization is used, then ``initial_level``\n            must be passed, as well as ``initial_trend`` and ``initial_seasonal`` if\n            applicable. Default is \'estimated\'. "legacy-heuristic" uses the same\n            values that were used in statsmodels 0.11 and earlier.\n        initial_level:\n            The initial level component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        initial_trend:\n            The initial trend component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        smoothing_level:\n            The alpha value of the simple exponential smoothing, if the value\n            is set then this value will be used as the value.\n        smoothing_trend:\n            The beta value of the Holt\'s trend method, if the value is\n            set then this value will be used as the value.\n        damping_trend:\n            The phi value of the damped method, if the value is\n            set then this value will be used as the value.\n        fit_kwargs:\n            Additional parameters for calling :py:meth:`statsmodels.tsa.holtwinters.ExponentialSmoothing.fit`.\n        ')), Assign(targets=[Name(id='trend', ctx=Store())], value=IfExp(test=Name(id='exponential', ctx=Load()), body=Constant(value='mul'), orelse=Constant(value='add'))), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='trend', value=Name(id='trend', ctx=Load())), keyword(arg='damped_trend', value=Name(id='damped_trend', ctx=Load())), keyword(arg='initialization_method', value=Name(id='initialization_method', ctx=Load())), keyword(arg='initial_level', value=Name(id='initial_level', ctx=Load())), keyword(arg='initial_trend', value=Name(id='initial_trend', ctx=Load())), keyword(arg='smoothing_level', value=Name(id='smoothing_level', ctx=Load())), keyword(arg='smoothing_trend', value=Name(id='smoothing_trend', ctx=Load())), keyword(arg='damping_trend', value=Name(id='damping_trend', ctx=Load())), keyword(value=Name(id='fit_kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='SimpleExpSmoothingModel', bases=[Name(id='HoltWintersModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Exponential smoothing etna model.\n\n    Restricted version of HoltWinters model.\n\n    Notes\n    -----\n    We use :py:class:`statsmodels.tsa.holtwinters.ExponentialSmoothing` model from statsmodels package.\n    They implement :py:class:`statsmodels.tsa.holtwinters.SimpleExpSmoothing` model\n    as a restricted version of :py:class:`~statsmodels.tsa.holtwinters.ExponentialSmoothing` model.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='initialization_method', annotation=Name(id='str', ctx=Load())), arg(arg='initial_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='smoothing_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='fit_kwargs'), defaults=[Constant(value='estimated'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='\n        Init Exponential smoothing model with given params.\n\n        Parameters\n        ----------\n        initialization_method:\n            Method for initialize the recursions. One of:\n\n            * None\n\n            * \'estimated\'\n\n            * \'heuristic\'\n\n            * \'legacy-heuristic\'\n\n            * \'known\'\n\n            None defaults to the pre-0.12 behavior where initial values\n            are passed as part of ``fit``. If any of the other values are\n            passed, then the initial values must also be set when constructing\n            the model. If \'known\' initialization is used, then ``initial_level``\n            must be passed, as well as ``initial_trend`` and ``initial_seasonal`` if\n            applicable. Default is \'estimated\'. "legacy-heuristic" uses the same\n            values that were used in statsmodels 0.11 and earlier.\n        initial_level:\n            The initial level component. Required if estimation method is "known".\n            If set using either "estimated" or "heuristic" this value is used.\n            This allows one or more of the initial values to be set while\n            deferring to the heuristic for others or estimating the unset\n            parameters.\n        smoothing_level:\n            The alpha value of the simple exponential smoothing, if the value\n            is set then this value will be used as the value.\n        fit_kwargs:\n            Additional parameters for calling :py:meth:`statsmodels.tsa.holtwinters.ExponentialSmoothing.fit`.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='initialization_method', value=Name(id='initialization_method', ctx=Load())), keyword(arg='initial_level', value=Name(id='initial_level', ctx=Load())), keyword(arg='smoothing_level', value=Name(id='smoothing_level', ctx=Load())), keyword(value=Name(id='fit_kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])