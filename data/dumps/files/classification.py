Module(body=[ImportFrom(module='itertools', names=[alias(name='compress')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Set')], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='sklearn.base', names=[alias(name='ClassifierMixin')], level=0), ImportFrom(module='sklearn.metrics', names=[alias(name='precision_recall_fscore_support')], level=0), ImportFrom(module='sklearn.metrics', names=[alias(name='roc_auc_score')], level=0), ImportFrom(module='etna.core', names=[alias(name='BaseMixin')], level=0), ImportFrom(module='etna.experimental.classification.base', names=[alias(name='PickleSerializable')], level=0), ImportFrom(module='etna.experimental.classification.feature_extraction.base', names=[alias(name='BaseTimeSeriesFeatureExtractor')], level=0), ImportFrom(module='etna.loggers', names=[alias(name='tslogger')], level=0), ClassDef(name='TimeSeriesBinaryClassifier', bases=[Name(id='BaseMixin', ctx=Load()), Name(id='PickleSerializable', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding time series binary classification.')), Assign(targets=[Name(id='NEGATIVE_CLASS', ctx=Store())], value=Constant(value=0)), Assign(targets=[Name(id='POSITIVE_CLASS', ctx=Store())], value=Constant(value=1)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='feature_extractor', annotation=Name(id='BaseTimeSeriesFeatureExtractor', ctx=Load())), arg(arg='classifier', annotation=Name(id='ClassifierMixin', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.5)]), body=[Expr(value=Constant(value='Init TimeSeriesClassifier with given parameters.\n\n        Parameters\n        ----------\n        feature_extractor:\n            Instance of time series feature extractor.\n        classifier:\n            Instance of classifier with sklearn interface.\n        threshold:\n            Positive class probability threshold.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_extractor', ctx=Store())], value=Name(id='feature_extractor', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='classifier', ctx=Store())], value=Name(id='classifier', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Set', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit the classifier.\n\n        Parameters\n        ----------\n        x:\n            Array with time series.\n        y:\n            Array of class labels.\n\n        Returns\n        -------\n        :\n            Fitted instance of classifier.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Name(id='y', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Load()), op=Sub(), right=Set(elts=[Constant(value=0), Constant(value=1)]))], keywords=[]), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only the 0 - negative and 1 - positive are possible values for the class labels!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='x_tr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_extractor', ctx=Load()), attr='fit_transform', ctx=Load()), args=[Name(id='x', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='classifier', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='x_tr', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='TimeSeriesBinaryClassifier')), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Predict classes with threshold.\n\n        Parameters\n        ----------\n        x:\n           Array with time series.\n\n        Returns\n        -------\n        :\n            Array with predicted labels.\n        ')), Assign(targets=[Name(id='y_prob_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='predict_proba', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Compare(left=Name(id='y_prob_pred', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='threshold', ctx=Load())]), attr='astype', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='predict_proba', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Predict probabilities of the positive class.\n\n        Parameters\n        ----------\n        x:\n            Array with time series.\n\n        Returns\n        -------\n        :\n            Probabilities for classes.\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Classifier is not fitted!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='x_tr', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_extractor', ctx=Load()), attr='transform', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_probs', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='classifier', ctx=Load()), attr='predict_proba', ctx=Load()), args=[Name(id='x_tr', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='NEGATIVE_CLASS', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Load())]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='POSITIVE_CLASS', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Load())])]), body=[Return(value=Subscript(value=Name(id='y_probs', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=1)], ctx=Load()), ctx=Load()))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='NEGATIVE_CLASS', ctx=Load()), ops=[In()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_classes', ctx=Load())]), body=[Return(value=BinOp(left=Constant(value=1), op=Sub(), right=Subscript(value=Name(id='y_probs', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=0)], ctx=Load()), ctx=Load())))], orelse=[])]), Return(value=Subscript(value=Name(id='y_probs', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=0)], ctx=Load()), ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='masked_crossval_score', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='mask', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Calculate classification metrics on cross-validation.\n\n        Parameters\n        ----------\n        x:\n            Array with time series.\n        y:\n            Array of class labels.\n        mask:\n            Fold mask (array where for each element there is a label of its fold)\n\n        Returns\n        -------\n        :\n            Classification metrics for each fold\n        ')), Assign(targets=[Name(id='roc_auc_scores', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='other_metrics', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='fold', ctx=Store()), iter=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='unique', ctx=Load()), args=[Name(id='mask', ctx=Load())], keywords=[]), body=[Assign(targets=[Tuple(elts=[Name(id='x_train', ctx=Store()), Name(id='y_train', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='compress', ctx=Load()), args=[], keywords=[keyword(arg='data', value=Name(id='x', ctx=Load())), keyword(arg='selectors', value=Compare(left=Name(id='mask', ctx=Load()), ops=[NotEq()], comparators=[Name(id='fold', ctx=Load())]))])], keywords=[]), Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='mask', ctx=Load()), ops=[NotEq()], comparators=[Name(id='fold', ctx=Load())]), ctx=Load())], ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='x_test', ctx=Store()), Name(id='y_test', ctx=Store())], ctx=Store())], value=Tuple(elts=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='compress', ctx=Load()), args=[], keywords=[keyword(arg='data', value=Name(id='x', ctx=Load())), keyword(arg='selectors', value=Compare(left=Name(id='mask', ctx=Load()), ops=[Eq()], comparators=[Name(id='fold', ctx=Load())]))])], keywords=[]), Subscript(value=Name(id='y', ctx=Load()), slice=Compare(left=Name(id='mask', ctx=Load()), ops=[Eq()], comparators=[Name(id='fold', ctx=Load())]), ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='x_train', ctx=Load()), Name(id='y_train', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_prob_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='predict_proba', ctx=Load()), args=[Name(id='x_test', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Compare(left=Name(id='y_prob_pred', ctx=Load()), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='threshold', ctx=Load())]), attr='astype', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='roc_auc_scores', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='roc_auc_score', ctx=Load()), args=[], keywords=[keyword(arg='y_true', value=Name(id='y_test', ctx=Load())), keyword(arg='y_score', value=Name(id='y_prob_pred', ctx=Load()))])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='other_metrics', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Call(func=Name(id='precision_recall_fscore_support', ctx=Load()), args=[], keywords=[keyword(arg='y_true', value=Name(id='y_test', ctx=Load())), keyword(arg='y_pred', value=Name(id='y_pred', ctx=Load())), keyword(arg='average', value=Constant(value='macro'))]), slice=Slice(upper=UnaryOp(op=USub(), operand=Constant(value=1))), ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Name(id='per_fold_metrics', ctx=Store()), annotation=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load()), ctx=Load()), value=DictComp(key=Name(id='metric', ctx=Load()), value=List(elts=[], ctx=Load()), generators=[comprehension(target=Name(id='metric', ctx=Store()), iter=List(elts=[Constant(value='precision'), Constant(value='recall'), Constant(value='fscore')], ctx=Load()), ifs=[], is_async=0)]), simple=1), For(target=Name(id='fold_metrics', ctx=Store()), iter=Name(id='other_metrics', ctx=Load()), body=[For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='metric', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[List(elts=[Constant(value='precision'), Constant(value='recall'), Constant(value='fscore')], ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Name(id='per_fold_metrics', ctx=Load()), slice=Name(id='metric', ctx=Load()), ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='fold_metrics', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Subscript(value=Name(id='per_fold_metrics', ctx=Load()), slice=Constant(value='AUC'), ctx=Store())], value=Name(id='roc_auc_scores', ctx=Load())), Assign(targets=[Name(id='mean_metrics', ctx=Store())], value=DictComp(key=Name(id='metric', ctx=Load()), value=Call(func=Name(id='float', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Tuple(elts=[Name(id='metric', ctx=Store()), Name(id='values', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='per_fold_metrics', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='tslogger', ctx=Load()), attr='start_experiment', ctx=Load()), args=[], keywords=[keyword(arg='job_type', value=Constant(value='metrics')), keyword(arg='group', value=Constant(value='all'))])), Expr(value=Call(func=Attribute(value=Name(id='tslogger', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='mean_metrics', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='tslogger', ctx=Load()), attr='finish_experiment', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='per_fold_metrics', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='list', ctx=Load())], ctx=Load()), ctx=Load()))], decorator_list=[])], type_ignores=[])