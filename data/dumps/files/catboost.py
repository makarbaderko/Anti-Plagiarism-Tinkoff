Module(body=[ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='catboost', names=[alias(name='CatBoostRegressor')], level=0), ImportFrom(module='catboost', names=[alias(name='Pool')], level=0), ImportFrom(module='deprecated', names=[alias(name='deprecated')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='NonPredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='MultiSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='NonPredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ClassDef(name='_CatBoostAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logging_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_reg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='CatBoostRegressor', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='logging_level', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_reg', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='_prepare_float_category_columns', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Load()), attr='astype', ctx=Load()), args=[Name(id='str', ctx=Load())], keywords=[]), attr='astype', ctx=Load()), args=[Constant(value='category')], keywords=[]))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Fit Catboost model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        regressors:\n            List of the columns with regressors(ignored in this model)\n\n        Returns\n        -------\n        :\n            Fitted model\n        ')), Assign(targets=[Name(id='features', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Name(id='columns_dtypes', ctx=Store())], value=Attribute(value=Name(id='features', ctx=Load()), attr='dtypes', ctx=Load())), Assign(targets=[Name(id='category_columns_dtypes', ctx=Store())], value=Subscript(value=Name(id='columns_dtypes', ctx=Load()), slice=Compare(left=Name(id='columns_dtypes', ctx=Load()), ops=[Eq()], comparators=[Constant(value='category')]), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='category_columns_dtypes', ctx=Load()), attr='index', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='float_category_columns_dtypes_indices', ctx=Store())], value=ListComp(elt=Name(id='idx', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='category_columns_dtypes', ctx=Load())], keywords=[]), ifs=[Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Attribute(value=Attribute(value=Name(id='x', ctx=Load()), attr='categories', ctx=Load()), attr='dtype', ctx=Load()), attr='type', ctx=Load()), Tuple(elts=[Name(id='float', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='floating', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Name(id='float_category_columns_dtypes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='category_columns_dtypes', ctx=Load()), attr='iloc', ctx=Load()), slice=Name(id='float_category_columns_dtypes_indices', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='float_category_columns', ctx=Store())], value=Attribute(value=Name(id='float_category_columns_dtypes', ctx=Load()), attr='index', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Store())], value=Name(id='float_category_columns', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[])), Assign(targets=[Name(id='train_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='features', ctx=Load()), Attribute(value=Name(id='target', ctx=Load()), attr='values', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='train_pool', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_CatBoostAdapter')), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute predictions from a Catboost model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n\n        Returns\n        -------\n        :\n            Array with predictions\n        ')), Assign(targets=[Name(id='features', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[])), Assign(targets=[Name(id='predict_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Load()))])), Assign(targets=[Name(id='pred', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='predict_pool', ctx=Load())], keywords=[])), Return(value=Name(id='pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal catboost.CatBoostRegressor model that is used inside etna class.\n\n        Returns\n        -------\n        result:\n           Internal model\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='CatBoostRegressor', ctx=Load()))], decorator_list=[]), ClassDef(name='CatBoostPerSegmentModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding per segment Catboost model.\n\n    Examples\n    --------\n    >>> from etna.datasets import generate_periodic_df\n    >>> from etna.datasets import TSDataset\n    >>> from etna.models import CatBoostPerSegmentModel\n    >>> from etna.transforms import LagTransform\n    >>> classic_df = generate_periodic_df(\n    ...     periods=100,\n    ...     start_time="2020-01-01",\n    ...     n_segments=4,\n    ...     period=7,\n    ...     sigma=3\n    ... )\n    >>> df = TSDataset.to_dataset(df=classic_df)\n    >>> ts = TSDataset(df, freq="D")\n    >>> horizon = 7\n    >>> transforms = [\n    ...     LagTransform(in_column="target", lags=[horizon, horizon+1, horizon+2])\n    ... ]\n    >>> ts.fit_transform(transforms=transforms)\n    >>> future = ts.make_future(horizon)\n    >>> model = CatBoostPerSegmentModel()\n    >>> model.fit(ts=ts)\n    CatBoostPerSegmentModel(iterations = None, depth = None, learning_rate = None,\n    logging_level = \'Silent\', l2_leaf_reg = None, thread_count = None, )\n    >>> forecast = model.forecast(future)\n    >>> pd.options.display.float_format = \'{:,.2f}\'.format\n    >>> forecast[:, :, "target"]\n    segment    segment_0 segment_1 segment_2 segment_3\n    feature       target    target    target    target\n    timestamp\n    2020-04-10      9.00      9.00      4.00      6.00\n    2020-04-11      5.00      2.00      7.00      9.00\n    2020-04-12      0.00      4.00      7.00      9.00\n    2020-04-13      0.00      5.00      9.00      7.00\n    2020-04-14      1.00      2.00      1.00      6.00\n    2020-04-15      5.00      7.00      4.00      7.00\n    2020-04-16      8.00      6.00      2.00      0.00\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logging_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_reg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Create instance of CatBoostPerSegmentModel with given parameters.\n\n        Parameters\n        ----------\n        iterations:\n            The maximum number of trees that can be built when solving\n            machine learning problems. When using other parameters that\n            limit the number of iterations, the final number of trees\n            may be less than the number specified in this parameter.\n        depth:\n            Depth of the tree. The range of supported values depends\n            on the processing unit type and the type of the selected loss function:\n\n            * CPU — Any integer up to 16.\n\n            * GPU — Any integer up to 8 pairwise modes (YetiRank, PairLogitPairwise and\n              QueryCrossEntropy) and up to 16 for all other loss functions.\n        learning_rate:\n            The learning rate. Used for reducing the gradient step.\n            If None the value is defined automatically depending on the number of iterations.\n        logging_level:\n            The logging level to output to stdout.\n            Possible values:\n\n            * Silent — Do not output any logging information to stdout.\n\n            * Verbose — Output the following data to stdout:\n\n                * optimized metric\n\n                * elapsed time of training\n\n                * remaining time of training\n\n            * Info — Output additional information and the number of trees.\n\n            * Debug — Output debugging information.\n\n        l2_leaf_reg:\n            Coefficient at the L2 regularization term of the cost function.\n            Any positive value is allowed.\n        thread_count:\n            The number of threads to use during the training.\n\n            * For CPU. Optimizes the speed of execution. This parameter doesn't affect results.\n            * For GPU. The given value is used for reading the data from the hard drive and does\n              not affect the training.\n              During the training one main thread and one thread for each GPU are used.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logging_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_reg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoostAdapter', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='logging_level', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_reg', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CatBoostMultiSegmentModel', bases=[Name(id='MultiSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding Catboost model for all segments.\n\n    Examples\n    --------\n    >>> from etna.datasets import generate_periodic_df\n    >>> from etna.datasets import TSDataset\n    >>> from etna.models import CatBoostMultiSegmentModel\n    >>> from etna.transforms import LagTransform\n    >>> classic_df = generate_periodic_df(\n    ...     periods=100,\n    ...     start_time="2020-01-01",\n    ...     n_segments=4,\n    ...     period=7,\n    ...     sigma=3\n    ... )\n    >>> df = TSDataset.to_dataset(df=classic_df)\n    >>> ts = TSDataset(df, freq="D")\n    >>> horizon = 7\n    >>> transforms = [\n    ...     LagTransform(in_column="target", lags=[horizon, horizon+1, horizon+2])\n    ... ]\n    >>> ts.fit_transform(transforms=transforms)\n    >>> future = ts.make_future(horizon)\n    >>> model = CatBoostMultiSegmentModel()\n    >>> model.fit(ts=ts)\n    CatBoostMultiSegmentModel(iterations = None, depth = None, learning_rate = None,\n    logging_level = \'Silent\', l2_leaf_reg = None, thread_count = None, )\n    >>> forecast = model.forecast(future)\n    >>> pd.options.display.float_format = \'{:,.2f}\'.format\n    >>> forecast[:, :, "target"].round()\n    segment    segment_0 segment_1 segment_2 segment_3\n    feature       target    target    target    target\n    timestamp\n    2020-04-10      9.00      9.00      4.00      6.00\n    2020-04-11      5.00      2.00      7.00      9.00\n    2020-04-12     -0.00      4.00      7.00      9.00\n    2020-04-13      0.00      5.00      9.00      7.00\n    2020-04-14      1.00      2.00      1.00      6.00\n    2020-04-15      5.00      7.00      4.00      7.00\n    2020-04-16      8.00      6.00      2.00      0.00\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logging_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_reg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Create instance of CatBoostMultiSegmentModel with given parameters.\n\n        Parameters\n        ----------\n        iterations:\n            The maximum number of trees that can be built when solving\n            machine learning problems. When using other parameters that\n            limit the number of iterations, the final number of trees\n            may be less than the number specified in this parameter.\n        depth:\n            Depth of the tree. The range of supported values depends\n            on the processing unit type and the type of the selected loss function:\n\n            * CPU — Any integer up to 16.\n\n            * GPU — Any integer up to 8 pairwise modes (YetiRank, PairLogitPairwise and\n              QueryCrossEntropy) and up to 16 for all other loss functions.\n        learning_rate:\n            The learning rate. Used for reducing the gradient step.\n            If None the value is defined automatically depending on the number of iterations.\n        logging_level:\n            The logging level to output to stdout.\n            Possible values:\n\n            * Silent — Do not output any logging information to stdout.\n\n            * Verbose — Output the following data to stdout:\n\n                * optimized metric\n\n                * elapsed time of training\n\n                * remaining time of training\n\n            * Info — Output additional information and the number of trees.\n\n            * Debug — Output debugging information.\n\n        l2_leaf_reg:\n            Coefficient at the L2 regularization term of the cost function.\n            Any positive value is allowed.\n        thread_count:\n            The number of threads to use during the training.\n\n            * For CPU. Optimizes the speed of execution. This parameter doesn't affect results.\n            * For GPU. The given value is used for reading the data from the hard drive and does\n              not affect the training.\n              During the training one main thread and one thread for each GPU are used.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logging_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_reg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoostAdapter', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='logging_level', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_reg', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CatBoostModelPerSegment', bases=[Name(id='CatBoostPerSegmentModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding per segment Catboost model.\n\n    Warnings\n    --------\n    CatBoostModelPerSegment is deprecated; will be deleted in etna==2.0.\n    Use etna.models.CatBoostPerSegmentModel instead.\n\n    Examples\n    --------\n    >>> from etna.datasets import generate_periodic_df\n    >>> from etna.datasets import TSDataset\n    >>> from etna.models import CatBoostModelPerSegment\n    >>> from etna.transforms import LagTransform\n    >>> classic_df = generate_periodic_df(\n    ...     periods=100,\n    ...     start_time="2020-01-01",\n    ...     n_segments=4,\n    ...     period=7,\n    ...     sigma=3\n    ... )\n    >>> df = TSDataset.to_dataset(df=classic_df)\n    >>> ts = TSDataset(df, freq="D")\n    >>> horizon = 7\n    >>> transforms = [\n    ...     LagTransform(in_column="target", lags=[horizon, horizon+1, horizon+2])\n    ... ]\n    >>> ts.fit_transform(transforms=transforms)\n    >>> future = ts.make_future(horizon)\n    >>> model = CatBoostModelPerSegment()\n    >>> model.fit(ts=ts)\n    CatBoostModelPerSegment(iterations = None, depth = None, learning_rate = None,\n    logging_level = \'Silent\', l2_leaf_reg = None, thread_count = None, )\n    >>> forecast = model.forecast(future)\n    >>> pd.options.display.float_format = \'{:,.2f}\'.format\n    >>> forecast[:, :, "target"]\n    segment    segment_0 segment_1 segment_2 segment_3\n    feature       target    target    target    target\n    timestamp\n    2020-04-10      9.00      9.00      4.00      6.00\n    2020-04-11      5.00      2.00      7.00      9.00\n    2020-04-12      0.00      4.00      7.00      9.00\n    2020-04-13      0.00      5.00      9.00      7.00\n    2020-04-14      1.00      2.00      1.00      6.00\n    2020-04-15      5.00      7.00      4.00      7.00\n    2020-04-16      8.00      6.00      2.00      0.00\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logging_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_reg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Create instance of CatBoostModelPerSegment with given parameters.\n\n        Parameters\n        ----------\n        iterations:\n            The maximum number of trees that can be built when solving\n            machine learning problems. When using other parameters that\n            limit the number of iterations, the final number of trees\n            may be less than the number specified in this parameter.\n        depth:\n            Depth of the tree. The range of supported values depends\n            on the processing unit type and the type of the selected loss function:\n\n            * CPU — Any integer up to 16.\n\n            * GPU — Any integer up to 8 pairwise modes (YetiRank, PairLogitPairwise and\n              QueryCrossEntropy) and up to 16 for all other loss functions.\n        learning_rate:\n            The learning rate. Used for reducing the gradient step.\n            If None the value is defined automatically depending on the number of iterations.\n        logging_level:\n            The logging level to output to stdout.\n            Possible values:\n\n            * Silent — Do not output any logging information to stdout.\n\n            * Verbose — Output the following data to stdout:\n\n                * optimized metric\n\n                * elapsed time of training\n\n                * remaining time of training\n\n            * Info — Output additional information and the number of trees.\n\n            * Debug — Output debugging information.\n\n        l2_leaf_reg:\n            Coefficient at the L2 regularization term of the cost function.\n            Any positive value is allowed.\n        thread_count:\n            The number of threads to use during the training.\n\n            * For CPU. Optimizes the speed of execution. This parameter doesn't affect results.\n            * For GPU. The given value is used for reading the data from the hard drive and does\n              not affect the training.\n              During the training one main thread and one thread for each GPU are used.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logging_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_reg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='logging_level', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_reg', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelPerSegment is deprecated; will be deleted in etna==2.0. Use CatBoostPerSegmentModel instead.'))])]), ClassDef(name='CatBoostModelMultiSegment', bases=[Name(id='CatBoostMultiSegmentModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding Catboost model for all segments.\n\n    Warnings\n    --------\n    CatBoostModelMultiSegment is deprecated; will be deleted in etna==2.0.\n    Use etna.models.CatBoostMultiSegmentModel instead.\n\n    Examples\n    --------\n    >>> from etna.datasets import generate_periodic_df\n    >>> from etna.datasets import TSDataset\n    >>> from etna.models import CatBoostModelMultiSegment\n    >>> from etna.transforms import LagTransform\n    >>> classic_df = generate_periodic_df(\n    ...     periods=100,\n    ...     start_time="2020-01-01",\n    ...     n_segments=4,\n    ...     period=7,\n    ...     sigma=3\n    ... )\n    >>> df = TSDataset.to_dataset(df=classic_df)\n    >>> ts = TSDataset(df, freq="D")\n    >>> horizon = 7\n    >>> transforms = [\n    ...     LagTransform(in_column="target", lags=[horizon, horizon+1, horizon+2])\n    ... ]\n    >>> ts.fit_transform(transforms=transforms)\n    >>> future = ts.make_future(horizon)\n    >>> model = CatBoostModelMultiSegment()\n    >>> model.fit(ts=ts)\n    CatBoostModelMultiSegment(iterations = None, depth = None, learning_rate = None,\n    logging_level = \'Silent\', l2_leaf_reg = None, thread_count = None, )\n    >>> forecast = model.forecast(future)\n    >>> pd.options.display.float_format = \'{:,.2f}\'.format\n    >>> forecast[:, :, "target"].round()\n    segment    segment_0 segment_1 segment_2 segment_3\n    feature       target    target    target    target\n    timestamp\n    2020-04-10      9.00      9.00      4.00      6.00\n    2020-04-11      5.00      2.00      7.00      9.00\n    2020-04-12     -0.00      4.00      7.00      9.00\n    2020-04-13      0.00      5.00      9.00      7.00\n    2020-04-14      1.00      2.00      1.00      6.00\n    2020-04-15      5.00      7.00      4.00      7.00\n    2020-04-16      8.00      6.00      2.00      0.00\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logging_level', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_reg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Create instance of CatBoostModelMultiSegment with given parameters.\n\n        Parameters\n        ----------\n        iterations:\n            The maximum number of trees that can be built when solving\n            machine learning problems. When using other parameters that\n            limit the number of iterations, the final number of trees\n            may be less than the number specified in this parameter.\n        depth:\n            Depth of the tree. The range of supported values depends\n            on the processing unit type and the type of the selected loss function:\n\n            * CPU — Any integer up to 16.\n\n            * GPU — Any integer up to 8 pairwise modes (YetiRank, PairLogitPairwise and\n              QueryCrossEntropy) and up to 16 for all other loss functions.\n        learning_rate:\n            The learning rate. Used for reducing the gradient step.\n            If None the value is defined automatically depending on the number of iterations.\n        logging_level:\n            The logging level to output to stdout.\n            Possible values:\n\n            * Silent — Do not output any logging information to stdout.\n\n            * Verbose — Output the following data to stdout:\n\n                * optimized metric\n\n                * elapsed time of training\n\n                * remaining time of training\n\n            * Info — Output additional information and the number of trees.\n\n            * Debug — Output debugging information.\n\n        l2_leaf_reg:\n            Coefficient at the L2 regularization term of the cost function.\n            Any positive value is allowed.\n        thread_count:\n            The number of threads to use during the training.\n\n            * For CPU. Optimizes the speed of execution. This parameter doesn't affect results.\n            * For GPU. The given value is used for reading the data from the hard drive and does\n              not affect the training.\n              During the training one main thread and one thread for each GPU are used.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logging_level', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_reg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='logging_level', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_reg', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelMultiSegment is deprecated; will be deleted in etna==2.0. Use CatBoostMultiSegmentModel instead.'))])])], type_ignores=[])