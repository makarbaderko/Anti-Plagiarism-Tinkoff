Module(body=[ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna', names=[alias(name='SETTINGS')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), If(test=Attribute(value=Name(id='SETTINGS', ctx=Load()), attr='prophet_required', ctx=Load()), body=[ImportFrom(module='prophet', names=[alias(name='Prophet')], level=0)], orelse=[]), ClassDef(name='_ProphetAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding Prophet model.')), Assign(targets=[Name(id='predefined_regressors_names', ctx=Store())], value=Tuple(elts=[Constant(value='floor'), Constant(value='cap')], ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='growth', annotation=Name(id='str', ctx=Load())), arg(arg='changepoints', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='n_changepoints', annotation=Name(id='int', ctx=Load())), arg(arg='changepoint_range', annotation=Name(id='float', ctx=Load())), arg(arg='yearly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='weekly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='daily_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='holidays', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), arg(arg='seasonality_mode', annotation=Name(id='str', ctx=Load())), arg(arg='seasonality_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='holidays_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='changepoint_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='mcmc_samples', annotation=Name(id='int', ctx=Load())), arg(arg='interval_width', annotation=Name(id='float', ctx=Load())), arg(arg='uncertainty_samples', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stan_backend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='additional_seasonality_params', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='linear'), Constant(value=None), Constant(value=25), Constant(value=0.8), Constant(value='auto'), Constant(value='auto'), Constant(value='auto'), Constant(value=None), Constant(value='additive'), Constant(value=10.0), Constant(value=10.0), Constant(value=0.05), Constant(value=0), Constant(value=0.8), Constant(value=1000), Constant(value=None), Tuple(elts=[], ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Store())], value=Name(id='growth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Store())], value=Name(id='n_changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Store())], value=Name(id='changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Store())], value=Name(id='changepoint_range', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Store())], value=Name(id='yearly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Store())], value=Name(id='weekly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Store())], value=Name(id='daily_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Store())], value=Name(id='holidays', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Store())], value=Name(id='seasonality_mode', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Store())], value=Name(id='seasonality_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Store())], value=Name(id='holidays_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Store())], value=Name(id='changepoint_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Store())], value=Name(id='mcmc_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Store())], value=Name(id='interval_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Store())], value=Name(id='uncertainty_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Store())], value=Name(id='stan_backend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Store())], value=Name(id='additional_seasonality_params', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='Prophet', ctx=Load()), args=[], keywords=[keyword(arg='growth', value=Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Load())), keyword(arg='changepoints', value=Name(id='changepoints', ctx=Load())), keyword(arg='n_changepoints', value=Name(id='n_changepoints', ctx=Load())), keyword(arg='changepoint_range', value=Name(id='changepoint_range', ctx=Load())), keyword(arg='yearly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Load())), keyword(arg='weekly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Load())), keyword(arg='daily_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Load())), keyword(arg='holidays', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Load())), keyword(arg='seasonality_mode', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Load())), keyword(arg='seasonality_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Load())), keyword(arg='holidays_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Load())), keyword(arg='changepoint_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Load())), keyword(arg='mcmc_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Load())), keyword(arg='interval_width', value=Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Load())), keyword(arg='uncertainty_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Load())), keyword(arg='stan_backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Load()))])), For(target=Name(id='seasonality_params', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='add_seasonality', ctx=Load()), args=[], keywords=[keyword(value=Name(id='seasonality_params', ctx=Load()))]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Fits a Prophet model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        regressors:\n            List of the columns with regressors\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Name(id='regressors', ctx=Load())), Assign(targets=[Name(id='prophet_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='y'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='ds'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), For(target=Name(id='regressor', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), body=[If(test=Compare(left=Name(id='regressor', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='predefined_regressors_names', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='add_regressor', ctx=Load()), args=[Name(id='regressor', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_ProphetAdapter')), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute predictions from a Prophet model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution\n\n        Returns\n        -------\n        :\n            DataFrame with predictions\n        ')), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='prophet_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='y'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='ds'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='forecast', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Subscript(value=Name(id='forecast', ctx=Load()), slice=Constant(value='yhat'), ctx=Load())], keywords=[])), If(test=Name(id='prediction_interval', ctx=Load()), body=[Assign(targets=[Name(id='sim_values', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predictive_samples', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), For(target=Name(id='quantile', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Name(id='percentile', ctx=Store())], value=BinOp(left=Name(id='quantile', ctx=Load()), op=Mult(), right=Constant(value=100))), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='yhat_'), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='percentile', ctx=Load()), args=[Subscript(value=Name(id='sim_values', ctx=Load()), slice=Constant(value='yhat'), ctx=Load()), Name(id='percentile', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='rename_dict', ctx=Store())], value=DictComp(key=Name(id='column', ctx=Load()), value=Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='yhat'), Constant(value='target')], keywords=[]), generators=[comprehension(target=Name(id='column', ctx=Store()), iter=Attribute(value=Name(id='y_pred', ctx=Load()), attr='columns', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='yhat')], keywords=[])], is_async=0)])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='y_pred', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='rename_dict', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal prophet.Prophet model that is used inside etna class.\n\n        Returns\n        -------\n        result:\n           Internal model\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='Prophet', ctx=Load()))], decorator_list=[]), ClassDef(name='ProphetModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding Prophet model.\n\n    Notes\n    -----\n    Original Prophet can use features \'cap\' and \'floor\',\n    they should be added to the known_future list on dataset initialization.\n\n    Examples\n    --------\n    >>> from etna.datasets import generate_periodic_df\n    >>> from etna.datasets import TSDataset\n    >>> from etna.models import ProphetModel\n    >>> classic_df = generate_periodic_df(\n    ...     periods=100,\n    ...     start_time="2020-01-01",\n    ...     n_segments=4,\n    ...     period=7,\n    ...     sigma=3\n    ... )\n    >>> df = TSDataset.to_dataset(df=classic_df)\n    >>> ts = TSDataset(df, freq="D")\n    >>> future = ts.make_future(7)\n    >>> model = ProphetModel(growth="flat")\n    >>> model.fit(ts=ts)\n    ProphetModel(growth = \'flat\', changepoints = None, n_changepoints = 25,\n    changepoint_range = 0.8, yearly_seasonality = \'auto\', weekly_seasonality = \'auto\',\n    daily_seasonality = \'auto\', holidays = None, seasonality_mode = \'additive\',\n    seasonality_prior_scale = 10.0, holidays_prior_scale = 10.0, changepoint_prior_scale = 0.05,\n    mcmc_samples = 0, interval_width = 0.8, uncertainty_samples = 1000, stan_backend = None,\n    additional_seasonality_params = (), )\n    >>> forecast = model.forecast(future)\n    >>> forecast\n    segment    segment_0 segment_1 segment_2 segment_3\n    feature       target    target    target    target\n    timestamp\n    2020-04-10      9.00      9.00      4.00      6.00\n    2020-04-11      5.00      2.00      7.00      9.00\n    2020-04-12      0.00      4.00      7.00      9.00\n    2020-04-13      0.00      5.00      9.00      7.00\n    2020-04-14      1.00      2.00      1.00      6.00\n    2020-04-15      5.00      7.00      4.00      7.00\n    2020-04-16      8.00      6.00      2.00      0.00\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='growth', annotation=Name(id='str', ctx=Load())), arg(arg='changepoints', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='n_changepoints', annotation=Name(id='int', ctx=Load())), arg(arg='changepoint_range', annotation=Name(id='float', ctx=Load())), arg(arg='yearly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='weekly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='daily_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='holidays', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), arg(arg='seasonality_mode', annotation=Name(id='str', ctx=Load())), arg(arg='seasonality_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='holidays_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='changepoint_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='mcmc_samples', annotation=Name(id='int', ctx=Load())), arg(arg='interval_width', annotation=Name(id='float', ctx=Load())), arg(arg='uncertainty_samples', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stan_backend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='additional_seasonality_params', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='linear'), Constant(value=None), Constant(value=25), Constant(value=0.8), Constant(value='auto'), Constant(value='auto'), Constant(value='auto'), Constant(value=None), Constant(value='additive'), Constant(value=10.0), Constant(value=10.0), Constant(value=0.05), Constant(value=0), Constant(value=0.8), Constant(value=1000), Constant(value=None), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value="\n        Create instance of Prophet model.\n\n        Parameters\n        ----------\n        growth:\n            Options are ‘linear’ and ‘logistic’. This likely will not be tuned;\n            if there is a known saturating point and growth towards that point\n            it will be included and the logistic trend will be used, otherwise\n            it will be linear.\n        changepoints:\n            List of dates at which to include potential changepoints. If\n            not specified, potential changepoints are selected automatically.\n        n_changepoints:\n            Number of potential changepoints to include. Not used\n            if input ``changepoints`` is supplied. If ``changepoints`` is not supplied,\n            then ``n_changepoints`` potential changepoints are selected uniformly from\n            the first ``changepoint_range`` proportion of the history.\n        changepoint_range:\n            Proportion of history in which trend changepoints will\n            be estimated. Defaults to 0.8 for the first 80%. Not used if\n            ``changepoints`` is specified.\n        yearly_seasonality:\n            By default (‘auto’) this will turn yearly seasonality on if there is\n            a year of data, and off otherwise. Options are [‘auto’, True, False].\n            If there is more than a year of data, rather than trying to turn this\n            off during HPO, it will likely be more effective to leave it on and\n            turn down seasonal effects by tuning ``seasonality_prior_scale``.\n        weekly_seasonality:\n            Same as for ``yearly_seasonality``.\n        daily_seasonality:\n            Same as for ``yearly_seasonality``.\n        holidays:\n            ``pd.DataFrame`` with columns holiday (string) and ds (date type)\n            and optionally columns lower_window and upper_window which specify a\n            range of days around the date to be included as holidays.\n            ``lower_window=-2`` will include 2 days prior to the date as holidays. Also\n            optionally can have a column ``prior_scale`` specifying the prior scale for\n            that holiday.\n        seasonality_mode:\n            'additive' (default) or 'multiplicative'.\n        seasonality_prior_scale:\n            Parameter modulating the strength of the\n            seasonality model. Larger values allow the model to fit larger seasonal\n            fluctuations, smaller values dampen the seasonality. Can be specified\n            for individual seasonalities using ``add_seasonality``.\n        holidays_prior_scale:\n            Parameter modulating the strength of the holiday components model, unless overridden\n            in the holidays input.\n        changepoint_prior_scale:\n            Parameter modulating the flexibility of the\n            automatic changepoint selection. Large values will allow many\n            changepoints, small values will allow few changepoints.\n        mcmc_samples:\n            Integer, if greater than 0, will do full Bayesian inference\n            with the specified number of MCMC samples. If 0, will do MAP\n            estimation.\n        interval_width:\n            Float, width of the uncertainty intervals provided\n            for the forecast. If ``mcmc_samples=0``, this will be only the uncertainty\n            in the trend using the MAP estimate of the extrapolated generative\n            model. If ``mcmc.samples>0``, this will be integrated over all model\n            parameters, which will include uncertainty in seasonality.\n        uncertainty_samples:\n            Number of simulated draws used to estimate\n            uncertainty intervals. Settings this value to 0 or False will disable\n            uncertainty estimation and speed up the calculation.\n        stan_backend:\n            as defined in StanBackendEnum default: None - will try to\n            iterate over all available backends and find the working one\n        additional_seasonality_params: Iterable[Dict[str, Union[int, float, str]]]\n            parameters that describe additional (not 'daily', 'weekly', 'yearly') seasonality that should be\n            added to model; dict with required keys 'name', 'period', 'fourier_order' and optional ones 'prior_scale',\n            'mode', 'condition_name' will be used for :py:meth:`prophet.Prophet.add_seasonality` method call.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Store())], value=Name(id='growth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Store())], value=Name(id='n_changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Store())], value=Name(id='changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Store())], value=Name(id='changepoint_range', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Store())], value=Name(id='yearly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Store())], value=Name(id='weekly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Store())], value=Name(id='daily_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Store())], value=Name(id='holidays', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Store())], value=Name(id='seasonality_mode', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Store())], value=Name(id='seasonality_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Store())], value=Name(id='holidays_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Store())], value=Name(id='changepoint_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Store())], value=Name(id='mcmc_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Store())], value=Name(id='interval_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Store())], value=Name(id='uncertainty_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Store())], value=Name(id='stan_backend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Store())], value=Name(id='additional_seasonality_params', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProphetModel', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_ProphetAdapter', ctx=Load()), args=[], keywords=[keyword(arg='growth', value=Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Load())), keyword(arg='n_changepoints', value=Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Load())), keyword(arg='changepoints', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Load())), keyword(arg='changepoint_range', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Load())), keyword(arg='yearly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Load())), keyword(arg='weekly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Load())), keyword(arg='daily_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Load())), keyword(arg='holidays', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Load())), keyword(arg='seasonality_mode', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Load())), keyword(arg='seasonality_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Load())), keyword(arg='holidays_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Load())), keyword(arg='changepoint_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Load())), keyword(arg='mcmc_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Load())), keyword(arg='interval_width', value=Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Load())), keyword(arg='uncertainty_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Load())), keyword(arg='stan_backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Load())), keyword(arg='additional_seasonality_params', value=Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])