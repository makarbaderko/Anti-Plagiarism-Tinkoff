Module(body=[ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='urllib', names=[alias(name='request')], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='sklearn.base', names=[alias(name='ClassifierMixin')], level=0), ImportFrom(module='etna.datasets', names=[alias(name='TSDataset')], level=0), ImportFrom(module='etna.experimental.classification.classification', names=[alias(name='TimeSeriesBinaryClassifier')], level=0), ImportFrom(module='etna.experimental.classification.feature_extraction.base', names=[alias(name='BaseTimeSeriesFeatureExtractor')], level=0), ImportFrom(module='etna.experimental.classification.utils', names=[alias(name='crop_nans_single_series')], level=0), ClassDef(name='PredictabilityAnalyzer', bases=[Name(id='TimeSeriesBinaryClassifier', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding time series predictability prediction.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='feature_extractor', annotation=Name(id='BaseTimeSeriesFeatureExtractor', ctx=Load())), arg(arg='classifier', annotation=Name(id='ClassifierMixin', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0.5)]), body=[Expr(value=Constant(value='Init PredictabilityAnalyzer with given parameters.\n\n        Parameters\n        ----------\n        feature_extractor:\n            Instance of time series feature extractor.\n        classifier:\n            Instance of classifier with sklearn interface.\n        threshold:\n            Positive class probability threshold.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='feature_extractor', value=Name(id='feature_extractor', ctx=Load())), keyword(arg='classifier', value=Name(id='classifier', ctx=Load())), keyword(arg='threshold', value=Name(id='threshold', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='get_series_from_dataset', args=arguments(posonlyargs=[], args=[arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Transform the dataset into the array with time series samples.\n\n        Series in the result array are sorted in the alphabetical order of the corresponding segment names.\n\n        Parameters\n        ----------\n        ts:\n            TSDataset with the time series.\n\n        Returns\n        -------\n        :\n            Array with time series from TSDataset.\n        ')), Assign(targets=[Name(id='series', ctx=Store())], value=Attribute(value=Attribute(value=Subscript(value=Name(id='ts', ctx=Load()), slice=Tuple(elts=[Slice(), Call(func=Name(id='sorted', ctx=Load()), args=[Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load())], keywords=[]), Constant(value='target')], ctx=Load()), ctx=Load()), attr='values', ctx=Load()), attr='T', ctx=Load())), Assign(targets=[Name(id='series', ctx=Store())], value=ListComp(elt=Call(func=Name(id='crop_nans_single_series', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='series', ctx=Load()), ifs=[], is_async=0)])), Return(value=Name(id='series', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), ctx=Load())), FunctionDef(name='analyze_predictability', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Analyse the time series in the dataset for predictability.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with time series.\n\n        Returns\n        -------\n        :\n            The indicators of predictability for the each segment in the dataset.\n        ')), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_series_from_dataset', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load()))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='predict', ctx=Load()), args=[], keywords=[keyword(arg='x', value=Name(id='x', ctx=Load()))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Name(id='sorted', ctx=Load()), args=[Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load())], keywords=[]), Name(id='y_pred', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_available_models', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the list of available models.')), Return(value=List(elts=[Constant(value='weasel'), Constant(value='tsfresh'), Constant(value='tsfresh_min')], ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='download_model', args=arguments(posonlyargs=[], args=[arg(arg='model_name', annotation=Name(id='str', ctx=Load())), arg(arg='dataset_freq', annotation=Name(id='str', ctx=Load())), arg(arg='path', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Return the list of available models.\n\n        Parameters\n        ----------\n        model_name:\n            Name of the pretrained model.\n        dataset_freq:\n            Frequency of the dataset.\n        path:\n            Path to save the file with model.\n\n        Raises\n        ------\n        ValueError:\n            If the model does not exist in s3.\n        ')), Assign(targets=[Name(id='url', ctx=Store())], value=JoinedStr(values=[Constant(value='http://etna-github-prod.cdn-tinkoff.ru/series_classification/22_11_2022/'), FormattedValue(value=Name(id='dataset_freq', ctx=Load()), conversion=-1), Constant(value='/'), FormattedValue(value=Name(id='model_name', ctx=Load()), conversion=-1), Constant(value='.pickle')])), Try(body=[Expr(value=Call(func=Attribute(value=Name(id='request', ctx=Load()), attr='urlretrieve', ctx=Load()), args=[], keywords=[keyword(arg='url', value=Name(id='url', ctx=Load())), keyword(arg='filename', value=Name(id='path', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model not found! Check the list of available models!')], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[])], type_ignores=[])