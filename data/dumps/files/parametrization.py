Module(body=[Import(names=[alias(name='torch')]), ClassDef(name='Parametrization', bases=[], keywords=[], body=[Expr(value=Constant(value='Mapping from real numbers to non-negative ones and vise-versa.\n\n    Args:\n        type: Type of parametrization (`exp`, `invlin`, `abs` or `sigmoid`).\n        min: Minimum positive value.\n        max: Maximum value for sigmoid parametrization.\n        center: Shift values prior to positive transform.\n        scale: Scale tangent slop at the center.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='type'), arg(arg='min'), arg(arg='max'), arg(arg='center'), arg(arg='scale')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=None), Constant(value=0), Constant(value=1)]), body=[If(test=Compare(left=Name(id='type', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Constant(value='exp'), Constant(value='invlin'), Constant(value='abs'), Constant(value='sigmoid')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='Unknown parametrization: {}.'), attr='format', ctx=Load()), args=[Name(id='type', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='max', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Compare(left=Name(id='type', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='sigmoid')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Maximum is supported for sigmoid parametrization only.')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='max', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Name(id='type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='sigmoid')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Maximum value must be provided for sigmoid parametrization.')], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Store())], value=Name(id='type', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Store())], value=Name(id='min', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max', ctx=Store())], value=Name(id='max', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_center', ctx=Store())], value=Name(id='center', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scale', ctx=Store())], value=Name(id='scale', ctx=Load()))], decorator_list=[]), FunctionDef(name='positive', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Smooth mapping from real to positive numbers.')), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_linear', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='exp')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_exp', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='invlin')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_invlin', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='sigmoid')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_sigmoid', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load())), keyword(arg='max', value=Attribute(value=Name(id='self', ctx=Load()), attr='_max', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='abs')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_abs', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[Assert(test=Constant(value=False))])])])])], decorator_list=[]), FunctionDef(name='log_positive', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Logarithm of positive function.')), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_linear', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='exp')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log_exp', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='invlin')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log_invlin', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='sigmoid')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log_sigmoid', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load())), keyword(arg='max', value=Attribute(value=Name(id='self', ctx=Load()), attr='_max', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='abs')]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_log_abs', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[Assert(test=Constant(value=False))])])])])], decorator_list=[]), FunctionDef(name='ipositive', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Inverse of positive function.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='exp')]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iexp', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='invlin')]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iinvlin', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='sigmoid')]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_isigmoid', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load())), keyword(arg='max', value=Attribute(value=Name(id='self', ctx=Load()), attr='_max', ctx=Load()))]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='abs')]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_iabs', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min', ctx=Load()))]))], orelse=[Assert(test=Constant(value=False))])])])]), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_ilinear', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='_linear', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_scale', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_scale', ctx=Load())))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_center', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_center', ctx=Load())))], orelse=[]), Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='_ilinear', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_center', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_center', ctx=Load())))], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_scale', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=1)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_scale', ctx=Load())))], orelse=[]), Return(value=Name(id='x', ctx=Load()))], decorator_list=[]), FunctionDef(name='_exp', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Smooth mapping from real to positive numbers.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='exp', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Name(id='result', ctx=Load()), op=Add(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_log_exp', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Logarithm of exponential function with min.')), Assign(targets=[Name(id='result', ctx=Store())], value=Name(id='x', ctx=Load())), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='min', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='tensor', ctx=Load()), args=[Name(id='min', ctx=Load())], keywords=[keyword(arg='dtype', value=Attribute(value=Name(id='x', ctx=Load()), attr='dtype', ctx=Load())), keyword(arg='device', value=Attribute(value=Name(id='x', ctx=Load()), attr='device', ctx=Load()))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='logaddexp', ctx=Load()), args=[Name(id='x', ctx=Load()), Call(func=Attribute(value=Name(id='min', ctx=Load()), attr='log', ctx=Load()), args=[], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_iexp', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Inverse of exp function with min.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='log', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_invlin', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Smooth mapping from real to positive numbers.\n\n        Inverse function for x < 0 and linear for x > 0.\n        ')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='x', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), BinOp(left=Constant(value=1), op=Div(), right=BinOp(left=Constant(value=1), op=Sub(), right=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='clip', ctx=Load()), args=[], keywords=[keyword(arg='max', value=Constant(value=0))]))), BinOp(left=Constant(value=1), op=Add(), right=Name(id='x', ctx=Load()))], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Name(id='result', ctx=Load()), op=Add(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_log_invlin', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Logarithm of invlin function.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='is_negative', ctx=Store())], value=Compare(left=Name(id='x', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)])), Assign(targets=[Name(id='nxp1', ctx=Store())], value=BinOp(left=Constant(value=1), op=Sub(), right=Name(id='x', ctx=Load()))), Assign(targets=[Name(id='xp1', ctx=Store())], value=BinOp(left=Constant(value=1), op=Add(), right=Name(id='x', ctx=Load()))), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='xp1', ctx=Store())], value=BinOp(left=Name(id='xp1', ctx=Load()), op=Add(), right=Name(id='min', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='where', ctx=Load()), args=[Name(id='is_negative', ctx=Load()), UnaryOp(op=USub(), operand=Call(func=Attribute(value=Name(id='nxp1', ctx=Load()), attr='log', ctx=Load()), args=[], keywords=[])), Call(func=Attribute(value=Name(id='xp1', ctx=Load()), attr='log', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='nxp1ge1', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='clip', ctx=Load()), args=[Name(id='nxp1', ctx=Load())], keywords=[keyword(arg='min', value=Constant(value=1))])), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Name(id='result', ctx=Load()), op=Add(), right=BinOp(left=Name(id='is_negative', ctx=Load()), op=Mult(), right=Call(func=Attribute(value=BinOp(left=Constant(value=1), op=Add(), right=BinOp(left=Name(id='min', ctx=Load()), op=Mult(), right=Name(id='nxp1ge1', ctx=Load()))), attr='log', ctx=Load()), args=[], keywords=[]))))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_iinvlin', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Inverse of invlin.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='x', ctx=Load()), ops=[Lt()], comparators=[Constant(value=1)]), BinOp(left=Constant(value=1), op=Sub(), right=BinOp(left=Constant(value=1), op=Div(), right=Name(id='x', ctx=Load()))), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Constant(value=1))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_abs', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Mapping from real to positive numbers.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='x', ctx=Load()), attr='abs', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=Name(id='result', ctx=Load()), op=Add(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_log_abs', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Logarithm of abs function.')), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='Parametrization', ctx=Load()), attr='_abs', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(arg='min', value=Name(id='min', ctx=Load()))]), attr='log', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_iabs', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0)]), body=[Expr(value=Constant(value='Inverse of abs (true inverse for positives only).')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='x', ctx=Store())], value=BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load())))], orelse=[]), Return(value=Name(id='x', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_sigmoid', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min'), arg(arg='max')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=1)]), body=[Expr(value=Constant(value='Smooth mapping from real to positive numbers.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[GtE()], comparators=[Name(id='max', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Minimum must be less than maximum.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='sigmoid', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), op=Mult(), right=BinOp(left=Name(id='max', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load()))), op=Add(), right=Name(id='min', ctx=Load()))), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_log_sigmoid', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min'), arg(arg='max')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=1)]), body=[Expr(value=Constant(value='Logarithm of sigmoid function.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[GtE()], comparators=[Name(id='max', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Minimum must be less than maximum.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='sigmoid', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), op=Mult(), right=BinOp(left=Name(id='max', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load()))), op=Add(), right=Name(id='min', ctx=Load()))], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())]), FunctionDef(name='_isigmoid', args=arguments(posonlyargs=[], args=[arg(arg='x'), arg(arg='min'), arg(arg='max')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=0), Constant(value=1)]), body=[Expr(value=Constant(value='Inverse sigmoid.')), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[Lt()], comparators=[Constant(value=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Only non-negative minimum is supported.')], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='min', ctx=Load()), ops=[GtE()], comparators=[Name(id='max', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Minimum must be less than maximum.')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='logit', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load())), op=Div(), right=BinOp(left=Name(id='max', ctx=Load()), op=Sub(), right=Name(id='min', ctx=Load())))], keywords=[keyword(arg='eps', value=BinOp(left=Constant(value=1), op=Sub(), right=Constant(value=6)))])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())])], decorator_list=[])], type_ignores=[])