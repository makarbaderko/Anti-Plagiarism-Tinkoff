Module(body=[ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='etna.datasets', names=[alias(name='TSDataset')], level=0), ImportFrom(module='etna.metrics.base', names=[alias(name='Metric')], level=0), ImportFrom(module='etna.metrics.base', names=[alias(name='MetricAggregationMode')], level=0), FunctionDef(name='dummy', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='np', ctx=Load()), attr='nan', ctx=Load()))], decorator_list=[]), ClassDef(name='_QuantileMetricMixin', bases=[], keywords=[], body=[FunctionDef(name='_validate_tsdataset_quantiles', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Check if quantiles presented in y_pred.')), Assign(targets=[Name(id='features', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load()), attr='columns', ctx=Load()), attr='get_level_values', ctx=Load()), args=[Constant(value='feature')], keywords=[])], keywords=[])), For(target=Name(id='quantile', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assert(test=Compare(left=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ops=[In()], comparators=[Name(id='features', ctx=Load())]), msg=JoinedStr(values=[Constant(value='Quantile '), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1), Constant(value=' is not presented in tsdataset.')]))], orelse=[])], decorator_list=[], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='Coverage', bases=[Name(id='Metric', ctx=Load()), Name(id='_QuantileMetricMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Coverage metric for prediction intervals - precenteage of samples in the interval ``[lower quantile, upper quantile]``.\n\n    .. math::\n        Coverage(y\\_true, y\\_pred) = \\frac{\\sum_{i=0}^{n-1}{[ y\\_true_i \\ge y\\_pred_i^{lower\\_quantile}] * [y\\_true_i \\le y\\_pred_i^{upper\\_quantile}] }}{n}\n\n    Notes\n    -----\n    Works just if quantiles presented in y_pred\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='quantiles', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load()), Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='dummy', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Store())], value=Name(id='quantiles', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='y_true', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='y_pred', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Compute metric's value with y_true and y_pred.\n\n        Notes\n        -----\n        Note that if y_true and y_pred are not sorted Metric will sort it anyway\n\n        Parameters\n        ----------\n        y_true:\n            dataset with true time series values\n        y_pred:\n            dataset with predicted time series values\n\n        Returns\n        -------\n            metric's value aggregated over segments or not (depends on mode)\n        ")), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_segment_columns', ctx=Load()), args=[], keywords=[keyword(arg='y_true', value=Name(id='y_true', ctx=Load())), keyword(arg='y_pred', value=Name(id='y_pred', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_tsdataset_quantiles', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='y_pred', ctx=Load())), keyword(arg='quantiles', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()))])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='y_true', ctx=Load()), attr='df', ctx=Load()), attr='columns', ctx=Load()), attr='get_level_values', ctx=Load()), args=[Constant(value='segment')], keywords=[])], keywords=[])), Assign(targets=[Name(id='metrics_per_segment', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_timestamp_columns', ctx=Load()), args=[], keywords=[keyword(arg='timestamp_true', value=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='y_true', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[]), attr='index', ctx=Load())), keyword(arg='timestamp_pred', value=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[]), attr='index', ctx=Load()))])), Assign(targets=[Name(id='upper_quantile_flag', ctx=Store())], value=Compare(left=Subscript(value=Name(id='y_true', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), ops=[LtE()], comparators=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()), slice=Constant(value=1), ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))])], ctx=Load()), ctx=Load())])), Assign(targets=[Name(id='lower_quantile_flag', ctx=Store())], value=Compare(left=Subscript(value=Name(id='y_true', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), ops=[GtE()], comparators=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()), slice=Constant(value=0), ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))])], ctx=Load()), ctx=Load())])), Assign(targets=[Subscript(value=Name(id='metrics_per_segment', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[BinOp(left=Name(id='upper_quantile_flag', ctx=Load()), op=Mult(), right=Name(id='lower_quantile_flag', ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metrics', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_aggregate_metrics', ctx=Load()), args=[Name(id='metrics_per_segment', ctx=Load())], keywords=[])), Return(value=Name(id='metrics', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=None))], decorator_list=[Name(id='property', ctx=Load())], returns=Constant(value=None))], decorator_list=[]), ClassDef(name='Width', bases=[Name(id='Metric', ctx=Load()), Name(id='_QuantileMetricMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mean width of prediction intervals.\n\n    .. math::\n        Width(y\\_true, y\\_pred) = \\frac{\\sum_{i=0}^{n-1}\\mid y\\_pred_i^{upper\\_quantile} - y\\_pred_i^{lower\\_quantile} \\mid}{n}\n\n    Notes\n    -----\n    Works just if quantiles presented in y_pred\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='quantiles', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='mode', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load()), Attribute(value=Name(id='MetricAggregationMode', ctx=Load()), attr='per_segment', ctx=Load())]), body=[Expr(value=Constant(value="Init metric.\n\n        Parameters\n        ----------\n        mode: 'macro' or 'per-segment'\n            metrics aggregation mode\n        kwargs:\n            metric's computation arguments\n        ")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load())), keyword(arg='metric_fn', value=Name(id='dummy', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Store())], value=Name(id='quantiles', ctx=Load()))], decorator_list=[]), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='y_true', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='y_pred', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="\n        Compute metric's value with y_true and y_pred.\n\n        Notes\n        -----\n        Note that if y_true and y_pred are not sorted Metric will sort it anyway\n\n        Parameters\n        ----------\n        y_true:\n            dataset with true time series values\n        y_pred:\n            dataset with predicted time series values\n\n        Returns\n        -------\n            metric's value aggregated over segments or not (depends on mode)\n        ")), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_segment_columns', ctx=Load()), args=[], keywords=[keyword(arg='y_true', value=Name(id='y_true', ctx=Load())), keyword(arg='y_pred', value=Name(id='y_pred', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_tsdataset_quantiles', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='y_pred', ctx=Load())), keyword(arg='quantiles', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()))])), Assign(targets=[Name(id='segments', ctx=Store())], value=Call(func=Name(id='set', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='y_true', ctx=Load()), attr='df', ctx=Load()), attr='columns', ctx=Load()), attr='get_level_values', ctx=Load()), args=[Constant(value='segment')], keywords=[])], keywords=[])), Assign(targets=[Name(id='metrics_per_segment', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='segment', ctx=Store()), iter=Name(id='segments', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_timestamp_columns', ctx=Load()), args=[], keywords=[keyword(arg='timestamp_true', value=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='y_true', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[]), attr='index', ctx=Load())), keyword(arg='timestamp_pred', value=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Constant(value='target')], ctx=Load()), ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[]), attr='index', ctx=Load()))])), Assign(targets=[Name(id='upper_quantile', ctx=Store())], value=Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()), slice=Constant(value=1), ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))])], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='lower_quantile', ctx=Store())], value=Subscript(value=Name(id='y_pred', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantiles', ctx=Load()), slice=Constant(value=0), ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))])], ctx=Load()), ctx=Load())), Assign(targets=[Subscript(value=Name(id='metrics_per_segment', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lower_quantile', ctx=Load()), op=Sub(), right=Name(id='upper_quantile', ctx=Load()))], keywords=[]), attr='mean', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='metrics', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_aggregate_metrics', ctx=Load()), args=[Name(id='metrics_per_segment', ctx=Load())], keywords=[])), Return(value=Name(id='metrics', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='greater_is_better', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Whether higher metric value is better.')), Return(value=Constant(value=False))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='Coverage'), Constant(value='Width')], ctx=Load()))], type_ignores=[])