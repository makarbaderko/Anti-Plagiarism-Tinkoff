Module(body=[ImportFrom(module='abc', names=[alias(name='ABC')], level=0), ImportFrom(module='abc', names=[alias(name='abstractmethod')], level=0), ImportFrom(module='copy', names=[alias(name='deepcopy')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), ImportFrom(module='typing', names=[alias(name='Callable')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.datasets.tsdataset', names=[alias(name='TSDataset')], level=0), ImportFrom(module='etna.models.decorators', names=[alias(name='log_decorator')], level=0), ClassDef(name='ModelForecastingMixin', bases=[Name(id='ABC', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class for model mixins.')), FunctionDef(name='_forecast', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='_predict', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Pass()], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='NonPredictionIntervalContextIgnorantModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Mixin for models that don't support prediction intervals and don't need context for prediction.")), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_forecast', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make predictions with using true values as autoregression context if possible (teacher forcing).\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_predict', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='NonPredictionIntervalContextRequiredModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Mixin for models that don't support prediction intervals and need context for prediction.")), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_size:\n            Number of last timestamps to leave after making prediction.\n            Previous timestamps will be used as a context for models that require it.\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_forecast', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_size', value=Name(id='prediction_size', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make predictions with using true values as autoregression context if possible (teacher forcing).\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_size:\n            Number of last timestamps to leave after making prediction.\n            Previous timestamps will be used as a context for models that require it.\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_predict', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_size', value=Name(id='prediction_size', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='PredictionIntervalContextIgnorantModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Mixin for models that support prediction intervals and don't need context for prediction.")), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution. By default 2.5% and 97.5% are taken to form a 95% prediction interval\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_forecast', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='Make predictions with using true values as autoregression context if possible (teacher forcing).\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution. By default 2.5% and 97.5% are taken to form a 95% prediction interval\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_predict', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='PredictionIntervalContextRequiredModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mixin for models that support prediction intervals and need context for prediction.')), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_size:\n            Number of last timestamps to leave after making prediction.\n            Previous timestamps will be used as a context for models that require it.\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution. By default 2.5% and 97.5% are taken to form a 95% prediction interval\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_forecast', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_size', value=Name(id='prediction_size', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='Make predictions with using true values as autoregression context if possible (teacher forcing).\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_size:\n            Number of last timestamps to leave after making prediction.\n            Previous timestamps will be used as a context for models that require it.\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution. By default 2.5% and 97.5% are taken to form a 95% prediction interval\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_predict', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_size', value=Name(id='prediction_size', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load()))]))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='PerSegmentModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Mixin for holding methods for per-segment prediction.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base_model', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Init PerSegmentModelMixin.\n\n        Parameters\n        ----------\n        base_model:\n            Internal model which will be used to forecast segments, expected to have fit/predict interface\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Store())], value=Name(id='base_model', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit model.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n\n        Returns\n        -------\n        :\n            Model after fit\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Name(id='segment', ctx=Store()), iter=Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load()), body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Store())], value=Call(func=Name(id='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load())], keywords=[]))], orelse=[]), For(target=Tuple(elts=[Name(id='segment', ctx=Store()), Name(id='model', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='segment_features', ctx=Store())], value=Subscript(value=Name(id='ts', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='segment', ctx=Load()), Slice()], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='segment_features', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment_features', ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='segment_features', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment_features', ctx=Load()), attr='droplevel', ctx=Load()), args=[Constant(value='segment')], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Name(id='segment_features', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment_features', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='model', ctx=Load()), attr='fit', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='segment_features', ctx=Load())), keyword(arg='regressors', value=Attribute(value=Name(id='ts', ctx=Load()), attr='regressors', ctx=Load()))]))], orelse=[]), Return(value=Name(id='self', ctx=Load()))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Constant(value='PerSegmentModelMixin')), FunctionDef(name='_get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal etna base models that are used inside etna class.\n\n        Returns\n        -------\n        :\n           dictionary where key is segment and value is internal model\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Can not get the dict with base models, the model is not fitted!')], keywords=[]))], orelse=[]), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_models', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal models that are used inside etna class.\n\n        Internal model is a model that is used inside etna to forecast segments,\n        e.g. :py:class:`catboost.CatBoostRegressor` or :py:class:`sklearn.linear_model.Ridge`.\n\n        Returns\n        -------\n        :\n           dictionary where key is segment and value is internal model\n        ')), Assign(targets=[Name(id='internal_models', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='segment', ctx=Store()), Name(id='base_model', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_model', ctx=Load()), args=[], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='base_model', ctx=Load()), Constant(value='get_model')], keywords=[])), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Constant(value='get_model method is not implemented for '), FormattedValue(value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='internal_models', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Name(id='base_model', ctx=Load()), attr='get_model', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='internal_models', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_make_predictions_segment', args=arguments(posonlyargs=[], args=[arg(arg='model', annotation=Name(id='Any', ctx=Load())), arg(arg='segment', annotation=Name(id='str', ctx=Load())), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_method', annotation=Name(id='Callable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Make predictions for one segment.')), Assign(targets=[Name(id='segment_features', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Name(id='segment', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='segment_features', ctx=Store())], value=Call(func=Attribute(value=Name(id='segment_features', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='dates', ctx=Store())], value=Subscript(value=Name(id='segment_features', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='dates', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True)), keyword(arg='inplace', value=Constant(value=True))])), Assign(targets=[Name(id='segment_predict', ctx=Store())], value=Call(func=Name(id='prediction_method', ctx=Load()), args=[], keywords=[keyword(arg='self', value=Name(id='model', ctx=Load())), keyword(arg='df', value=Name(id='segment_features', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='segment_predict', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='segment_predict', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Dict(keys=[Constant(value='target')], values=[Name(id='segment_predict', ctx=Load())])], keywords=[]))], orelse=[]), Assign(targets=[Subscript(value=Name(id='segment_predict', ctx=Load()), slice=Constant(value='segment'), ctx=Store())], value=Name(id='segment', ctx=Load())), Assign(targets=[Name(id='prediction_size', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='prediction_size')], keywords=[])), If(test=Compare(left=Name(id='prediction_size', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='segment_predict', ctx=Load()), slice=Constant(value='timestamp'), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='dates', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='prediction_size', ctx=Load()))), ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))]))], orelse=[Assign(targets=[Subscript(value=Name(id='segment_predict', ctx=Load()), slice=Constant(value='timestamp'), ctx=Store())], value=Name(id='dates', ctx=Load()))]), Return(value=Name(id='segment_predict', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='_make_predictions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_method', annotation=Name(id='Callable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataframe with features\n        prediction_method:\n            Method for making predictions\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Assign(targets=[Name(id='result_list', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='to_pandas', ctx=Load()), args=[], keywords=[])), For(target=Tuple(elts=[Name(id='segment', ctx=Store()), Name(id='model', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_model', ctx=Load()), args=[], keywords=[]), attr='items', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='segment_predict', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions_segment', ctx=Load()), args=[], keywords=[keyword(arg='model', value=Name(id='model', ctx=Load())), keyword(arg='segment', value=Name(id='segment', ctx=Load())), keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='prediction_method', value=Name(id='prediction_method', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='result_list', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='segment_predict', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='concat', ctx=Load()), args=[Name(id='result_list', ctx=Load())], keywords=[keyword(arg='ignore_index', value=Constant(value=True))])), Assign(targets=[Name(id='result_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='result_df', ctx=Load()), attr='set_index', ctx=Load()), args=[List(elts=[Constant(value='timestamp'), Constant(value='segment')], ctx=Load())], keywords=[])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='to_pandas', ctx=Load()), args=[], keywords=[keyword(arg='flatten', value=Constant(value=True))])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='set_index', ctx=Load()), args=[List(elts=[Constant(value='timestamp'), Constant(value='segment')], ctx=Load())], keywords=[])), Assign(targets=[Name(id='columns_to_clear', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='result_df', ctx=Load()), attr='columns', ctx=Load()), attr='intersection', ctx=Load()), args=[Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='result_df', ctx=Load()), attr='index', ctx=Load()), Name(id='columns_to_clear', ctx=Load())], ctx=Load()), ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='NaN', ctx=Load())), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='combine_first', ctx=Load()), args=[Name(id='result_df', ctx=Load())], keywords=[]), attr='reset_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='TSDataset', ctx=Load()), attr='to_dataset', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Store())], value=Name(id='df', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='inverse_transform', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='prediction_size', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='prediction_size')], keywords=[])), If(test=Compare(left=Name(id='prediction_size', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Store())], value=Subscript(value=Attribute(value=Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load()), attr='iloc', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='prediction_size', ctx=Load()))), ctx=Load()))], orelse=[]), Return(value=Name(id='ts', ctx=Load()))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='_forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), Constant(value='forecast')], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='forecast', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='predict', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='_predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='predict', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load()))], decorator_list=[]), ClassDef(name='MultiSegmentModelMixin', bases=[Name(id='ModelForecastingMixin', ctx=Load())], keywords=[], body=[Expr(value=Constant(value="Mixin for holding methods for multi-segment prediction.\n\n    It currently isn't working with prediction intervals and context.\n    ")), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base_model', annotation=Name(id='Any', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Init MultiSegmentModel.\n\n        Parameters\n        ----------\n        base_model:\n            Internal model which will be used to forecast segments, expected to have fit/predict interface\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Store())], value=Name(id='base_model', ctx=Load()))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit model.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n\n        Returns\n        -------\n        :\n            Model after fit\n        ')), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='to_pandas', ctx=Load()), args=[], keywords=[keyword(arg='flatten', value=Constant(value=True))])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='dropna', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=Constant(value='segment'))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='fit', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='regressors', value=Attribute(value=Name(id='ts', ctx=Load()), attr='regressors', ctx=Load()))])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Constant(value='MultiSegmentModelMixin')), FunctionDef(name='_make_predictions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_method', annotation=Name(id='Callable', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Make predictions.\n\n        Parameters\n        ----------\n        ts:\n            Dataset with features\n        prediction_method:\n            Method for making predictions\n\n        Returns\n        -------\n        :\n            Dataset with predictions\n        ')), Assign(targets=[Name(id='horizon', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='to_pandas', ctx=Load()), args=[], keywords=[keyword(arg='flatten', value=Constant(value=True))]), attr='drop', ctx=Load()), args=[List(elts=[Constant(value='segment')], ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Name(id='y', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='prediction_method', ctx=Load()), args=[], keywords=[keyword(arg='self', value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load())), keyword(arg='df', value=Name(id='x', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]), attr='reshape', ctx=Load()), args=[UnaryOp(op=USub(), operand=Constant(value=1)), Name(id='horizon', ctx=Load())], keywords=[]), attr='T', ctx=Load())), Assign(targets=[Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Slice(), Subscript(value=Attribute(value=Name(id='pd', ctx=Load()), attr='IndexSlice', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value='target')], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Store())], value=Name(id='y', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='inverse_transform', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='ts', ctx=Load()))], decorator_list=[], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='_forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), Constant(value='forecast')], keywords=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='forecast', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='predict', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='_predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_predictions', ctx=Load()), args=[], keywords=[keyword(arg='ts', value=Name(id='ts', ctx=Load())), keyword(arg='prediction_method', value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='predict', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get internal model that is used inside etna class.\n\n        Internal model is a model that is used inside etna to forecast segments,\n        e.g. :py:class:`catboost.CatBoostRegressor` or :py:class:`sklearn.linear_model.Ridge`.\n\n        Returns\n        -------\n        :\n           Internal model\n        ')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='hasattr', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), Constant(value='get_model')], keywords=[])), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Constant(value='get_model method is not implemented for '), FormattedValue(value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_base_model', ctx=Load()), attr='get_model', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Any', ctx=Load()))], decorator_list=[])], type_ignores=[])