Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='abc', names=[alias(name='abstractmethod')], level=0), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='statsmodels.tools.sm_exceptions', names=[alias(name='ValueWarning')], level=0), ImportFrom(module='statsmodels.tsa.statespace.sarimax', names=[alias(name='SARIMAX')], level=0), ImportFrom(module='statsmodels.tsa.statespace.sarimax', names=[alias(name='SARIMAXResultsWrapper')], level=0), ImportFrom(module='etna.libs.pmdarima_utils', names=[alias(name='seasonal_prediction_with_confidence')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.utils', names=[alias(name='determine_num_steps')], level=0), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='filterwarnings', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Constant(value='No frequency information was provided, so inferred frequency .* will be used')), keyword(arg='action', value=Constant(value='ignore')), keyword(arg='category', value=Name(id='ValueWarning', ctx=Load())), keyword(arg='module', value=Constant(value='statsmodels.tsa.base.tsa_model'))])), ClassDef(name='_SARIMAXBaseAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Base class for adapters based on :py:class:`statsmodels.tsa.statespace.sarimax.SARIMAX`.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Fits a SARIMAX model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        regressors:\n            List of the columns with regressors\n\n        Returns\n        -------\n        :\n            Fitted model\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Name(id='regressors', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_encode_categoricals', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='exog_train', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_select_regressors', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_fit_results', ctx=Load()), args=[], keywords=[keyword(arg='endog', value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), keyword(arg='exog', value=Name(id='exog_train', ctx=Load()))])), Assign(targets=[Name(id='freq', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='infer_freq', ctx=Load()), args=[Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())], keywords=[keyword(arg='warn', value=Constant(value=False))])), If(test=Compare(left=Name(id='freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't determine frequency of a given dataframe")], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_SARIMAXBaseAdapter')), FunctionDef(name='_make_prediction', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='dynamic', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Make predictions taking into account ``dynamic`` parameter.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='horizon', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_encode_categoricals', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load()), Name(id='horizon', ctx=Load())], keywords=[])), Assign(targets=[Name(id='exog_future', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_select_regressors', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='end_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='start_idx', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Name(id='start_timestamp', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), Assign(targets=[Name(id='end_idx', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Name(id='end_timestamp', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), If(test=Name(id='prediction_interval', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='forecast', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Constant(value=0.05)), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Dict(keys=[Constant(value='mean')], values=[Name(id='forecast', ctx=Load())])], keywords=[])), For(target=Name(id='quantile', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Name(id='alpha', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='quantile', ctx=Load()), op=Mult(), right=Constant(value=2)), BinOp(left=BinOp(left=Constant(value=1), op=Sub(), right=Name(id='quantile', ctx=Load())), op=Mult(), right=Constant(value=2))], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='borders', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Name(id='alpha', ctx=Load())), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), If(test=Compare(left=Name(id='quantile', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Constant(value=1), op=Div(), right=Constant(value=2))]), body=[Assign(targets=[Name(id='series', ctx=Store())], value=Subscript(value=Name(id='borders', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=0)], ctx=Load()), ctx=Load()))], orelse=[Assign(targets=[Name(id='series', ctx=Store())], value=Subscript(value=Name(id='borders', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=1)], ctx=Load()), ctx=Load()))]), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='mean_'), FormattedValue(value=Name(id='quantile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Name(id='series', ctx=Load()))], orelse=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='forecast', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Constant(value=0.05)), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Dict(keys=[Constant(value='mean')], values=[Name(id='forecast', ctx=Load())])], keywords=[]))]), Assign(targets=[Name(id='rename_dict', ctx=Store())], value=DictComp(key=Name(id='column', ctx=Load()), value=Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='mean'), Constant(value='target')], keywords=[]), generators=[comprehension(target=Name(id='column', ctx=Store()), iter=Attribute(value=Name(id='y_pred', ctx=Load()), attr='columns', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='mean')], keywords=[])], is_async=0)])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='y_pred', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='rename_dict', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute autoregressive predictions from a SARIMAX model.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        prediction_interval:\n             If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution\n\n        Returns\n        -------\n        :\n            DataFrame with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_prediction', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load())), keyword(arg='dynamic', value=Constant(value=True))]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='\n        Compute predictions from a SARIMAX model and use true in-sample data as lags if possible.\n\n        Parameters\n        ----------\n        df:\n            Features dataframe\n        prediction_interval:\n            If True returns prediction interval for forecast\n        quantiles:\n            Levels of prediction distribution\n\n        Returns\n        -------\n        :\n            DataFrame with predictions\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_prediction', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='prediction_interval', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load())), keyword(arg='dynamic', value=Constant(value=False))]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='_get_fit_results', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='endog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())), arg(arg='exog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='SARIMAXResultsWrapper', ctx=Load())), FunctionDef(name='_check_df', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='horizon', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Something went wrong, regressor_columns is None!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='column_to_drop', ctx=Store())], value=ListComp(elt=Name(id='col', ctx=Load()), generators=[comprehension(target=Name(id='col', ctx=Store()), iter=Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load()), ifs=[Compare(left=Name(id='col', ctx=Load()), ops=[NotIn()], comparators=[BinOp(left=List(elts=[Constant(value='target'), Constant(value='timestamp')], ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()))])], is_async=0)])), If(test=Name(id='column_to_drop', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='SARIMAX model does not work with exogenous features (features unknown in future).\n '), FormattedValue(value=Name(id='column_to_drop', ctx=Load()), conversion=-1), Constant(value=' will be dropped')]))]))], orelse=[]), If(test=Name(id='horizon', ctx=Load()), body=[Assign(targets=[Name(id='short_regressors', ctx=Store())], value=ListComp(elt=Name(id='regressor', ctx=Load()), generators=[comprehension(target=Name(id='regressor', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ifs=[Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Name(id='regressor', ctx=Load()), ctx=Load()), attr='count', ctx=Load()), args=[], keywords=[]), ops=[Lt()], comparators=[Name(id='horizon', ctx=Load())])], is_async=0)])), If(test=Name(id='short_regressors', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Regressors '), FormattedValue(value=Name(id='short_regressors', ctx=Load()), conversion=-1), Constant(value=' are too short for chosen horizon value.\n Try lower horizon value, or drop this regressors.')])], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='_select_regressors', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), body=[Assign(targets=[Name(id='exog_future', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Name(id='exog_future', ctx=Load()), attr='index', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()))], orelse=[Assign(targets=[Name(id='exog_future', ctx=Store())], value=Constant(value=None))]), Return(value=Name(id='exog_future', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), FunctionDef(name='_encode_categoricals', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='categorical_cols', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='select_dtypes', ctx=Load()), args=[], keywords=[keyword(arg='include', value=List(elts=[Constant(value='category')], ctx=Load()))]), attr='columns', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])), Try(body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='categorical_cols', ctx=Load())], ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Name(id='categorical_cols', ctx=Load()), ctx=Load()), attr='astype', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Categorical columns '), FormattedValue(value=Name(id='categorical_cols', ctx=Load()), conversion=-1), Constant(value=' can not been converted to int.\n Try to encode this columns manually.')])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get :py:class:`statsmodels.tsa.statespace.sarimax.SARIMAXResultsWrapper` that is used inside etna class.\n\n        Returns\n        -------\n        :\n           Internal model\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load()))], decorator_list=[], returns=Name(id='SARIMAXResultsWrapper', ctx=Load()))], decorator_list=[]), ClassDef(name='_SARIMAXAdapter', bases=[Name(id='_SARIMAXBaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Class for holding Sarimax model.\n\n    Notes\n    -----\n    We use SARIMAX [1] model from statsmodels package. Statsmodels package uses `exog` attribute for\n    `exogenous regressors` which should be known in future, however we use exogenous for\n    additional features what is not known in future, and regressors for features we do know in\n    future.\n\n    .. `SARIMAX: <https://www.statsmodels.org/stable/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html>_`\n\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='seasonal_order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='measurement_error', annotation=Name(id='bool', ctx=Load())), arg(arg='time_varying_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='mle_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='simple_differencing', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_stationarity', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_invertibility', annotation=Name(id='bool', ctx=Load())), arg(arg='hamilton_representation', annotation=Name(id='bool', ctx=Load())), arg(arg='concentrate_scale', annotation=Name(id='bool', ctx=Load())), arg(arg='trend_offset', annotation=Name(id='float', ctx=Load())), arg(arg='use_exact_diffuse', annotation=Name(id='bool', ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missing', annotation=Name(id='str', ctx=Load())), arg(arg='validate_specification', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=2), Constant(value=1), Constant(value=0)], ctx=Load()), Tuple(elts=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=12)], ctx=Load()), Constant(value='c'), Constant(value=False), Constant(value=False), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=False), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=True)]), body=[Expr(value=Constant(value="\n        Init SARIMAX model with given params.\n\n        Parameters\n        ----------\n        order:\n            The (p,d,q) order of the model for the number of AR parameters,\n            differences, and MA parameters. `d` must be an integer\n            indicating the integration order of the process, while\n            `p` and `q` may either be an integers indicating the AR and MA\n            orders (so that all lags up to those orders are included) or else\n            iterables giving specific AR and / or MA lags to include. Default is\n            an AR(1) model: (1,0,0).\n        seasonal_order:\n            The (P,D,Q,s) order of the seasonal component of the model for the\n            AR parameters, differences, MA parameters, and periodicity.\n            `D` must be an integer indicating the integration order of the process,\n            while `P` and `Q` may either be an integers indicating the AR and MA\n            orders (so that all lags up to those orders are included) or else\n            iterables giving specific AR and / or MA lags to include. `s` is an\n            integer giving the periodicity (number of periods in season), often it\n            is 4 for quarterly data or 12 for monthly data. Default is no seasonal\n            effect.\n        trend:\n            Parameter controlling the deterministic trend polynomial :math:`A(t)`.\n            Can be specified as a string where 'c' indicates a constant (i.e. a\n            degree zero component of the trend polynomial), 't' indicates a\n            linear trend with time, and 'ct' is both. Can also be specified as an\n            iterable defining the non-zero polynomial exponents to include, in\n            increasing order. For example, `[1,1,0,1]` denotes\n            :math:`a + bt + ct^3`. Default is to not include a trend component.\n        measurement_error:\n            Whether or not to assume the endogenous observations `endog` were\n            measured with error. Default is False.\n        time_varying_regression:\n            Used when an explanatory variables, `exog`, are provided provided\n            to select whether or not coefficients on the exogenous regressors are\n            allowed to vary over time. Default is False.\n        mle_regression:\n            Whether or not to use estimate the regression coefficients for the\n            exogenous variables as part of maximum likelihood estimation or through\n            the Kalman filter (i.e. recursive least squares). If\n            `time_varying_regression` is True, this must be set to False. Default\n            is True.\n        simple_differencing:\n            Whether or not to use partially conditional maximum likelihood\n            estimation. If True, differencing is performed prior to estimation,\n            which discards the first :math:`s D + d` initial rows but results in a\n            smaller state-space formulation. See the Notes section for important\n            details about interpreting results when this option is used. If False,\n            the full SARIMAX model is put in state-space form so that all\n            datapoints can be used in estimation. Default is False.\n        enforce_stationarity:\n            Whether or not to transform the AR parameters to enforce stationarity\n            in the autoregressive component of the model. Default is True.\n        enforce_invertibility:\n            Whether or not to transform the MA parameters to enforce invertibility\n            in the moving average component of the model. Default is True.\n        hamilton_representation:\n            Whether or not to use the Hamilton representation of an ARMA process\n            (if True) or the Harvey representation (if False). Default is False.\n        concentrate_scale:\n            Whether or not to concentrate the scale (variance of the error term)\n            out of the likelihood. This reduces the number of parameters estimated\n            by maximum likelihood by one, but standard errors will then not\n            be available for the scale parameter.\n        trend_offset:\n            The offset at which to start time trend values. Default is 1, so that\n            if `trend='t'` the trend is equal to 1, 2, ..., nobs. Typically is only\n            set when the model created by extending a previous dataset.\n        use_exact_diffuse:\n            Whether or not to use exact diffuse initialization for non-stationary\n            states. Default is False (in which case approximate diffuse\n            initialization is used).\n        dates:\n            If no index is given by `endog` or `exog`, an array-like object of\n            datetime objects can be provided.\n        freq:\n            If no index is given by `endog` or `exog`, the frequency of the\n            time-series may be specified here as a Pandas offset or offset string.\n        missing:\n            Available options are 'none', 'drop', and 'raise'. If 'none', no nan\n            checking is done. If 'drop', any observations with nans are dropped.\n            If 'raise', an error is raised. Default is 'none'.\n        validate_specification:\n            If True, validation of hyperparameters is performed.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Store())], value=Name(id='order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Store())], value=Name(id='seasonal_order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Store())], value=Name(id='measurement_error', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Store())], value=Name(id='time_varying_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Store())], value=Name(id='mle_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Store())], value=Name(id='simple_differencing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Store())], value=Name(id='enforce_stationarity', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Store())], value=Name(id='enforce_invertibility', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Store())], value=Name(id='hamilton_representation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Store())], value=Name(id='concentrate_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Store())], value=Name(id='trend_offset', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Store())], value=Name(id='use_exact_diffuse', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Store())], value=Name(id='validate_specification', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='_get_fit_results', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='endog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())), arg(arg='exog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='endog_np', ctx=Store())], value=Attribute(value=Name(id='endog', ctx=Load()), attr='values', ctx=Load())), Assign(targets=[Name(id='model', ctx=Store())], value=Call(func=Name(id='SARIMAX', ctx=Load()), args=[], keywords=[keyword(arg='endog', value=Name(id='endog_np', ctx=Load())), keyword(arg='exog', value=Name(id='exog', ctx=Load())), keyword(arg='order', value=Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Load())), keyword(arg='seasonal_order', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Load())), keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='measurement_error', value=Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Load())), keyword(arg='time_varying_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Load())), keyword(arg='mle_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Load())), keyword(arg='simple_differencing', value=Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Load())), keyword(arg='enforce_stationarity', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Load())), keyword(arg='enforce_invertibility', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Load())), keyword(arg='hamilton_representation', value=Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Load())), keyword(arg='concentrate_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Load())), keyword(arg='trend_offset', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Load())), keyword(arg='use_exact_diffuse', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load())), keyword(arg='validate_specification', value=Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load()))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='model', ctx=Load()), attr='fit', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='SARIMAXModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='\n    Class for holding Sarimax model.\n\n    Method ``predict`` can use true target values only on train data on future data autoregression\n    forecasting will be made even if targets are known.\n\n    Notes\n    -----\n    We use :py:class:`statsmodels.tsa.sarimax.SARIMAX`. Statsmodels package uses `exog` attribute for\n    `exogenous regressors` which should be known in future, however we use exogenous for\n    additional features what is not known in future, and regressors for features we do know in\n    future.\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='seasonal_order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='measurement_error', annotation=Name(id='bool', ctx=Load())), arg(arg='time_varying_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='mle_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='simple_differencing', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_stationarity', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_invertibility', annotation=Name(id='bool', ctx=Load())), arg(arg='hamilton_representation', annotation=Name(id='bool', ctx=Load())), arg(arg='concentrate_scale', annotation=Name(id='bool', ctx=Load())), arg(arg='trend_offset', annotation=Name(id='float', ctx=Load())), arg(arg='use_exact_diffuse', annotation=Name(id='bool', ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missing', annotation=Name(id='str', ctx=Load())), arg(arg='validate_specification', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=2), Constant(value=1), Constant(value=0)], ctx=Load()), Tuple(elts=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=12)], ctx=Load()), Constant(value='c'), Constant(value=False), Constant(value=False), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=False), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=True)]), body=[Expr(value=Constant(value="\n        Init SARIMAX model with given params.\n\n        Parameters\n        ----------\n        order:\n            The (p,d,q) order of the model for the number of AR parameters,\n            differences, and MA parameters. `d` must be an integer\n            indicating the integration order of the process, while\n            `p` and `q` may either be an integers indicating the AR and MA\n            orders (so that all lags up to those orders are included) or else\n            iterables giving specific AR and / or MA lags to include. Default is\n            an AR(1) model: (1,0,0).\n        seasonal_order:\n            The (P,D,Q,s) order of the seasonal component of the model for the\n            AR parameters, differences, MA parameters, and periodicity.\n            `D` must be an integer indicating the integration order of the process,\n            while `P` and `Q` may either be an integers indicating the AR and MA\n            orders (so that all lags up to those orders are included) or else\n            iterables giving specific AR and / or MA lags to include. `s` is an\n            integer giving the periodicity (number of periods in season), often it\n            is 4 for quarterly data or 12 for monthly data. Default is no seasonal\n            effect.\n        trend:\n            Parameter controlling the deterministic trend polynomial :math:`A(t)`.\n            Can be specified as a string where 'c' indicates a constant (i.e. a\n            degree zero component of the trend polynomial), 't' indicates a\n            linear trend with time, and 'ct' is both. Can also be specified as an\n            iterable defining the non-zero polynomial exponents to include, in\n            increasing order. For example, `[1,1,0,1]` denotes\n            :math:`a + bt + ct^3`. Default is to not include a trend component.\n        measurement_error:\n            Whether or not to assume the endogenous observations `endog` were\n            measured with error. Default is False.\n        time_varying_regression:\n            Used when an explanatory variables, `exog`, are provided provided\n            to select whether or not coefficients on the exogenous regressors are\n            allowed to vary over time. Default is False.\n        mle_regression:\n            Whether or not to use estimate the regression coefficients for the\n            exogenous variables as part of maximum likelihood estimation or through\n            the Kalman filter (i.e. recursive least squares). If\n            `time_varying_regression` is True, this must be set to False. Default\n            is True.\n        simple_differencing:\n            Whether or not to use partially conditional maximum likelihood\n            estimation. If True, differencing is performed prior to estimation,\n            which discards the first :math:`s D + d` initial rows but results in a\n            smaller state-space formulation. See the Notes section for important\n            details about interpreting results when this option is used. If False,\n            the full SARIMAX model is put in state-space form so that all\n            datapoints can be used in estimation. Default is False.\n        enforce_stationarity:\n            Whether or not to transform the AR parameters to enforce stationarity\n            in the autoregressive component of the model. Default is True.\n        enforce_invertibility:\n            Whether or not to transform the MA parameters to enforce invertibility\n            in the moving average component of the model. Default is True.\n        hamilton_representation:\n            Whether or not to use the Hamilton representation of an ARMA process\n            (if True) or the Harvey representation (if False). Default is False.\n        concentrate_scale:\n            Whether or not to concentrate the scale (variance of the error term)\n            out of the likelihood. This reduces the number of parameters estimated\n            by maximum likelihood by one, but standard errors will then not\n            be available for the scale parameter.\n        trend_offset:\n            The offset at which to start time trend values. Default is 1, so that\n            if `trend='t'` the trend is equal to 1, 2, ..., nobs. Typically is only\n            set when the model created by extending a previous dataset.\n        use_exact_diffuse:\n            Whether or not to use exact diffuse initialization for non-stationary\n            states. Default is False (in which case approximate diffuse\n            initialization is used).\n        dates:\n            If no index is given by `endog` or `exog`, an array-like object of\n            datetime objects can be provided.\n        freq:\n            If no index is given by `endog` or `exog`, the frequency of the\n            time-series may be specified here as a Pandas offset or offset string.\n        missing:\n            Available options are 'none', 'drop', and 'raise'. If 'none', no nan\n            checking is done. If 'drop', any observations with nans are dropped.\n            If 'raise', an error is raised. Default is 'none'.\n        validate_specification:\n            If True, validation of hyperparameters is performed.\n        ")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Store())], value=Name(id='order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Store())], value=Name(id='seasonal_order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Store())], value=Name(id='measurement_error', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Store())], value=Name(id='time_varying_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Store())], value=Name(id='mle_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Store())], value=Name(id='simple_differencing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Store())], value=Name(id='enforce_stationarity', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Store())], value=Name(id='enforce_invertibility', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Store())], value=Name(id='hamilton_representation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Store())], value=Name(id='concentrate_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Store())], value=Name(id='trend_offset', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Store())], value=Name(id='use_exact_diffuse', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Store())], value=Name(id='validate_specification', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='SARIMAXModel', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_SARIMAXAdapter', ctx=Load()), args=[], keywords=[keyword(arg='order', value=Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Load())), keyword(arg='seasonal_order', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Load())), keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='measurement_error', value=Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Load())), keyword(arg='time_varying_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Load())), keyword(arg='mle_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Load())), keyword(arg='simple_differencing', value=Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Load())), keyword(arg='enforce_stationarity', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Load())), keyword(arg='enforce_invertibility', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Load())), keyword(arg='hamilton_representation', value=Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Load())), keyword(arg='concentrate_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Load())), keyword(arg='trend_offset', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Load())), keyword(arg='use_exact_diffuse', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load())), keyword(arg='validate_specification', value=Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])