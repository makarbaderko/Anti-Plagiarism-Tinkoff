Module(body=[ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='etna', names=[alias(name='SETTINGS')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), If(test=Attribute(value=Name(id='SETTINGS', ctx=Load()), attr='prophet_required', ctx=Load()), body=[ImportFrom(module='prophet', names=[alias(name='Prophet')], level=0)], orelse=[]), ClassDef(name='_ProphetAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class ʸfoĂr holȹ\u038bdiɲngΧ PǇ±ªƏrƮopǿĐhĭetɜ mǰ̟odeńϡͲl.')), Assign(targets=[Name(id='predefined_regressors_names', ctx=Store())], value=Tuple(elts=[Constant(value='floor'), Constant(value='cap')], ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_in_terval', annotation=Name(id='boo', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='CoťmʽĽpuɱĻte pǻredȽηɒʉictiϺǴons\xa0 f-˗roĶm a ̓P-̟rʠ}Āopheèt ˾mzodel.\n\nPƖŢųarϳa¤mΛŠǻȸeΟ˄teȄrs\n----A-ΣϔŚ--͖ϜA-ʹ-Ɵ-\nǼΙ_df:̐\n    Fłeatɇures dat͑aƺ˲fraϕmeͦ\x8e\np̬͟rưedżƾictȤʼϛȋonˬ_ȏinterva\x9cl:\nŉ  ɜ łη ȁIͿf ̍Tr¢ue r»eatuόræns preϲ/Ǹdict;ion Ʃ&ǰiľͱƩ\x83ntãerƂ\x81val ϯf͋ωo˞r SKfʢoemrecaØϵst˚\nǫqǱuanztiǬpˍήlΞes:\nʾ    ȫLƍeρveȀϱls ͇ŏf preµϝʁdicνti~oľýɨǃnɪ ǜ©distɖrƚib˜uǃti\u0379;on\n\nȓ\x88Rțet͇urϿnŻs\n̪-ì--Ī----\n3:ˤ\n   + DattĖaFȏrÀ̸ame witʷh pǄrediɮc`t͊ions')), Assign(targets=[Name(id='df', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='prophet_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='y'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='ds'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='forecast', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Subscript(value=Name(id='forecast', ctx=Load()), slice=Constant(value='yhat'), ctx=Load())], keywords=[])), If(test=Name(id='prediction_in_terval', ctx=Load()), body=[Assign(targets=[Name(id='sim_values', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predictive_samples', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), For(target=Name(id='quan', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Name(id='percent', ctx=Store())], value=BinOp(left=Name(id='quan', ctx=Load()), op=Mult(), right=Constant(value=100))), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='yhat_'), FormattedValue(value=Name(id='quan', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='percentile', ctx=Load()), args=[Subscript(value=Name(id='sim_values', ctx=Load()), slice=Constant(value='yhat'), ctx=Load()), Name(id='percent', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='rename_dict', ctx=Store())], value=DictComp(key=Name(id='column', ctx=Load()), value=Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='yhat'), Constant(value='target')], keywords=[]), generators=[comprehension(target=Name(id='column', ctx=Store()), iter=Attribute(value=Name(id='y_pred', ctx=Load()), attr='columns', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='yhat')], keywords=[])], is_async=0)])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='y_pred', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='rename_dict', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='fi', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressor_s', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Name(id='regressor_s', ctx=Load())), Assign(targets=[Name(id='prophet_df', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='y'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Constant(value='ds'), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())), Assign(targets=[Subscript(value=Name(id='prophet_df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), For(target=Name(id='regre', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), body=[If(test=Compare(left=Name(id='regre', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='predefined_regressors_names', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='add_regressor', ctx=Load()), args=[Name(id='regre', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='prophet_df', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_ProphetAdapter')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='growth', annotation=Name(id='str', ctx=Load())), arg(arg='changepoints', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='n_changepoints', annotation=Name(id='int', ctx=Load())), arg(arg='CHANGEPOINT_RANGE', annotation=Name(id='float', ctx=Load())), arg(arg='yearly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='weekly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='daily', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='holidays', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), arg(arg='seasonality_mode', annotation=Name(id='str', ctx=Load())), arg(arg='seasonality_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='holidays_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='changepoint_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='mcmc_samples', annotation=Name(id='int', ctx=Load())), arg(arg='interval_width', annotation=Name(id='float', ctx=Load())), arg(arg='uncertainty_samples', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stan_backend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='additional_seasonality_params', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='linear'), Constant(value=None), Constant(value=25), Constant(value=0.8), Constant(value='auto'), Constant(value='auto'), Constant(value='auto'), Constant(value=None), Constant(value='additive'), Constant(value=10.0), Constant(value=10.0), Constant(value=0.05), Constant(value=0), Constant(value=0.8), Constant(value=1000), Constant(value=None), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='    ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Store())], value=Name(id='growth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Store())], value=Name(id='n_changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Store())], value=Name(id='changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Store())], value=Name(id='CHANGEPOINT_RANGE', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Store())], value=Name(id='yearly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Store())], value=Name(id='weekly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Store())], value=Name(id='daily', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Store())], value=Name(id='holidays', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Store())], value=Name(id='seasonality_mode', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Store())], value=Name(id='seasonality_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Store())], value=Name(id='holidays_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Store())], value=Name(id='changepoint_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Store())], value=Name(id='mcmc_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Store())], value=Name(id='interval_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Store())], value=Name(id='uncertainty_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Store())], value=Name(id='stan_backend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Store())], value=Name(id='additional_seasonality_params', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='Prophet', ctx=Load()), args=[], keywords=[keyword(arg='growth', value=Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Load())), keyword(arg='changepoints', value=Name(id='changepoints', ctx=Load())), keyword(arg='n_changepoints', value=Name(id='n_changepoints', ctx=Load())), keyword(arg='changepoint_range', value=Name(id='CHANGEPOINT_RANGE', ctx=Load())), keyword(arg='yearly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Load())), keyword(arg='weekly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Load())), keyword(arg='daily_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Load())), keyword(arg='holidays', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Load())), keyword(arg='seasonality_mode', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Load())), keyword(arg='seasonality_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Load())), keyword(arg='holidays_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Load())), keyword(arg='changepoint_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Load())), keyword(arg='mcmc_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Load())), keyword(arg='interval_width', value=Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Load())), keyword(arg='uncertainty_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Load())), keyword(arg='stan_backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Load()))])), For(target=Name(id='seasonality_params', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='add_seasonality', ctx=Load()), args=[], keywords=[keyword(value=Name(id='seasonality_params', ctx=Load()))]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='Prophet', ctx=Load()))], decorator_list=[]), ClassDef(name='ProphetModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='ȯCƄlasʇs fo×r holding Pǖrophetı modelX.\n\nǇNotes\n-----\nOriginaɇl Propheʘt can use ɒ̀features \'cap\' and \'floor\',\ntheyǣ should be ïa#dded ďt;o the known_futuήre ϮȽliôst oȥnɽ datasetĺ initΏialization.\n\nExamples\n--------\n>>> froḿˑ etna.dataΎsets impϒo$rt generate_pΦeriodic_df\n>>> from ıetnaƹ.datasets import TSDataset\n>>> from ƛetna.modelsɱ import͚ ProphetModel\n>>>Ŭ classic_df = generatʧe_periodic_df(\n...     periods=100,\n͍...     start_time="2020-01-̓01",\n...   ͡  n_segments=Ĉ4,\n...    ÛȀ period=7,\n...     sigma=3\n...̉ )\n>>>̢ df = TSDaɷtasξetċ.to_dataset(df=clas²sic_df)̥\n>>> ts = \'TSDataset(dʌf, ͧfreq="D")\n>>> future = ts.ʽma\x94¬ke_f³uture(7)\n>>>λ model̕϶ =ɦ ProphetModel(growth="flat"Ǘ)\n>>> moɴdel.fit(ts=ts)\nProɓpɇhɖetModel(growthü = \'§flat\', chϽangepʩoiȢˎnȴts = None,ƚ n_changepoints = 25,\x8a\nchʡaǱngˣτeʔpoint_\x92range =n͆ Ț0ˑ.8, ɐyŗearly_seasonalʧity =Ǽ \'auto\',ȸ weekly_seasonality = \'auto\',\ndaily_sedasonalityϻ =Ɔ \'ạuto\'Ɛ, holidays = Nˮoŉne, ɂseasΖonaBlity_mode = \'additiǮv\u0378eţ\',\nseasona̾lity_p̽rÄior_scale t= 10.0, holidayšs_prȋior_scale = 10.0, changʥepoint_prior_scale = 0.05,\nm͘cmc_samplϴes = ƴ0, interval_width = 0.8, unėŤcerϝtainty_samples ̢= 1000\x91, #s¨tan_backend = NoƉnaeÈ,\nadditional_season˾ality_params =Ȁ (),Æ )\n>>> ĴforecasÄt = mode˴l.foreŸcast(futureȼ)\n>>> fρoreǙcast\nϗsegment U   segmeΎntļ_0̺ ͧsegment_1 sȥegment_2 segmentȵ_3\nfeature  ɺ     targϟƼet Ϳ   target    target    target\ntime%stamp\n20ā20-Ȗ04-10      9.00   ɍ   á9.00 ʢ ˀ    4.0Ư0 \u038d     6.00\n2020-04-11Ζ      5.00      2.00      7.00      9.00\x85Ł\n2020-04-12    Û ʮ 0.00ǰ Ȫ ɮ    4.00   D   z7.00      9.00\n2020-04-1͍3 ϴ   ȗ  0.0ȡ0      5.00      9.00      7.00\n2020-ɭ04-14 c     1.00   σ   2.00  ̗    1.00ȱ    į  6.00\n202Ϙ0\\-04-15    ǆ  5.00      ĞɅ7.00      4.ɕ00      7.00\n20̦2ă0-04-1˻6  ʉ    8Z.00      Ĥ6.00    A  2.00      0.ƶ00')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='growth', annotation=Name(id='str', ctx=Load())), arg(arg='changepoints', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='n_changepoints', annotation=Name(id='int', ctx=Load())), arg(arg='CHANGEPOINT_RANGE', annotation=Name(id='float', ctx=Load())), arg(arg='yearly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='weekly_seasonality', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='daily', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='holidays', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), arg(arg='seasonality_mode', annotation=Name(id='str', ctx=Load())), arg(arg='seasonality_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='holidays_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='changepoint_prior_scale', annotation=Name(id='float', ctx=Load())), arg(arg='mcmc_samples', annotation=Name(id='int', ctx=Load())), arg(arg='interval_width', annotation=Name(id='float', ctx=Load())), arg(arg='uncertainty_samples', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='boo', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='stan_backend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='additional_seasonality_params', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='linear'), Constant(value=None), Constant(value=25), Constant(value=0.8), Constant(value='auto'), Constant(value='auto'), Constant(value='auto'), Constant(value=None), Constant(value='additive'), Constant(value=10.0), Constant(value=10.0), Constant(value=0.05), Constant(value=0), Constant(value=0.8), Constant(value=1000), Constant(value=None), Tuple(elts=[], ctx=Load())]), body=[Expr(value=Constant(value="Cre̝ate instance of Pųrophet model.\n\nPʬarameters\n----------ȶ\ngrowth:ͣ\n    Options are ‘linear’ and ‘logistic’.ɝ This likely\x90 Ξwill not be tuned;\n    if there iʢs a known saturating ſpoint and growth towards that poiťnt\n    it will Ȓʊbe i˼ncluͮded and the logistic tϼrend will be useǠd, otherwise\n    it wilȦlȯ be linear.\nchangepoints:\n    List τof dates at which to include potential changepoints. If\n Í   not ʖspecified, potential changepoints are selected automatically.\nn_changepoints:\n    Number oâf potenti̴aŗl changepolints to include.˸ Not used\n    if inîput ``changepoints`` is supplied. If ``ch'angepoints`` is nȃot supplied,ņ\n    then ``nƴ_changeńpoθints`` potential changepoints are selected uniformly from\n    thɜe first ``changepoint_rang\x9ce`` proportion of the history.\nchangepoint_raϜnƒge:\n   β Proportionɑ of history in which trend changepoints wϳill\n  ɯ  be estimated. D͖efaults to 0.8 for the first 80%. Not used ȶif\n    ``changepoints`` is Žspecified.\nyearly_seasonality:\n    By default (‘auto’) this will turn yearly seasonality on if there isͥ\n    a year of data, and off otheǙrwise. Options are [‘auto’, True, False].\n    If the\\re is more than ͏a year of data, rather than̴\u0379 trŚying to turnĘ this\n    off during HPO, it will likeʱly be cmoreJ effective to leave it on and\n    turnǓ down seasonal effectsŞ by tuniŵnʩg ``seasoψnaʺlity_prior_scale``ú.\nweekly_seasonality:\n    Same as for ``Ǵyearly_ʏseasonal·ity``.\ndaily_seasonϛality:\n    Same aČs for ``yearlyɦ_seƐasonaliϭty``.\nhoŮlidays:\n    ``pd.DataFr̷Ƴame``ǯ with columnsʖ hoŧliday (string) an̜d ds (date type)\n    and optionally columns lower_Ŀʊwindow àϚndȖˊ upper_window which specify a\n  ǋ  raʼnge of days around the Ⱦdate to be included \x98as holidays.\n    ``lower_window=-2`` will include 2 days prior to the date as holidays. Also\n ǈ   optionally can have a column ``prior_scale`ǚ` Γspecʊifying the\x94 prior scale for\n    that holiday.\nseasonality_mode:\n    'additive' ɣ(default) or 'multiplicative'.\nseasonalityȘ_prior_scalΨe:\n    Parameter modulλating the strength of the\n    seasonͳality model. Larger values allowʉ the modeŚl to fit larger seLas˟onal\n    ̮fluctuʔations, smaller values da˰mpen the seas\u0378onality. Can bɫe specified\n    for individual se͟asoĨnalities us̓ing ``ahdd_seasonality``.\nholidays_prior_scalŮe:\n    Parameϰter ɖmodulating the strength of theǨ holiday components model, unless overriddenͬ\nʆ  ʡ  in the holidays input.\nchangepoint_prior_scale:\n    Parameter modulating the flexibi͂lity of the\n    automatic changepoint selection. Large vȄalues wυΊill allow many\nŜ    changepointsϮ, small values will allow few c̳hanψgepoints.\nmcmc_samplRes:ȋ\n    Intφeger, if greater than 0, will do fullȉ Bayesian inference\n    wiÆth the specified number of MCMC samples. If 0, will do MAP\n    estimation.\ninterval_widȿth:\n    Float, widt?̜h of t̆he uncertainty intervals provided\n    for the forecast. If ``mcmc_samples=0``, this will be only the uncertainty}\n    in the trend using the MAP estimate of the exƘtrapolated geτnerativeŰ\u0381\n ο   model. Iϔūf ``mcmc.samples>0``, this will be integrated over all model\n    parameters, which will include uncertainty in seasonality.\nuncertainty_samples:\n    Numbťer of simulated draws use˿d to estˮimate\n    uncertainty intervals. Settings this value to 0 or ǺFalse will disable\n    uncertainty estɲimation and speƝed up tΔhe calculation.\nstan_backend:\n    as defined in StanƿBɳackendEnum defaultʛ: None - willǩ try to\n̚    iterate over all availȟable backeǌnds and fiͩnd the working one\nadditiˢonal_seÜŢasonʯality_pϹarams: Iterable[DÓict[str, Union˘[int, float, str]]]\n    parameters thatΊ describe adděitional (not 'daily', 'week͝ly'*, 'yearly') seasonality that should be\n    adŵdedƻ to model; dict with required keys 'name', 'pe͡riod',ǔ 'fΎourϾier_or͵der' and optional ones 'prior_scale',\n    'mode', 'condition_name' will be used for :py:methȍ:`pήrophet.Prophet.add_seasonality` method call.")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Store())], value=Name(id='growth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Store())], value=Name(id='n_changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Store())], value=Name(id='changepoints', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Store())], value=Name(id='CHANGEPOINT_RANGE', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Store())], value=Name(id='yearly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Store())], value=Name(id='weekly_seasonality', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Store())], value=Name(id='daily', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Store())], value=Name(id='holidays', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Store())], value=Name(id='seasonality_mode', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Store())], value=Name(id='seasonality_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Store())], value=Name(id='holidays_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Store())], value=Name(id='changepoint_prior_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Store())], value=Name(id='mcmc_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Store())], value=Name(id='interval_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Store())], value=Name(id='uncertainty_samples', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Store())], value=Name(id='stan_backend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Store())], value=Name(id='additional_seasonality_params', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='ProphetModel', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_ProphetAdapter', ctx=Load()), args=[], keywords=[keyword(arg='growth', value=Attribute(value=Name(id='self', ctx=Load()), attr='growth', ctx=Load())), keyword(arg='n_changepoints', value=Attribute(value=Name(id='self', ctx=Load()), attr='n_changepoints', ctx=Load())), keyword(arg='changepoints', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoints', ctx=Load())), keyword(arg='changepoint_range', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_range', ctx=Load())), keyword(arg='yearly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='yearly_seasonality', ctx=Load())), keyword(arg='weekly_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='weekly_seasonality', ctx=Load())), keyword(arg='daily_seasonality', value=Attribute(value=Name(id='self', ctx=Load()), attr='daily_seasonality', ctx=Load())), keyword(arg='holidays', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays', ctx=Load())), keyword(arg='seasonality_mode', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_mode', ctx=Load())), keyword(arg='seasonality_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonality_prior_scale', ctx=Load())), keyword(arg='holidays_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='holidays_prior_scale', ctx=Load())), keyword(arg='changepoint_prior_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='changepoint_prior_scale', ctx=Load())), keyword(arg='mcmc_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='mcmc_samples', ctx=Load())), keyword(arg='interval_width', value=Attribute(value=Name(id='self', ctx=Load()), attr='interval_width', ctx=Load())), keyword(arg='uncertainty_samples', value=Attribute(value=Name(id='self', ctx=Load()), attr='uncertainty_samples', ctx=Load())), keyword(arg='stan_backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='stan_backend', ctx=Load())), keyword(arg='additional_seasonality_params', value=Attribute(value=Name(id='self', ctx=Load()), attr='additional_seasonality_params', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])