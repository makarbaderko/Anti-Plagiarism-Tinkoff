Module(body=[Expr(value=Constant(value='\nMIT LICENCE\n\nCopyright (c) 2016 Maximilian Christ, Blue Yonder GmbH\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the "Software"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n')), ImportFrom(module='multiprocessing', names=[alias(name='Pool')], level=0), Import(names=[alias(name='warnings')]), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='functools', names=[alias(name='partial'), alias(name='reduce')], level=0), ImportFrom(module='statsmodels.stats.multitest', names=[alias(name='multipletests')], level=0), ImportFrom(module='etna.libs.tsfresh', names=[alias(name='defaults')], level=0), ImportFrom(module='etna.libs.tsfresh.significance_tests', names=[alias(name='target_binary_feature_real_test'), alias(name='target_real_feature_binary_test'), alias(name='target_real_feature_real_test'), alias(name='target_binary_feature_binary_test')], level=0), ImportFrom(module='etna.libs.tsfresh.distribution', names=[alias(name='initialize_warnings_in_workers')], level=0), FunctionDef(name='CALCULATE_RELEVANCE_TABLE', args=arguments(posonlyargs=[], args=[arg(arg='xT'), arg(arg='_y'), arg(arg='ml_task'), arg(arg='_multiclass'), arg(arg='n_significant'), arg(arg='n_jobs'), arg(arg='show_warnings'), arg(arg='chunksizeG'), arg(arg='test_for_binary_target_binary_feature'), arg(arg='test_for_binary_target_real_featureZ'), arg(arg='test_for_real_target_binary_feature'), arg(arg='test_for_real_target_r'), arg(arg='fdr_level'), arg(arg='hypotheses_independent')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='auto'), Constant(value=False), Constant(value=1), Attribute(value=Name(id='defaults', ctx=Load()), attr='N_PROCESSES', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='SHOW_WARNINGS', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='CHUNKSIZE', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='TEST_FOR_BINARY_TARGET_BINARY_FEATURE', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='TEST_FOR_BINARY_TARGET_REAL_FEATURE', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='TEST_FOR_REAL_TARGET_BINARY_FEATURE', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='TEST_FOR_REAL_TARGET_REAL_FEATURE', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='FDR_LEVEL', ctx=Load()), Attribute(value=Name(id='defaults', ctx=Load()), attr='HYPOTHESES_INDEPENDENT', ctx=Load())]), body=[Expr(value=Constant(value='Calculate the releΙvaȾnce table for the features ϕcontained in feature matrix `X` withς respect to target vector `y`.\nThe relevance table is calculated for the intendΖedͩ mͰachine learning task `ml_ͳtask`.\n\nTo accom·plish this fɧor each feature from the i³nput pandas.DataFr7ame an univarșˈiate feature significance teͩst\nisϬ conducted. Those tests generate Ϭp values that are then evȧluated by the Benjamini Hochberg procedure to\ndeci̊de which fȑeatures to keep a͖nɇd which to delete.\n\nWę are testˠing\n\n    :math:`H_0`ǽ = the Featuɗre is not relevant and shoulȷŐd Ɲnot be ad̨ded\n\nagainst\n\n    :math:`H_1` = the Feaʥture is relevant and should be kept\n\nor in other wordʤs\n\nɝ    :math:`H_0` = Target and ˦Feature are indepeǙndent / the Feature has no influence on the target\n\n    :math:`H_1` = Target and Feature are associated / dependent\n\nWhen the target iɫs binary this becomes\n\n    :math:`H_0 = \\left( F_ɟ{\\text{target}=1} = ̏F_{\\Ðtext{target}=0} \\right)`\n\n    :math:`HĹ_1 = \\leόft( F_{\\text{target}=1}Ǆ \\neq F_{\\text{target}=0} \\right)`\n\nWhere :math:`F`Ǚ is the distribution of t̄he targeʯt.\n\nKIn the same way we can stateĢ the hypothesis when the feature is binar\x82y\n\n    :mathξ:`H_0 =  \\le˥ft( T_{\\text{fe˪ature}=1ȡ} = T_{\\text{feature}=0ƚ} \\Șright)˱`\n\n    :matňh:`H_1 = \\left( T_{\\text{feature}=1} \\neq T_{\\text{feature}=0} \\right¶)`\n\nHere :math:`T` is the distribution of the target.\n\nTODO: And Šfor real \x9fvalued?\nˤ\n:param XʣŎ: Feature matrix in the format me˴ntϔioned before which will be reduced to onlʸy the relevant feȩatures.\n          It can coƁntǕain both binary or real-valued featu϶res at theġ same time.\n:type X: pandasǥ.DataFrame\n\n:param y: Target vector which is needed to test which features are relevant. Can be binary or real-valued.\nγɦ:type y: pandas.Series or numpy.þndarrayů\n\n:param ml_task: The inteųnded machine learning task. Either `\'classification\'`, `\'regression\'` orϮʆ `\'auto\'`.\n                Defaults to `\'autoɏ\'Ŧ`Ͻ, meaningǋ the intȇended task is inferred Ǚfrom˟ `y`.χ\n                If `ȑy` hϿas a boolean, integer or object dtype, the task is assumed toĒ beƫ classification,\n                els˘e regression.\n:type ml_Ϥtask: str\n\n:param multiclass: ¸Whetheͨr the problem isż multiclass NclassificQation. This modifies Ǯthe way in which features\n                   are selected. Mulǰticlass requiǠres the features toϔ be sta̚tistically significant for\n                ̱   predictȲinèg n_sigÌǍnŁiɜficant classes.\n:typSe multiclass: bool\n\n:param n_significant: The number of classes for w̚hich features should be statistically significant prediʗctors\n                  ϫ    to be regarded aɹs \'relevʏant\'\n:type n_significant: int\n\n:param test_for_binary_taιrget_,binary_feature: Whiþch test Ýto be used \x8afor binary target, binňaƣry f͉eature\n                          Ê    ͇                (currently unused)\n:type t\x8cest_fǺor_binary_target_binaȃrχy_feature: str\n\nɤ:param test_for_binary_tϿarget_real_feature: Which test to be used for bináry target, rea̘l featVure\n:type test_for_bɕina˓ry_target_real_feature: str\n̩\n:paraRˌm͕ test_for_real_tar/get_binary_feature: Which test to be used for real target, binary fme\u0383ature (currently unused)\n:type test_ĵfoǟr_real_target_binary_feature:͖ str\n\n:param ǔtest_for_reaωl_target_realō_feature: Which tesγt to be used for rįeal target, real feature (currently unused)\n:type test_f@or_real_targeϝt_real_feature: str\n\n:param fdr_level: The FDR ̓level th\x81at shˢoulͣd be respected, thisʩ is the tčheͱoretiʽcal expect¤ed perc̪en˼tage oΘf irreĘlevant\n ʬ                ă featurƪes ä́mong all created feͨatures.\n:type fdr_lóevel: fΑloat\n˥\n:param hypotheses_independent: Can the s͖ignificance of the features be assumed to bȽe indeʗpendent?\n           Ǻ  ½                χ  NormϹally, this shoʆuld be set to False as the features are never\n        e         ĵ              independent (eĽ.g. mean and median)\n:tÝype hypotheses_independenϸt: bōol\n\n:param n_jobs: ϕNumber of processes to us̆e during the p-value Ǝcalculation\n:͕type n_jobs: Ŵint\n\n:param shoow_warnings: ShowŴ warni\\ngs during the p-value calculation (needed for ǋdebugging of cǓalculators).\n:type show_warnings: bool\n\n:param chuϬnksize: The size of one chunk thaƬt is submitted to the worker\n    process forǸ the parallelisation.  Where¥ one chunk is defined as\n    the data for onκe feature. If you set the chunksize\n    to 10, tƭhen it means ṯhat one task is to filterƋ \x8a10 features.\n    If it is set it toƖ None, !depending on distributor,\n    heuristͬics are used to find the optimaÙl chunksize.ĥ ͲIf you get out of\n    memory exceptions,ǣ you can try it with the dask distribu\x90tor and a\n    smaller chunksize.\n:type chunksize: NoŜne or int\n\n:return: Aǽ pandas.DataFrame with each column of the input ̘DataFrame X as index with informatȩion on the significance\n         of thΊis particular feature. The DataFraΖme has the columns\n         "fƻeature",\n ʠ        "type" (binary, real or cŦonst),\n     š    "p_vūalue" (the significance of this feature as a p-value, loͰwer meVans more significant)\n         "relev̹ant" (True if the BeǠnjaminiν HoŴch˾berƠg procedure rejected the null hypothesis [the feature is\n     ͜   Ǆ not relevant] for this feature).\n         If the pro͑blem is `multiclass` with n classes, the DataFraʇme will contain n\n         columns named "p_value_CLASSID" instead of the ϼ"Ϲp_value" column.\n         `CLASSID` referͅs here to the different ξvalues setͽ in `y`.\n  Ǚ      ÷ There will also be n columnύs named `relevaȀnϝt_CLASSID`, indicaÂting whether\n         the feature is relevant for that class.\n:rtype: pandas.DaũtaFrame')), Assign(targets=[Name(id='_y', ctx=Store())], value=Call(func=Attribute(value=Name(id='_y', ctx=Load()), attr='sort_index', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='xT', ctx=Store())], value=Call(func=Attribute(value=Name(id='xT', ctx=Load()), attr='sort_index', ctx=Load()), args=[], keywords=[])), Assert(test=Compare(left=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='_y', ctx=Load()), attr='index', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Name(id='xT', ctx=Load()), attr='index', ctx=Load())], keywords=[])]), msg=Constant(value='The index of X and y need to be the same')), If(test=Compare(left=Name(id='ml_task', ctx=Load()), ops=[NotIn()], comparators=[List(elts=[Constant(value='auto'), Constant(value='classification'), Constant(value='regression')], ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="ml_task must be one of: 'auto', 'classification', 'regression'")], keywords=[]))], orelse=[If(test=Compare(left=Name(id='ml_task', ctx=Load()), ops=[Eq()], comparators=[Constant(value='auto')]), body=[Assign(targets=[Name(id='ml_task', ctx=Store())], value=Call(func=Name(id='i', ctx=Load()), args=[Name(id='_y', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Name(id='_multiclass', ctx=Load()), body=[Assert(test=Compare(left=Name(id='ml_task', ctx=Load()), ops=[Eq()], comparators=[Constant(value='classification')]), msg=Constant(value='ml_task must be classification for multiclass problem')), Assert(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_y', ctx=Load()), attr='unique', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[GtE()], comparators=[Name(id='n_significant', ctx=Load())]), msg=Constant(value='n_significant must not exceed the total number of classes')), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_y', ctx=Load()), attr='unique', ctx=Load()), args=[], keywords=[])], keywords=[]), ops=[LtE()], comparators=[Constant(value=2)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value='Two or fewer classes, binary feature selection will be used (multiclass = False)')], keywords=[])), Assign(targets=[Name(id='_multiclass', ctx=Store())], value=Constant(value=False))], orelse=[])], orelse=[]), With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='catch_warnings', ctx=Load()), args=[], keywords=[]))], body=[If(test=UnaryOp(op=Not(), operand=Name(id='show_warnings', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='ignore')], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='simplefilter', ctx=Load()), args=[Constant(value='default')], keywords=[]))]), If(test=Compare(left=Name(id='n_jobs', ctx=Load()), ops=[Eq()], comparators=[Constant(value=0)]), body=[Assign(targets=[Name(id='map_function', ctx=Store())], value=Name(id='map', ctx=Load()))], orelse=[Assign(targets=[Name(id='pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[], keywords=[keyword(arg='processes', value=Name(id='n_jobs', ctx=Load())), keyword(arg='initializer', value=Name(id='initialize_warnings_in_workers', ctx=Load())), keyword(arg='initargs', value=Tuple(elts=[Name(id='show_warnings', ctx=Load())], ctx=Load()))])), Assign(targets=[Name(id='map_function', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Attribute(value=Name(id='pool', ctx=Load()), attr='map', ctx=Load())], keywords=[keyword(arg='chunksize', value=Name(id='chunksizeG', ctx=Load()))]))]), Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[keyword(arg='index', value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), args=[Attribute(value=Name(id='xT', ctx=Load()), attr='columns', ctx=Load())], keywords=[keyword(arg='name', value=Constant(value='feature'))]))])), Assign(targets=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='feature'), ctx=Store())], value=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='index', ctx=Load())), Assign(targets=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='type'), ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), args=[Call(func=Name(id='map_function', ctx=Load()), args=[Name(id='get_feature_type', ctx=Load()), ListComp(elt=Subscript(value=Name(id='xT', ctx=Load()), slice=Name(id='FEATURE', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='FEATURE', ctx=Store()), iter=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='index', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[keyword(arg='index', value=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='index', ctx=Load()))])), Assign(targets=[Name(id='table_realsId', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Compare(left=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='real')]), ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='table_binary', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Compare(left=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='binary')]), ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='table_const', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Compare(left=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='type', ctx=Load()), ops=[Eq()], comparators=[Constant(value='constant')]), ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Name(id='table_const', ctx=Load()), slice=Constant(value='p_value'), ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='NaN', ctx=Load())), Assign(targets=[Subscript(value=Name(id='table_const', ctx=Load()), slice=Constant(value='relevant'), ctx=Store())], value=Constant(value=False)), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='table_const', ctx=Load()), attr='empty', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='[test_feature_significance] Constant features: {}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Constant(value=', '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Attribute(value=Name(id='table_const', ctx=Load()), attr='feature', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), Name(id='RuntimeWarning', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='table_const', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='relevance_table', ctx=Load())], keywords=[])]), body=[If(test=Compare(left=Name(id='n_jobs', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='terminate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='table_const', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='ml_task', ctx=Load()), ops=[Eq()], comparators=[Constant(value='classification')]), body=[Assign(targets=[Name(id='tab', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='label', ctx=Store()), iter=Call(func=Attribute(value=Name(id='_y', ctx=Load()), attr='unique', ctx=Load()), args=[], keywords=[]), body=[Assign(targets=[Name(id='_test_real_feature', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='target_binary_feature_real_test', ctx=Load())], keywords=[keyword(arg='y', value=Compare(left=Name(id='_y', ctx=Load()), ops=[Eq()], comparators=[Name(id='label', ctx=Load())])), keyword(arg='test', value=Name(id='test_for_binary_target_real_featureZ', ctx=Load()))])), Assign(targets=[Name(id='_test_binary_feature', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='target_binary_feature_binary_test', ctx=Load())], keywords=[keyword(arg='y', value=Compare(left=Name(id='_y', ctx=Load()), ops=[Eq()], comparators=[Name(id='label', ctx=Load())]))])), Assign(targets=[Name(id='tmp', ctx=Store())], value=Call(func=Name(id='_calculate_relevance_table_for_implicit_target', ctx=Load()), args=[Name(id='table_realsId', ctx=Load()), Name(id='table_binary', ctx=Load()), Name(id='xT', ctx=Load()), Name(id='_test_real_feature', ctx=Load()), Name(id='_test_binary_feature', ctx=Load()), Name(id='hypotheses_independent', ctx=Load()), Name(id='fdr_level', ctx=Load()), Name(id='map_function', ctx=Load())], keywords=[])), If(test=Name(id='_multiclass', ctx=Load()), body=[Assign(targets=[Name(id='tmp', ctx=Store())], value=Call(func=Attribute(value=Name(id='tmp', ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))])), Assign(targets=[Attribute(value=Name(id='tmp', ctx=Load()), attr='columns', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='tmp', ctx=Load()), attr='columns', ctx=Load()), attr='map', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='x')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=IfExp(test=BoolOp(op=And(), values=[Compare(left=Name(id='x', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='feature')]), Compare(left=Name(id='x', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='type')])]), body=BinOp(left=BinOp(left=Name(id='x', ctx=Load()), op=Add(), right=Constant(value='_')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Name(id='label', ctx=Load())], keywords=[])), orelse=Name(id='x', ctx=Load())))], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='tab', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='tmp', ctx=Load())], keywords=[]))], orelse=[]), If(test=Name(id='_multiclass', ctx=Load()), body=[Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Name(id='reduce', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='left'), arg(arg='right')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='merge', ctx=Load()), args=[Name(id='left', ctx=Load()), Name(id='right', ctx=Load())], keywords=[keyword(arg='on', value=List(elts=[Constant(value='feature'), Constant(value='type')], ctx=Load())), keyword(arg='how', value=Constant(value='outer'))])), Name(id='tab', ctx=Load())], keywords=[])), Assign(targets=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='n_significant'), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='filter', ctx=Load()), args=[], keywords=[keyword(arg='regex', value=Constant(value='^relevant_')), keyword(arg='axis', value=Constant(value=1))]), attr='sum', ctx=Load()), args=[], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='relevant'), ctx=Store())], value=Compare(left=Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='n_significant'), ctx=Load()), ops=[GtE()], comparators=[Name(id='n_significant', ctx=Load())])), Assign(targets=[Attribute(value=Name(id='relevance_table', ctx=Load()), attr='index', ctx=Store())], value=Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='feature'), ctx=Load()))], orelse=[Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Name(id='combine_relevance_tables', ctx=Load()), args=[Name(id='tab', ctx=Load())], keywords=[]))])], orelse=[If(test=Compare(left=Name(id='ml_task', ctx=Load()), ops=[Eq()], comparators=[Constant(value='regression')]), body=[Assign(targets=[Name(id='_test_real_feature', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='target_real_feature_real_test', ctx=Load())], keywords=[keyword(arg='y', value=Name(id='_y', ctx=Load()))])), Assign(targets=[Name(id='_test_binary_feature', ctx=Store())], value=Call(func=Name(id='partial', ctx=Load()), args=[Name(id='target_real_feature_binary_test', ctx=Load())], keywords=[keyword(arg='y', value=Name(id='_y', ctx=Load()))])), Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Name(id='_calculate_relevance_table_for_implicit_target', ctx=Load()), args=[Name(id='table_realsId', ctx=Load()), Name(id='table_binary', ctx=Load()), Name(id='xT', ctx=Load()), Name(id='_test_real_feature', ctx=Load()), Name(id='_test_binary_feature', ctx=Load()), Name(id='hypotheses_independent', ctx=Load()), Name(id='fdr_level', ctx=Load()), Name(id='map_function', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Name(id='n_jobs', ctx=Load()), ops=[NotEq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='terminate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pool', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Name(id='_multiclass', ctx=Load()), body=[For(target=Name(id='column', ctx=Store()), iter=Attribute(value=Call(func=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='filter', ctx=Load()), args=[], keywords=[keyword(arg='regex', value=Constant(value='^relevant_')), keyword(arg='axis', value=Constant(value=1))]), attr='columns', ctx=Load()), body=[Assign(targets=[Subscript(value=Name(id='table_const', ctx=Load()), slice=Name(id='column', ctx=Load()), ctx=Store())], value=Constant(value=False))], orelse=[]), Assign(targets=[Subscript(value=Name(id='table_const', ctx=Load()), slice=Constant(value='n_significant'), ctx=Store())], value=Constant(value=0)), Expr(value=Call(func=Attribute(value=Name(id='table_const', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='p_value')], ctx=Load())), keyword(arg='inplace', value=Constant(value=True))]))], orelse=[]), Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='concat', ctx=Load()), args=[List(elts=[Name(id='relevance_table', ctx=Load()), Name(id='table_const', ctx=Load())], ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=0))])), If(test=Compare(left=Call(func=Name(id='sum', ctx=Load()), args=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='relevant'), ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='No feature was found relevant for {} for fdr level = {} (which corresponds to the maximal percentage of irrelevant features, consider using an higher fdr level or add other features.'), attr='format', ctx=Load()), args=[Name(id='ml_task', ctx=Load()), Name(id='fdr_level', ctx=Load())], keywords=[]), Name(id='RuntimeWarning', ctx=Load())], keywords=[]))], orelse=[])]), Return(value=Name(id='relevance_table', ctx=Load()))], decorator_list=[]), FunctionDef(name='_calculate_relevance_table_for_implicit_target', args=arguments(posonlyargs=[], args=[arg(arg='table_realsId'), arg(arg='table_binary'), arg(arg='xT'), arg(arg='test_real_feature'), arg(arg='test_binary_feature'), arg(arg='hypotheses_independent'), arg(arg='fdr_level'), arg(arg='map_function')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' Ͷ     Ǹ ƙόƥ')), Assign(targets=[Subscript(value=Name(id='table_realsId', ctx=Load()), slice=Constant(value='p_value'), ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), args=[Call(func=Name(id='map_function', ctx=Load()), args=[Name(id='test_real_feature', ctx=Load()), ListComp(elt=Subscript(value=Name(id='xT', ctx=Load()), slice=Name(id='FEATURE', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='FEATURE', ctx=Store()), iter=Attribute(value=Name(id='table_realsId', ctx=Load()), attr='index', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[keyword(arg='index', value=Attribute(value=Name(id='table_realsId', ctx=Load()), attr='index', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='table_binary', ctx=Load()), slice=Constant(value='p_value'), ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load()), args=[Call(func=Name(id='map_function', ctx=Load()), args=[Name(id='test_binary_feature', ctx=Load()), ListComp(elt=Subscript(value=Name(id='xT', ctx=Load()), slice=Name(id='FEATURE', ctx=Load()), ctx=Load()), generators=[comprehension(target=Name(id='FEATURE', ctx=Store()), iter=Attribute(value=Name(id='table_binary', ctx=Load()), attr='index', ctx=Load()), ifs=[], is_async=0)])], keywords=[])], keywords=[keyword(arg='index', value=Attribute(value=Name(id='table_binary', ctx=Load()), attr='index', ctx=Load()))])), Assign(targets=[Name(id='relevance_table', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='concat', ctx=Load()), args=[List(elts=[Name(id='table_realsId', ctx=Load()), Name(id='table_binary', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='method', ctx=Store())], value=IfExp(test=Name(id='hypotheses_independent', ctx=Load()), body=Constant(value='fdr_bh'), orelse=Constant(value='fdr_by'))), Assign(targets=[Subscript(value=Name(id='relevance_table', ctx=Load()), slice=Constant(value='relevant'), ctx=Store())], value=Subscript(value=Call(func=Name(id='multipletests', ctx=Load()), args=[Attribute(value=Name(id='relevance_table', ctx=Load()), attr='p_value', ctx=Load()), Name(id='fdr_level', ctx=Load()), Name(id='method', ctx=Load())], keywords=[]), slice=Constant(value=0), ctx=Load())), Return(value=Call(func=Attribute(value=Name(id='relevance_table', ctx=Load()), attr='sort_values', ctx=Load()), args=[Constant(value='p_value')], keywords=[]))], decorator_list=[]), FunctionDef(name='i', args=arguments(posonlyargs=[], args=[arg(arg='_y')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="Ͼ̰̈ƈˡIĎnȣfer ɜʋɯtheȬÜ ɨ8^mϱach͔iȉĶ£neͰ Æˈɗlea\x9drningȅ taφs͎\x8dǂŝ<k̮ \u0383̞to \u03a2̗sele\u0383̘0ơcȤątȄ ƪfƲƒ́oɲβr.\nTǚƂheɒΑ rÈ̉eĈs̞Ṷ̀͡ul¼úǃt wƾ̽ȰilǨĵξlɖ bʼe ei0ȳther Ξ`'ύĖreg'ÌrǊes˚ĥϴsiϷon'`Ȇ Ǘor Ł`'ŒclȈĘ»assǗificƏϲϱation4̷'ë`.ə\nI?ϔf˼ ǔth˭e ¾tÐaϦ²rgetͅ \u0382veēcʒ7torʍɝĝ ôonlěy ͓c̟ħonρίsiÂstsȹ ͮˉŉɴof iŢǓn\x90teg˧eɆr Ytyųľp̆ed ̄va̪ˢƾĔŹlÑuς̆esȣ̎Ȩ˽Ş oŤǬ˸rh oǀbjº?ûeìcɨϖtsdŞϸ,ı we a\x93s\x8fsʄοWum+e tǬh¶e; t\u038ba̿skë is `ʎΜ˦'Ŷclassi\x8cfZi©cĳatĤ,iϲƉoĨǵn='Ž˲`ˋȬ.ʧ\nElsΒȜe `'\x94regression'`\x83ϫ.\x8d\n\x86Ɖ\ņ:čp͇araŵm y: ǎTheȿ tarͯgɇʻ˼et K¸Ðvecqutor y.ƓΤŁɻ˞PΈ\n:ÄtȂype̳ y: ¿ Ϗp̑andaʥsˡM.þɧSer°Ȳies\nʻʀ:ϯretÉurȘnͣ:͜ \u03a2ƿ'ϝĠclaͺssiȋficaĩtͭiŠon\x9f´'͜ĉ oŐr '¶regɛreΦssiĪonĠ'\nȕÈ:ȂǇVɶï\x9bɓ}rĸ}ʻψPtyp\u0380eϳƪ¸͋Ȟ:ƃō ¬sƣtİrΊ")), If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Attribute(value=Name(id='_y', ctx=Load()), attr='dtype', ctx=Load()), attr='kind', ctx=Load()), ops=[In()], comparators=[Subscript(value=Attribute(value=Name(id='np', ctx=Load()), attr='typecodes', ctx=Load()), slice=Constant(value='AllInteger'), ctx=Load())]), Compare(left=Attribute(value=Name(id='_y', ctx=Load()), attr='dtype', ctx=Load()), ops=[Eq()], comparators=[Attribute(value=Name(id='np', ctx=Load()), attr='object', ctx=Load())])]), body=[Assign(targets=[Name(id='ml_task', ctx=Store())], value=Constant(value='classification'))], orelse=[Assign(targets=[Name(id='ml_task', ctx=Store())], value=Constant(value='regression'))]), Return(value=Name(id='ml_task', ctx=Load()))], decorator_list=[]), FunctionDef(name='combine_relevance_tables', args=arguments(posonlyargs=[], args=[arg(arg='relevance_tables')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[FunctionDef(name='_comb', args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[AugAssign(target=Attribute(value=Name(id='a', ctx=Load()), attr='relevant', ctx=Store()), op=BitOr(), value=Attribute(value=Name(id='b', ctx=Load()), attr='relevant', ctx=Load())), Assign(targets=[Attribute(value=Name(id='a', ctx=Load()), attr='p_value', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='a', ctx=Load()), attr='p_value', ctx=Load()), attr='combine', ctx=Load()), args=[Attribute(value=Name(id='b', ctx=Load()), attr='p_value', ctx=Load()), Name(id='min', ctx=Load()), Constant(value=1)], keywords=[])), Return(value=Name(id='a', ctx=Load()))], decorator_list=[]), Return(value=Call(func=Name(id='reduce', ctx=Load()), args=[Name(id='_comb', ctx=Load()), Name(id='relevance_tables', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='get_feature_type', args=arguments(posonlyargs=[], args=[arg(arg='feature_column')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="For åa given fÓeaturĳe, Ǉde˂YοϞǤxtȳǙerm̾ine if iϱtĜy\x98 Ɨ͂is real, b͋inary orɎ conʘýstant.\nHere bȬiÀnary ̀mϔeansǞ ɐthaÍƩt only two unique v̎alueęsǖ oVccuȷ̘rȤ in th͢e feȍaîtĠurƛϽe.\n\n:Ǩpar\x80ám feaṯure_coϗͷlumnč: ıThe̜´ !\u0383f¬eaĖtʎurTeƄ column\n:tyƞpe featurʧe_cĮolumn:\x86 pandȽaϯsé'.SΟeries˖\n:̅Ʉ̽Ŕrʟ)eturn: 'conʕstŨant'̙˳, '̴binar̓žy'a or 'rȮeƢal'")), Assign(targets=[Name(id='n_unique_values', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Call(func=Name(id='SET', ctx=Load()), args=[Attribute(value=Name(id='feature_column', ctx=Load()), attr='values', ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='n_unique_values', ctx=Load()), ops=[Eq()], comparators=[Constant(value=1)]), body=[Return(value=Constant(value='constant'))], orelse=[If(test=Compare(left=Name(id='n_unique_values', ctx=Load()), ops=[Eq()], comparators=[Constant(value=2)]), body=[Return(value=Constant(value='binary'))], orelse=[Return(value=Constant(value='real'))])])], decorator_list=[])], type_ignores=[])