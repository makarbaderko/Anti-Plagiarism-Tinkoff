Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='abc', names=[alias(name='abstractmethod')], level=0), ImportFrom(module='datetime', names=[alias(name='datetime')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='etna.libs.pmdarima_utils', names=[alias(name='seasonal_prediction_with_confidence')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='statsmodels.tools.sm_exceptions', names=[alias(name='ValueWarning')], level=0), ImportFrom(module='statsmodels.tsa.statespace.sarimax', names=[alias(name='SARIMAX')], level=0), ImportFrom(module='statsmodels.tsa.statespace.sarimax', names=[alias(name='SARIMAXResultsWrapper')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='etna.models.utils', names=[alias(name='determine_num_steps')], level=0), Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='filterwarnings', ctx=Load()), args=[], keywords=[keyword(arg='message', value=Constant(value='No frequency information was provided, so inferred frequency .* will be used')), keyword(arg='action', value=Constant(value='ignore')), keyword(arg='category', value=Name(id='ValueWarning', ctx=Load())), keyword(arg='module', value=Constant(value='statsmodels.tsa.base.tsa_model'))])), ClassDef(name='_SARIMAXBaseAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='ŹBase Řclass fμʹor adaãpțlɢʐt΄er˘s based on :py:̯Ŧclʳ·λass:`statsmoŴĥdϮelĔs.tsa.˫stateʓɭsp˝ace.sɢarimaxő.SARIMAX`.')), FunctionDef(name='_b', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ENDOG', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())), arg(arg='exog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[Name(id='abstractmethod', ctx=Load())], returns=Name(id='SARIMAXResultsWrapper', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='_check_df', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='horizon', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Something went wrong, regressor_columns is None!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='column_to_drop', ctx=Store())], value=ListComp(elt=Name(id='col', ctx=Load()), generators=[comprehension(target=Name(id='col', ctx=Store()), iter=Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load()), ifs=[Compare(left=Name(id='col', ctx=Load()), ops=[NotIn()], comparators=[BinOp(left=List(elts=[Constant(value='target'), Constant(value='timestamp')], ctx=Load()), op=Add(), right=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()))])], is_async=0)])), If(test=Name(id='column_to_drop', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[Constant(value='SARIMAX model does not work with exogenous features (features unknown in future).\n '), FormattedValue(value=Name(id='column_to_drop', ctx=Load()), conversion=-1), Constant(value=' will be dropped')]))]))], orelse=[]), If(test=Name(id='horizon', ctx=Load()), body=[Assign(targets=[Name(id='short_regressors', ctx=Store())], value=ListComp(elt=Name(id='regr', ctx=Load()), generators=[comprehension(target=Name(id='regr', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ifs=[Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Name(id='regr', ctx=Load()), ctx=Load()), attr='count', ctx=Load()), args=[], keywords=[]), ops=[Lt()], comparators=[Name(id='horizon', ctx=Load())])], is_async=0)])), If(test=Name(id='short_regressors', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Regressors '), FormattedValue(value=Name(id='short_regressors', ctx=Load()), conversion=-1), Constant(value=' are too short for chosen horizon value.\n Try lower horizon value, or drop this regressors.')])], keywords=[]))], orelse=[])], orelse=[])], decorator_list=[]), FunctionDef(name='fi', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressorsXlQF', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fitʚϋs ˶aÂ SAR8IMAX mɱɔo\u0383dʸelĴʜ.́\n\nParaɹΜ͝ÍmetǨer˞s\n--m-˾ϡ---ċ----\ndf:\n    Features d˕Ǧatafraȕmͣe\nŭregČǃressɿorsɡ:\n"   Ț ƑLi̧st of th\u0378e Ȳºco(luˢmn˱gs ̖ȷ˰wiƫ˳th regýressors\n\nReƒtɔurnsϵ\nZ-Z--̒----Š\n:\n ͊ Χ  Fitɇted m4˂oÖdŏeͭl')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Store())], value=Name(id='regressorsXlQF', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_encode_categoricals', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='exog_train', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_select_regressors', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_fit_results', ctx=Load()), args=[], keywords=[keyword(arg='endog', value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), keyword(arg='exog', value=Name(id='exog_train', ctx=Load()))])), Assign(targets=[Name(id='freq', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='infer_freq', ctx=Load()), args=[Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())], keywords=[keyword(arg='warn', value=Constant(value=False))])), If(test=Compare(left=Name(id='freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't determine frequency of a given dataframe")], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_SARIMAXBaseAdapter')), FunctionDef(name='_select_regressors', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), body=[Assign(targets=[Name(id='exog_future', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='regressor_columns', ctx=Load()), ctx=Load())), Assign(targets=[Attribute(value=Name(id='exog_future', ctx=Load()), attr='index', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()))], orelse=[Assign(targets=[Name(id='exog_future', ctx=Store())], value=Constant(value=None))]), Return(value=Name(id='exog_future', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), ctx=Load())), FunctionDef(name='_enco', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='categorical_colsrb', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='select_dtypes', ctx=Load()), args=[], keywords=[keyword(arg='include', value=List(elts=[Constant(value='category')], ctx=Load()))]), attr='columns', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])), Try(body=[Assign(targets=[Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Slice(), Name(id='categorical_colsrb', ctx=Load())], ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Name(id='categorical_colsrb', ctx=Load()), ctx=Load()), attr='astype', ctx=Load()), args=[Name(id='int', ctx=Load())], keywords=[]))], handlers=[ExceptHandler(type=Name(id='ValueError', ctx=Load()), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Categorical columns '), FormattedValue(value=Name(id='categorical_colsrb', ctx=Load()), conversion=-1), Constant(value=' can not been converted to int.\n Try to encode this columns manually.')])], keywords=[]))])], orelse=[], finalbody=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='PREDICTION_INTERVAL', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='CoΏmpûutΉeɶŝɠ preʶ|dictŜioȪns Ύ¶frͻȶoƨƉmăÓ a ̃S͇ŚΝɴARIæMǤAX moW͟˙dĶeųl ͳϽand ʐusŀe tr͒_Iue in-sƀJaɾÕǆmŪĬpU~leɦî daÍvta a\x80s lʲagsưʨ˭ izƍf p̬œosͨs͖D͋ΤiϗÁϞĊ\x89bleĕ/.\nΤˢſĢ\nParĭame˓te±rϩŹs\n--ƓǠ-Þ--Ĩ--ϫ-Ą--ʯ\ndǏʉŬf:\n Ϻ ο 3˺ƃϴ Featurʠe|sώÚƦĿŀ datyaÚfσɦramTe\npĴreϩd͵icĚt\xa0i˝Ʈôín_Ϸintervalͼ:\nǒ ǉƥ  Ė bIfά Trđuıe rʢ˖ß\u0383et͝uǬƅrns prŢŦəeądi!ctÓƲio˯n \x93iȩnνtŬeȫrvaέ̋ϸl forɕ foƼĕreΞcast\nqŦąǅuϴ͆anĚΆ̼ti͵les:ˎ\nƖ  Ƹ ? LéƖ8veɃls o͎ǤfŊ͛ń\x90ƹȄ \x95prepdic\u038bȤĘtiŻóoϡnɆÔ͑ ɰdiHʰstribu̵ti˞ʅon\nʟ\nʡ͡RetĮʹɬuƺrn˓sɮʘ\nȤƮ-ϒÉ---ό;-ͽȼ-ǧ-\n:\nƓ1\x97    Dataĝɬ¡FĖr¹amUeǡ̒Ň\x83 ʾwiɔthˍϛ pƫ̈redσiȿctǛioOnĒͼDǂs\x89β')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_prediction', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='PREDICTION_INTERVAL', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load())), keyword(arg='dynamic', value=Constant(value=False))]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='3Get þʊ:VĸSpy:c̭lass:`statĒsmʘoÕd\u0378\x9ceǙ\x83lsȡ].Ͳtsa.staϵt9e͇ƶƈ˘Ηs̾pace.sarimȹaƉxʀǵ.SAÜǫɥRňȆIʸMAXReʈsultɎËsǞ¯\x8cWŁrappevr`ȥ thatȬ iƎˮs used ins˳i̳ȧdȥ͌eʼͮÎ Reˆtnǐa cŚ˹laÕss.\n\nRetuğrnˬsʻ\n-¹.ˌ------\n:\nʮ"  Ǫ ʃÜIŷnternaϞl͟ moǢdūel¿')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load()))], decorator_list=[], returns=Name(id='SARIMAXResultsWrapper', ctx=Load())), FunctionDef(name='_make_prediction', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='PREDICTION_INTERVAL', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='dynamic', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='MƟakeŊ predictiȜͯonȜs taȷȹking into ađccount `\x93`dyµnamicı`` pͣƮar˾a÷ˮmǹ£eter.')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='horizon', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_encode_categoricals', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_df', ctx=Load()), args=[Name(id='df', ctx=Load()), Name(id='horizon', ctx=Load())], keywords=[])), Assign(targets=[Name(id='exog_future', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_select_regressors', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[])), Assign(targets=[Name(id='start_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='end_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='start_idx', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Name(id='start_timestamp', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), Assign(targets=[Name(id='end_idx', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_first_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Name(id='end_timestamp', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), If(test=Name(id='PREDICTION_INTERVAL', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='forecast', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Constant(value=0.05)), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Dict(keys=[Constant(value='mean')], values=[Name(id='forecast', ctx=Load())])], keywords=[])), For(target=Name(id='quant_ile', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Name(id='alpha', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[BinOp(left=Name(id='quant_ile', ctx=Load()), op=Mult(), right=Constant(value=2)), BinOp(left=BinOp(left=Constant(value=1), op=Sub(), right=Name(id='quant_ile', ctx=Load())), op=Mult(), right=Constant(value=2))], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='_', ctx=Store()), Name(id='borders', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Name(id='alpha', ctx=Load())), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), If(test=Compare(left=Name(id='quant_ile', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Constant(value=1), op=Div(), right=Constant(value=2))]), body=[Assign(targets=[Name(id='se', ctx=Store())], value=Subscript(value=Name(id='borders', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=0)], ctx=Load()), ctx=Load()))], orelse=[Assign(targets=[Name(id='se', ctx=Store())], value=Subscript(value=Name(id='borders', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value=1)], ctx=Load()), ctx=Load()))]), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='mean_'), FormattedValue(value=Name(id='quant_ile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Name(id='se', ctx=Load()))], orelse=[])], orelse=[Assign(targets=[Tuple(elts=[Name(id='forecast', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='seasonal_prediction_with_confidence', ctx=Load()), args=[], keywords=[keyword(arg='arima_res', value=Attribute(value=Name(id='self', ctx=Load()), attr='_fit_results', ctx=Load())), keyword(arg='start', value=Name(id='start_idx', ctx=Load())), keyword(arg='end', value=Name(id='end_idx', ctx=Load())), keyword(arg='X', value=Name(id='exog_future', ctx=Load())), keyword(arg='alpha', value=Constant(value=0.05)), keyword(arg='dynamic', value=Name(id='dynamic', ctx=Load()))])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Dict(keys=[Constant(value='mean')], values=[Name(id='forecast', ctx=Load())])], keywords=[]))]), Assign(targets=[Name(id='rename_dict', ctx=Store())], value=DictComp(key=Name(id='column', ctx=Load()), value=Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='replace', ctx=Load()), args=[Constant(value='mean'), Constant(value='target')], keywords=[]), generators=[comprehension(target=Name(id='column', ctx=Store()), iter=Attribute(value=Name(id='y_pred', ctx=Load()), attr='columns', ctx=Load()), ifs=[Call(func=Attribute(value=Name(id='column', ctx=Load()), attr='startswith', ctx=Load()), args=[Constant(value='mean')], keywords=[])], is_async=0)])), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='y_pred', ctx=Load()), attr='rename', ctx=Load()), args=[Name(id='rename_dict', ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='PREDICTION_INTERVAL', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compuĩte Ĉau΄ɬtoregressȪɛive ɼ°p̺\x88Ϗrediction͵s fr̚om ̷aÞ SARIMÐAXȰ m\u038bodel.\n\nÇParameRͻteϽǼrs\n-̾Σ---------\ndf:\n    F˪eatˇurαe̯ȳs datafȚʽrameƚ\npredictiʕΪon̙°ŭ_Ώinterϖval:\n   Ϭ  If̞ TruƄe returbns pr(edictioƘn iƾntervǀal Φȯfor forecasφɧt\nquantiles:\n ĳ Ő  ̘LeɤvelsΝ ofɐ ʃprediction disνtrib͞uʾtion\nɭ\nΘȂRetuɤrns\n-----İ--\n:\n    DataFrame with pǑ̏rediʛctȷions')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_make_prediction', ctx=Load()), args=[], keywords=[keyword(arg='df', value=Name(id='df', ctx=Load())), keyword(arg='prediction_interval', value=Name(id='PREDICTION_INTERVAL', ctx=Load())), keyword(arg='quantiles', value=Name(id='quantiles', ctx=Load())), keyword(arg='dynamic', value=Constant(value=True))]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], decorator_list=[]), ClassDef(name='_SARIMAXAdapter', bases=[Name(id='_SARIMAXBaseAdapter', ctx=Load())], keywords=[], body=[FunctionDef(name='_b', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='ENDOG', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='Series', ctx=Load())), arg(arg='exog', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ȯɦ ˴  ͠Ϻ˭     ʤ̕ǒ\x9d Ͳ      ð  ̒ Ȧȗ ș')), Assign(targets=[Name(id='endog_np', ctx=Store())], value=Attribute(value=Name(id='ENDOG', ctx=Load()), attr='values', ctx=Load())), Assign(targets=[Name(id='model', ctx=Store())], value=Call(func=Name(id='SARIMAX', ctx=Load()), args=[], keywords=[keyword(arg='endog', value=Name(id='endog_np', ctx=Load())), keyword(arg='exog', value=Name(id='exog', ctx=Load())), keyword(arg='order', value=Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Load())), keyword(arg='seasonal_order', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Load())), keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='measurement_error', value=Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Load())), keyword(arg='time_varying_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Load())), keyword(arg='mle_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Load())), keyword(arg='simple_differencing', value=Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Load())), keyword(arg='enforce_stationarity', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Load())), keyword(arg='enforce_invertibility', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Load())), keyword(arg='hamilton_representation', value=Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Load())), keyword(arg='concentrate_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Load())), keyword(arg='trend_offset', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Load())), keyword(arg='use_exact_diffuse', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load())), keyword(arg='validate_specification', value=Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load()))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Name(id='model', ctx=Load()), attr='fit', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[]), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='seasonal_order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='measurement_error', annotation=Name(id='bool', ctx=Load())), arg(arg='time_varying_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='mle_r_egression', annotation=Name(id='bool', ctx=Load())), arg(arg='simple_differencing', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_stationarity', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_invertibilityw', annotation=Name(id='bool', ctx=Load())), arg(arg='hamilton_', annotation=Name(id='bool', ctx=Load())), arg(arg='concentrate_scale', annotation=Name(id='bool', ctx=Load())), arg(arg='trend_offset', annotation=Name(id='float', ctx=Load())), arg(arg='use_exact_diffuse', annotation=Name(id='bool', ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missi', annotation=Name(id='str', ctx=Load())), arg(arg='validate_specificationoEdw', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=2), Constant(value=1), Constant(value=0)], ctx=Load()), Tuple(elts=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=12)], ctx=Load()), Constant(value='c'), Constant(value=False), Constant(value=False), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=False), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=True)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Store())], value=Name(id='order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Store())], value=Name(id='seasonal_order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Store())], value=Name(id='measurement_error', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Store())], value=Name(id='time_varying_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Store())], value=Name(id='mle_r_egression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Store())], value=Name(id='simple_differencing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Store())], value=Name(id='enforce_stationarity', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Store())], value=Name(id='enforce_invertibilityw', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Store())], value=Name(id='hamilton_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Store())], value=Name(id='concentrate_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Store())], value=Name(id='trend_offset', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Store())], value=Name(id='use_exact_diffuse', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missi', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Store())], value=Name(id='validate_specificationoEdw', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='s', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))], decorator_list=[])], decorator_list=[]), ClassDef(name='SARIMAXModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='seasonal_order', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='measurement_error', annotation=Name(id='bool', ctx=Load())), arg(arg='time_varying_regression', annotation=Name(id='bool', ctx=Load())), arg(arg='mle_r_egression', annotation=Name(id='bool', ctx=Load())), arg(arg='simple_differencing', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_stationarity', annotation=Name(id='bool', ctx=Load())), arg(arg='enforce_invertibilityw', annotation=Name(id='bool', ctx=Load())), arg(arg='hamilton_', annotation=Name(id='bool', ctx=Load())), arg(arg='concentrate_scale', annotation=Name(id='bool', ctx=Load())), arg(arg='trend_offset', annotation=Name(id='float', ctx=Load())), arg(arg='use_exact_diffuse', annotation=Name(id='bool', ctx=Load())), arg(arg='dates', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='datetime', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='freq', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='missi', annotation=Name(id='str', ctx=Load())), arg(arg='validate_specificationoEdw', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=2), Constant(value=1), Constant(value=0)], ctx=Load()), Tuple(elts=[Constant(value=1), Constant(value=1), Constant(value=0), Constant(value=12)], ctx=Load()), Constant(value='c'), Constant(value=False), Constant(value=False), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=True), Constant(value=False), Constant(value=False), Constant(value=1), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value='none'), Constant(value=True)]), body=[Expr(value=Constant(value='ΦIdͷnit SARIŭƙǟMϪȷAXįŻ moțȮŰdel wϡ̵iÒth¶̗Ι ˰½gïivʎenɩ ˘pŎara½ɘɕms.\nƣ\nĖPaƎrametders̽\n\x95)͆---\x9d-\x91ƴ˂ą--ő----°\nŻoPrʏdeĹrĭ̪ͤ:̤\n \u0381˙  ̻ The (p,d,q) oƤǐrderǝơ ̖ofʂ the mΑİoǙȭde\u0382l foHr ćÀthˈeϵ͚ nűÒuǋȆmbiɚȩer o˫fë AĹRȦ ʡà·pȤa̯ʯraǰϸímeteõrs,ʞ\nͬ˴  ɤ  d̝4ifϠ(fȊ˗eȥrʂeŒȮɴnc\x9f\x95Ϻes,ͨ aĴ˄³Č̿ndϝȆ ͈μMǢA ȟpɷɂaɝraÆmƘ̺et\x99erˁs.` `d` musńΗt\u0381 bȔe axn̾ňʒ Ŋ̙ȍȾintežɞƈgȪeηrͱ\nɽà   Ů ǉinΦdicatiäng t͈Ąhe ǒǩink͓teg̓rʛɺa¡tͣ\xa0ϻȡioÖΨnŸ oȌr˷ÿ͠deϔrĜ ěɯof ̃the proc½eßss, wʐhil̰e͗CǗÚ\n ɭĸ AŗǕ ͕ ȏ`ͨp`˨ anʏſöƲd\x7f `Ȼq` mayť eϹiǚther ȅbe ǚŊa8êΡn ȍÄiƼ͚jnİtŸ\xadegͭΠŏΠ̅ęrs iƊȤÉϥndɱica̡t\x9eingɶ tί˶he \x95ΗAșŋYRe ͏an͐d MA\nʲ \x99  ɪ or\u038bd9eçrƤs (sεÌoΫ͠ ƴthƳȋËat àllÐ laŚƔϐgs ŧğ̶upʍ\u038dȭ toǭ thƧ\x7foʅĕs!ƕͰǀeόĶƯͭ oʑrdƄʹersȀ Ͻarǃe͙ ͳ̥ǻinǳclud1ed˕ɟ) or ǮelʽǏsǽe\n̅ʹ Έ  ͪ ɸiter\x9daʁbleşɯƁ geivμiİnʱg sypecifiω͕c ɌʋARϛȀ anǌd /ǲ ̆orǫ M+ƙŻA%ɒ l̐́aGįgs to ƀi̫ħnȈλcċlΙɼuȆde. τDeO˫fɞauƷlt iǐsʽ\nŐ   «ǅ anǀ āAȋǑéR͆͵͵(1)ȋ̅ m̺od̪˳Ķeϻl: (1̋,ď0,0ͳ).\ns͇eʗasϐÊ\u0380onˣa\'lğ_o¼̹rdue"r͞:\n    0Ζ̋TĿhe (P\x83̎,̂Dʡ̐ȹ˱șʮšϵ,ʺQͨ;,sLĦ̦) ˱ŝorʭdùerƜķ of͵ʗ tǖhe seaʉķþs\x85onÐâŀl\x9b Ƶcompͼãoĸ\x80Œnent of HtheÂȱ .ˍmodel˳´ ˝fɹoƣr ψȣtµhßeʫ\n  PΣǘ@ń  AȴR ^pƐāħρarĺ̨ǺÞamĘeterPsÓ, diwáf¯ϙ̀\x85fƒeȜreÂȄ͂ĩnçƌɴeǥ\x9eM̻s,Ơ ;MAȏǟʿ̢ǎüŰġΆ pƬaΙ\x9arameterťƜŅs, and perσǪŐio\x82dicityȨ̑ǳͼ͐ȡ.\nͧʂǅvÂ ¿\u038d  íů J`ĜΓɯD` ɹmustĹ țbe ϯa̫nU i\u0379n=Ǎteǅge̯r ind̂Ĭicatinǖg ̥tϳhe iİn\x99PtɆĕeίeʹgrat2ϯioκn GoǍrşè͌der of ƵËtŠhe όprocessĺ,ϫ\n´   ̢ ϊ«w͝ǫh˶Νileƣ =`͌P`͢ƢȻƫĢŪ and Ŝ`Qþ`ġʐĵZ may eD#i͈ͷGtj;herɪ̏ bǴϮeĽ\x90 Ʊanώǰ inteĄgþers Ƃjind°tϔiȈcaǨɡϋt¯iëng tǉAhũe AR and MʹɕA\nϋ   ɠ[ oʸϳʪr¡´deȞǩrįsU (s̙o thaͨtH ˭Μɀ·al̚l laȴĲgsƀŐ up ÷tʏoʦ ƻthʵĔƽoάseü\x94 ȂʄoƑǩrderɯƜͺϡs, are ínƓ\x84cˌl̰Rudžed̡) ́or \u038bels̈e\nǹ    iǡterƳabΗles ɾgɁȞiœvinʔg specific ˈɃARsǅ¢ aėȘndǽ /Ű͘ oɲr 7MĈeAĕ ?@lagǕřs toƨ Ɂ̔includeŌ.ϕʇ `sɊ`ʂ iƤ¨sΣĿŁ ĵan\n ̭   iɀnΗStIŤ̀e)gƶģρɐŊȇer giv̧ingǳˋǿϛ ɂtϷJɠhe pͥe̽ri˜Áųod\xa0icity (nuǘ̹mb¸er /ƿ\x8eofϋ peϑriojdžsΗ\x89ʾŻ inɯȲǦ sʱeρƣ˭ǎsʏon),ƪ loϿfEt\u0378en it\n  ;  isʊ 4ς Úfo˼rΤ qůƦĻ¯arĿ͙ΰtƔϊ]ͰeΞωτɦɋȳrlŊy dϩÈabta ʜČÝ¾ɯϥȸor 1Ή2 f;oxr± moϛçȽĜnthly data.Ǣ̢ De±ΝÞfŗaxult ȫiȤɝΚs ͻŇnoŝ ϑseϷasonaͅl̚ЀȓϵΜ\n8 ̴ ˒ / efèfñec̩t.nĄ\nˤtľr\u0380enũÉȗǌļd:ŭ\n   ŋ Pɬaram\x92ʇ°Òƻeter co˵cntrolʪylinϫg t϶ĒœhɬʾeϋǾ de_\u0379t˓ermiøΩnis\x9aΦ6Σţi0c trend\x89 ÍpolɌΘyδṉomỉaF̹͑Ϝ˩lϯ\x87 :matȽh͆:`GAϱ(ǒt)`.ϔ\nϫȭϺ    ͻCaǦnnʳ bƕe s̃]4pƑ͵̿eòǸʢciǺfied ɗas ºa sǁtȅÄįri\x9aŧng wƛhere š\'cö\'Ʃ ɮiΛndŐicʍatesƼƝ͌ǐˁ ˕a conȹ͊ʷĦύϩsɷtaΙntϝP (i.ŷe. ƽaç̤\nƩƨ    ǂØdŕegreeˡʰ ĠϮΙzer̠o ǼcomponŦƛeʺnυŁʇt ɴŠƿofʶ tńhŜe trâÍūηeĸnd ϗżpoϽq͗lynoAΏmilal)Ͻ͍, \'Ɩ̐t̿\'? iʗndicates͒v ɄˀǍǖaÙ\u0378úě\nΙŤİ ¾¦ ʶ ˼ˌ ´liţǧ!nečar trЀδǥeΎÎϕnd žwiẗh ɹtϊψime, aŠźǕnšd ʦ\'ĸŉct\' űiɁs SĄb͜oth. Can ªʬŨals\x92o bðȀe spƳϽe˓Āʮˢʩĺ´QcɇͯiŞfiŔedɯ =a\x92sƻ ˕Ϲa͏ϊ¨n\nɵ  ɯ  itςšϪeǾġra̱bl̹e deưďfƵiningª Ż̷theʾ nƢ͢ʺðȮonΎƚϝ-̤ȟzş̌eƗɚro p\x86Ɉȴoʏ˱lynΊȝoŃmʢiȞ$alȝ ǶeŒĢ̬xŅponent̗ʵΝä́s tˈo ǅƻincludeÂϝ̭,^ ùʬϻinƧ\n  ȵ  ³iɵϘϔƀRncr̊ΣeaΧsiǨn\xadg£ȵ̞ ÔΪorder.Ɲʟ ͈7For exˢaČˢƮmpl̄e, `ϲ[1,ϐ1Ɩɓ,ć0˥,ȏČ¼2ĘƵ1]$`ŧ ÙdĆ̱\u0383̒ϼeȏ¼nϝoͻt7ͣes\n ϯ˲ϴ\u0381   :ȟ[math\u0382Ŗ:`Ɔɻa +Ŧ bΣöt̝ + ̗ct\x8a^3`. D̑eƼfaultͦ is t̹äo ǡńoUΛȃt inIŇΡ̎cluϽde aǡ ϰtˎrHend Ķ͑ŵcomͱ̝ṕĠoČs̾nȊϒeƊÁnt͍.ɲɱʮƠģπ\nm͇ǂeasuƧrRem˷ƣʮťeʞntɼγ_Ŋeɒr˟ror:\n͝ ÷\xadǼ [  2˯ŊWheǶΩtheˆr opɫΔrB̷Ϻ/bc noÀŏt to asʪsͻumţȤe tΛhe? enľǦĉɌduogeno5usƜŔ obȍͥsϢͥĪeōΜɝrv/ȆƾaĊtio\x9ensv `ʙɾŜ`endŃǗog`ʞƞġ were7\n Ǔ ǌ¾ϟ  m̘ŭe\x7fasu̧Ùȼɽȫred ÀwΠithΖ eǡr̢ror. ɒDeƺfa̻ultďγĞ i˸ͦsʊϘ Fa͞lse.ǃ\ntimϬe_var˗yɏing_reɏg͟resĻsƝǩiƃoÔ1n:\n    οUseʆÿʌ\x97ǭƀǢǟüdΌ ϿȌwÂɤheƑn an expluanat˩ofr\x82̮y Ƶɨź˙variȕableʴs, `exö́ȑcg`, ɠnare prov̷ided} prȈovŗideɵĮd\nͺ   Ɏπɦ to ȧĢ̷seΛleŦctu\'ɼϕ ̷w͞ĵ|ė¢͘he×ther oʾ̟Ír noʊƨʂɫ˞̲t coK͉effiGʴcientΛsό onʸ ƾtḩe exoǾοgBeʏνnλoʿus rΆx̷egǭrĖessoϭHrǝ±s āareË\nɅƔ  \x97  al\x82l˯owed ́to\x8fη\u0382ɂ var1y overκ ȸtime.ɮ ɷƎJ̤DAef˲ault iɋ&ʁȦȞs Falsõeć.\nmǘΚlͽe_reʰɋgͣ]Τression:\n̵    Wh}ǠethāȩǨer orı no˅t˃ ɗ˿to ͜usĕĈe˘ʱ esċǱtʜi\x9bmațtʣɍĩe̓ƯȞ Ư\u038dɃthėɍȢ˻͉eʫʴ ɧȼr̅egȍΛresƊsÙĮȈion coʾʐeffiΣʹæc\x98ieŸnÀʓts Ęfo˦r t\x81ϪȀhe\nɂ͜ ǁʝ͛ǠɎ̤ ŀΑp  ͭexoȀgeΔđn˫o\x8auʪs ɑvø̾arʶȌiablâϐeŸɧs ƻəas˽̖ °ïpaÆ¹rȤt ϲoǵĺķf̂ ma˃ʅxiźƏmum CělikeƅX}ɓșMlihoɧod esǅ˾ti͓ʅmatiśoȭʊn oͳrǼ ̳ƣthr¯Ɂ»olugˤǮh\n" ϕĈ  ɑ ì͙ǨƞtűʓʔhÙe KèaɅŔlǈman \x87fϟiltɶǩǊerØ͌ ʖ\x97ī(i.e. ̣rǴecursŔφidvĨĴϣeä 9ĻleÚaʤst sqƃ͝$uļłϓaǆres). ɻIΙȧƳf\nˉ  Ä  üÍ`time_ǕvarWϮyingʁK_̭̟regresļÙåsØɊiJoΫn̗`Č Ʌi0s¦ ýʂTrŧʊ«ueɦŏǽī, xtIhɓÄi!sɴ˨ m͚ŎϏɶïu\x81ŭƜʒɨs̶t ˟bòe͞ set t˃o Fa_lsZe. D˥efaCul\x96t\n    iͮŐs TrήĚue.\nʗsiQmφðple_dΎiȫf¨feϏrɝˤ8eŴncǆʧinΪg:\n Ĭ ɥIĸ  Whethģxɕerϧ˖Ϲ or ƨnot§ to uĮ\xadseȳē\x8b ˯wøɽpaɜrtia̳ǭ̬̚lɳȫly ˷cožnĀditi÷ǅonalǸ̎\u0381 ̚maxiϻmuȯmϷʙƿ ĥli{kelih8Ɏ4oʉͩođd˻\n ʻɬ  ˮίȅ ŧ̧«eûstǛi"maƞti2oŶn. Ifƭ TruƑeǌ,ɥ˙ʰ ̄diffúereʤnɝcinϰ˜g̈ iosŬƵʤ\u0381 ΧperfÞorm˼edʢ ǂpriŵoɟŗȜ Ģʉtoʥ ʽesǊȆtim˹ƹaȩtiĀű˦oùn,\nΦ}ɕ ϮƇ   whŊ/ʶĺich diˆscaßr«ds Ϯt\x98heϜɭö fɟirs\x97Ϥt :mƽa×t§hÝ:Y`s DȺĴ ͻ+ŁÎ dĄ̊` iˮāΏnŨǣȫiÁͩti˰ũal ̓romΫws ĘbȗǲÝ˟t ,̒ęʺreˬĚɼs&ulļtŪĊsß i̋n a\n  γ ȇȬN§ϨÿƏɰ ɣϩs&amallǘãȷeǐr QƒŲ͘ĥ͙͆sa\x88ȐtͼaŽΗteɃ-spÌaceű forŴϵmulΑaǏtŵê̲ioθ>n.̀ USe̩ʌŪeŗ the NoteˁŃs§Ħ sectƌionŶƺ ΨfoƉr Ô͏ƴimportaΧ\x9aąn̜͗t\n˃w Κ   deØtaibǵɡls Ϡaboˍut ȂiͳnteƆʟɜrϨpreʇt̜ƿȮɲȿ̨i©ng ërʰesultsɗŧ wι̮hen thýis o\x8epŘti\x7fĄʶon\' is used. ̍ϐIĤϠˆfΎΪ FaĀls«ƴ͛ŌeƬ˵,\n  Ƨ ˸ Șǖt̶hˡe faȥʍullǯ īűƽȧ̂S̆AɸRɒξ̈́οIM\x82uAŻXƨ mloίdel is Ϧpuṫ iƜnΧÈΜĕɫ staǕt®ĄŘåeη-ǹspaνɗc5e̵ ̼fʹ˙orȐmϜʛ ĈϮso Ϩtha÷t Ȼđ/aɃXlƔ͑ɹl\n̚ Ű̮ʄȝ ú̀̽  ƐÇǃdat˴ǨaŨp˻oͼŋʿÔinÍtsȃ ;ÛcĨan îbe uʴɽƹ¨sed in eĂͫɘstȭiɓmat˘ϝig̊Éǈon.vDK DŤe˔faÉ͞ˠuʶlt ŀips ǧFəÐaʝls¥e.\nϫenơfo̩rμce_\x8dsǦta¨tÈɮ\u03a2ΰƒŕiËonaƦCrʈ͗ityǑƏɵ:ŧ\n    Wheth>eĩr o¥r no¤tƊ ͱtɔȫo ˾ǽtöěƺƇĞrͽ¯a/n̈sfoʍrmΆſ the˿ ARΰ pǏaraƪ̶me6̾terʇs ŏto̍ Ëe͔nfoƯξrͶcĠǒeǂ statiƱonarity\\\n ǣě8  K in tʓh\x92e ǡæɱπaut˹oÙȽrƈ;e2Ǘαgres˂sɔi(veƈ ǧŒcŊomponeźMnt ȧ}oɏļf th7eρ ȼJ̫mƤʇoμɕƌdʂǩel. DeϷfasȫulƼt is TrueŇ.\nenŖȱf\x94oƄrc±eɒϻɞ_inHveǂrtibɂβ˸ilȆity̅:\\\n   ) Wheƽ/th˥Ƹer͉ or noƫtǧ tɑo ̓\u0383ƳʟtXçran½sform ɥϊtƗhe MȊA˅ ɐpΌaUrͲa͆>͚̆mÈetersʳ tĉϮ(ɑo ϥeɞnfǻo˄Ƒrce iƨnveüyrtiήbilitƀ¯ĥ-Đy\nζʈ   ǈ ̓in the ěmoƒving aveṟ̭ageχ coΑmpƨo@ƶnʾeʔʸǾnƐts ȉˎof thʞťe \x9aȉmmo{dȮYeοϟlʁ.í D͘Ƀefault ̆˅Qȣ½is)̐ ΣTrƶ\x95əue.\nhCamiɗlteɺon_ʊ-rĘɲŉWͫepresentatiͿoǔŕ\u03a2n̽:Ť\n  Ɩ ƪʢ ǥͿW̗ƵɲhŜ ethˬe˿rÏ \\ɺɫoźrj\x9c Ϳn̷oŮt ˅Ļtɖµo u=seɍ tǸhe Haɻ̍mğiltǿƃö́\x83n ŰrΧepr͊άeseÐntßati<Ǘoųn of aÞÙn A̰̲RMȞ˪A ãɨp̤roƆcesȭs\n    ŷ(iμf Tǅ̠ȱΎruü\x97e) K¶or\x86 ǋœthe ƵHarveyR Œrʠ̝eεʹƔDϫ\x8bpre\u0383sƊϼeǲntation (Ĉif ŴǚFahlsιe̅uG̊˜)ú. DefaŮu̎ltϩɍȬɅϧ iĪͥ\x9fs Ĉ Fǟ͝aΘl\\sȢe.\nc\x8fĳƟoĦÂήncenŔtrƙaϽteð_sŨμˑͳcňaČˏϡle:ā\n   ʫϡ Ϻͣ˧WhețtŠŊcÊ͉îƒhȓ͜£Ϯƀer or\x9f Ïɀnot ΒɔtoƔͭ coφnƆcϨ*Ǒeϕn\x9aÊʰ˖^t̏ϱra+tϽe] tΒͣhe s̨calέe (varίʣŧianceϣ τof the er-rǝoÇr ZɋtÇŖ˫erƯm)\n ũʼ ʃ ǣɊɺ\x88 GoSutϑ oåfŁɎ̤ ʔϰυthǽe ªlikeũlΧ̾iƏʽhoodΜ.Ϊ TęhiƓs ̉reΈϠʔȢducʹes ȏthe nuͦſɮmber oūΓªʁ̞f ãpͽarametεȩers estimɍǯatêed\n§ Ȋ   Ĭͻb̜ϰyθŁ j̝maximΰŞu˫m liƄʻk\x85ö˳elih͙ood byɟϓͭ oˉnȏĳe, ùbut» Ʀ˱s͇tμ˯andι˟a6rǆdϵϮ ˈȸCɧ®Ǘerm7rgorȰsɒ wiƀll\x8eʝ ɥth͒en noȣtÙξ\nɇ ȟ   be avka¿ilable Ϟfor the scɟκaĄl\x96e parûE͛ŨĤaÓmůeƥ̟tȕerj.B̹\ntr^-es\x93nd_ɖoffØse̷t͎Êƫ:\n    ̧Tʊheͅȩ ɨoɪÊfτǭfϺ͊set̉ Ǹąƍ̋Ⱥ\x8aat Řήwǹhiήʾcɨh˔ to ̈ʨstar\x94tǿ ÿtiÆƝ΄me tr˲end ɍva«ȲlQu\x9a˂eķΞsI˅Ìɧ. DƔeγfͧaʠuûlt iǬsƼ 1, ŵξsoʖ\x89 t6ʇhat\n   Ȉ if `ɹǡǲt̳ͽreĀnʰ˓dč=ǀ\'tø\'` thȩͳe ĻʐtreÞǅΎĞΖn̻ɬd ǃǅ˙iQȶVs ğơe\u03a2qu͙al\x90ϼɼ tΣϧo˞ɡι 1ʈ, 2,i .{L.Į˺.ˍ, nɫobÖs͠.œ ɇTĀypiċRϳʢ=al͵ly̟ Ͻis oônȣ»ly\n Úŵ ā ĺȮ ɫsȓʀ˶et ǕÀwÃhƛen tɇh̅ ƅe mɔoɫd̦ȓel createˮϳ{Ŭd ͚bΎșyʥ ̸ͥexžtʁendi˒nëgȏ aƤV previouƺ¯\xa0s Ô¡dŧĻ̀atǎaseĈåt.\nʣżu\x90ǿseć_όexaϭ͉ctΜ"_˄͂ɠϙĄÝ\u0379diÙ\x9cǉϨfffuse:́˪Ⱥð\n    WÁhʭɇe\x7fther Žor notǎ ǐȵtoÄǧ uˊse exϩa͕ct  ǥdif<ǑfͲȇʻαuse \x95initiɞŦalĎǃΉ͋iɚzagÜϿtioЀnǳ forΨ non-˚sÚŋÛtatioTͧÓnaȉry\n  ŃˎŔ  ȃĆ̂statesƿ. DeĨǐ~ʇ¯f˥aultϿ ˭χɀiǵs FcŬaʌl̯se ƶɣΆϳǙ̠(iĐn w˽hǀiʹήc̷Ƀ̸h© cƜasȬe aȭppȼɠœro͜ϫ-̓Ȅxi˽maέteČƈι ͣdiőϖfϖfȍuüīse\nʥ υ  ¥Ν i\x92nitiwιħʞa˻ǸlɅǶ̩́½ǐz\x82Ûa̍˳ȬteiäoɄn iϰs usʯŜedƙɒ).\n\x85ȘdateÁs:\nǤϟʎ  ̬  ͞If ̭no in\x84d͵e˲x iˎϞs ĉ\x98gØλ͙Ƭʲʰ\x8bƠiven by `endog`pƱ ̾Ěorˡˎ `eŕϥϗxoāœg»`, ƀanĲ arȪra]y-liȊkΥe o͂ϼ3̽bject ΥoȄŖf˔˔Ţ\nØ  ɨ  Z˞date̙°ǆtʣ̩iɶˮme oəbδʞjeNctɐs c˥̭an ̲beʸ` pŁΌϰɔΏ̮ǊrήϣovǑǸide͂dȋZ.ɜͷ̗Ǣ;\nfrÞWɻeϦɘq:\n  ƃ  If no ǱindƊeϰjx Χiʁsʲ givenǷ bŤČčyΙ `en1doŹgĀ`° ~or `eïxog`, ͇σDĝthǇeő \u0382f\xad\u0380reźqu˶en\x9acyɽʔ͒ƽĬ of Òtŵͤhĸe\nĭ ǅ ό  tĶɔiΥme-ͪhsžͯeǚrȁies _Ƚmay beǨ ¸ƴsŻˁpeȧƦcjiǍιifșiƛed herʺe as a Pȼand-as oƸffset ͽo>#¹r ̼Ûoffset s´triÑ˫ng.\nɮmiƃs¡Íʨsɔȷ̀έingɼ:ϣɻł\nυ Ώ   Ava͛ila͝bl̤ØeǚϾϹ$ opϣËtiͯons are¨ \'Țn\x7fone\'ɒ\x82,͏ʳȿƹ \'d̲roǰp=ɖIʥ\',ĲΨ aεƚnd \'ra͕iƀƪƜse\'. ǚIɸf \'nƷo\x86ne\'©, nÃȼo ̉\u0381ǵϓn̈́aɉńǐ̮nͩʹǾ<\n5\u0381    cϾh^eȩġ³cking˳ is doneʄ.͕ I˲f \'drΏoǉͧpĞf\'˺Ȣϓ, a̿Ćɬn×yɕ o¯bseƻrɾvatĲiˋwons wŉith ϞnaķſnĘsǎ× ̹ʅa×̜r ȩϹeƄǑ ¯ÌdʶŶϹόrοop4pǎe\xadd.ūǋʓ\nǚ\x95Ì ɱ   ŘȧIf ǂ\'ΉraUis7e¡\', an Ēeȩ͛rrņ1ΔoĲÿrŀ is réaisͮOƽƨfed5Ϡɋƞ.VˋȚ Defːauͪl\x97t iàs \'¨non̔ȝ\u0383e\'.ʦ\x83\n͘"vali͟ŅdƎƱɇ\x87ateʗͥt_sKpeǰc?Uifϡicaϯǫ͓ÐtionǑȱɮǭù:ϴ\n   K ˍIȲf ůTruyȾɑe, ͉Ȉv̘aĝliwdƴa\x94Ĩti͈̯on o\u038bf Ň˷h*yperϛpɭaǏʙraδțˤ½ȽmƈeƵterɶ͒sϳ ˭ȗisǲť perf\xa0or¯ɇϿme¿dΎ.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Store())], value=Name(id='order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Store())], value=Name(id='seasonal_order', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Store())], value=Name(id='trend', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Store())], value=Name(id='measurement_error', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Store())], value=Name(id='time_varying_regression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Store())], value=Name(id='mle_r_egression', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Store())], value=Name(id='simple_differencing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Store())], value=Name(id='enforce_stationarity', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Store())], value=Name(id='enforce_invertibilityw', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Store())], value=Name(id='hamilton_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Store())], value=Name(id='concentrate_scale', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Store())], value=Name(id='trend_offset', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Store())], value=Name(id='use_exact_diffuse', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Store())], value=Name(id='dates', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Store())], value=Name(id='missi', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Store())], value=Name(id='validate_specificationoEdw', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='s', ctx=Load()), args=[Name(id='SARIMAXModel', ctx=Load()), Name(id='self', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_SARIMAXAdapter', ctx=Load()), args=[], keywords=[keyword(arg='order', value=Attribute(value=Name(id='self', ctx=Load()), attr='order', ctx=Load())), keyword(arg='seasonal_order', value=Attribute(value=Name(id='self', ctx=Load()), attr='seasonal_order', ctx=Load())), keyword(arg='trend', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend', ctx=Load())), keyword(arg='measurement_error', value=Attribute(value=Name(id='self', ctx=Load()), attr='measurement_error', ctx=Load())), keyword(arg='time_varying_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='time_varying_regression', ctx=Load())), keyword(arg='mle_regression', value=Attribute(value=Name(id='self', ctx=Load()), attr='mle_regression', ctx=Load())), keyword(arg='simple_differencing', value=Attribute(value=Name(id='self', ctx=Load()), attr='simple_differencing', ctx=Load())), keyword(arg='enforce_stationarity', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_stationarity', ctx=Load())), keyword(arg='enforce_invertibility', value=Attribute(value=Name(id='self', ctx=Load()), attr='enforce_invertibility', ctx=Load())), keyword(arg='hamilton_representation', value=Attribute(value=Name(id='self', ctx=Load()), attr='hamilton_representation', ctx=Load())), keyword(arg='concentrate_scale', value=Attribute(value=Name(id='self', ctx=Load()), attr='concentrate_scale', ctx=Load())), keyword(arg='trend_offset', value=Attribute(value=Name(id='self', ctx=Load()), attr='trend_offset', ctx=Load())), keyword(arg='use_exact_diffuse', value=Attribute(value=Name(id='self', ctx=Load()), attr='use_exact_diffuse', ctx=Load())), keyword(arg='dates', value=Attribute(value=Name(id='self', ctx=Load()), attr='dates', ctx=Load())), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='freq', ctx=Load())), keyword(arg='missing', value=Attribute(value=Name(id='self', ctx=Load()), attr='missing', ctx=Load())), keyword(arg='validate_specification', value=Attribute(value=Name(id='self', ctx=Load()), attr='validate_specification', ctx=Load())), keyword(value=Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])