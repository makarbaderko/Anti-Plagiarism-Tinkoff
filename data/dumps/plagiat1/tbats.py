Module(body=[ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='tbats.tbats', names=[alias(name='TBATS')], level=0), ImportFrom(module='tbats.abstract', names=[alias(name='ContextInterface')], level=0), ImportFrom(module='tbats.abstract', names=[alias(name='Estimator')], level=0), ImportFrom(module='tbats.bats', names=[alias(name='BATS')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='tbats.tbats.Model', names=[alias(name='Model')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.utils', names=[alias(name='determine_num_steps')], level=0), ClassDef(name='_TBATSAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='model', annotation=Name(id='Estimator', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Name(id='model', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="It is not possible to make in-sample predictions with BATS/TBATS model! In-sample predictions aren't supported by current implementation.")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='steps_to_forecast', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), Assign(targets=[Name(id='steps_to_skip', ctx=Store())], value=BinOp(left=Name(id='steps_to_forecast', ctx=Load()), op=Sub(), right=Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()))), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), If(test=Name(id='prediction_interval', ctx=Load()), body=[For(target=Name(id='quant', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='pred', ctx=Store()), Name(id='confidence_intervals', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='steps_to_forecast', ctx=Load())), keyword(arg='confidence_level', value=Name(id='quant', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load())), If(test=Compare(left=Name(id='quant', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Constant(value=1), op=Div(), right=Constant(value=2))]), body=[Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quant', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='confidence_intervals', ctx=Load()), slice=Constant(value='lower_bound'), ctx=Load()))], orelse=[Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quant', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='confidence_intervals', ctx=Load()), slice=Constant(value='upper_bound'), ctx=Load()))])], orelse=[])], orelse=[Assign(targets=[Name(id='pred', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='steps_to_forecast', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pred', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load()))]), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='y_pred', ctx=Load()), attr='iloc', ctx=Load()), slice=Slice(lower=Name(id='steps_to_skip', ctx=Load())), ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))])), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()))], decorator_list=[], returns=Name(id='Model', ctx=Load())), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=' ɯ   ƸʔŞ  ͨ˽       ĺɖ \x8dȽ Ɩ    ')), Assign(targets=[Name(id='freq', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='infer_freq', ctx=Load()), args=[Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())], keywords=[keyword(arg='warn', value=Constant(value=False))])), If(test=Compare(left=Name(id='freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't determine frequency of a given dataframe")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Name(id='freq', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[]), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[Constant(value="Method predict isn't currently implemented!")], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], decorator_list=[]), ClassDef(name='BATSModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Cϒʰ<lNÔasɐs fo\x97Ȩʷr hËolΦƃdiȏngȕˠκ ØsʈegĔmϼen\x81t ^ϞÒόintKeɥφr¸̩va̠l@ Bό̍ATSʁ mƊ͚̈́şĹoȳdeͳlî\x87.A')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='u', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='s', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='str', ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Expr(value=Constant(value="CreaɈtʣe \u0383BATcS\x8cǋȲMĉȨoǈåde̪l ǫČwi|tŰh˝Ī giˁˉƽ̜venÛ paɅrƯaɏ1metì/\x86ers.\nƤ\nParϽaƺ̞mͥƴet̻ʿǨ\x82ersƐ\n-Ư³Ȓ-ͤ----ý---Ϡ-\nųsÖe¸_b+Ķoʙx_coϿĭʆx:Ƈͮ boolχʴ oϙr ĹNdone˾Ʒϩϙ,Þ Å÷@optͰion̐a˛lʶƬ (|def˯rȵauπȎl0t=No}nʫe)\n    Iɸġfͫ ƽBφÍΫoxĆƋ-Co˹ͯͲȺˬx ϴǞǈtranŘsΔf˸orơŪmΠ>ation ofʉʃ oȁrig\x84iűnʯţaB˺Șl series shȖoĵulʤȉdȆ ̼be ˰ƹˆ\x81aͶƯ͊ǜppͲlΉie͒d.̇\n Ι  ̀ǯ Whenʹ ˲NÃon͵ȝe źͰb;΄oΥĄÚpthʯq cʧ%ase×ρs s˴2˸haɟll beľ c̎ϔɨ̉ɑoΣns§id̷eΦreÁd ψandąǞO \x9abȸeˍ̐tϷĀʝteƤϹ\x88r ȒisǃɌǔϟ selected bʣyŚ A̫I&ũC.\n̋bo\x95xʧǇŃ_cƟ̤ɲoxλÆ_ǽĶboşundª̗ŏs̟: t±uple, ϬshǙ\x82apeȪ=Ȅ(7͞2ƨ,Ͷ), optionƑalʎ â(\u0382dʷƓefìiault=(Ņ0, 1))\n « ƃ  }Mini̾mal andĉ ɜǲmȘėDaΞxiɋ3Ⱥm2al( ¹Boͯx\u0381-\xa0ɏCośx p9Ƞareameter ʹ/vaĎlues.ř\nÂuóseɣ_treånʇdğʝƧ: bo͂ol or DNñoϕȔn7e\x8eʴͿ,ðƌ ȢopʻǘEȂtionaϝƢl \x98(defaulǙt=NÖone\u0379)\n   ȪȘ InɩϰÏdicaĮtĕǾȻ\x91ąŌ˲eȢsÈ Qwͭhɮ˗ȋet̋hϧˊeőĳr 0toΒ ŇincluȤΒĦdeʹ̱º aˍɷ trenϬd oɓr ʕno͐t.\näĎCʔ ϣ˫   Wőheǣčn ĂƱ̮̼Nones\x7f both caɝ\x9bȌδsesψ& shaʕ́lƌϧ̝l¾ \x84bÏȁe conĸsgȷiͣdȐeʗrΩÐ͢eʛdͿ S̄and betterɇʋɶ ist ϋseʤ̈́ĞclecƑted by̗ A̻IϱC˓.\nusŨeɝ͝_daŐ$m˷pedάɫΓϵŷ_-7tre͵̺Ňnád:F \x88ǵbʢooǖʸl oΑær bNĝ̡onÊe, opΩtˈiźĦonaǧɶl (ƴɛdefault=NoΒne)\n ˎʹ ζ  Iʔ\x80ĈndiʌcaǤtŶeės whƇǣeϴàĀtherÁˇɋ\x7f ƁX̯ǫtŢo i¹̯n\x85˅cludeá Ϩ̉aΞƣ ɐdǣ˪a˦mʆ˪̙ͩpiĜng\u0379 pa¸ɠraɎ˳metŒeʿΦr ~dǷin t΄he treȕznd or ȝṅ̨ȧɻĬotãǟ.̊\nǭɑ\u0380˅¿ν ¯˄ĚΚg  ȱ Appli!ǯƎes o*«nʙlȂ\x8eyų whenŖ`ΥͬȀ trend ̆\x84ƛπi\u038d͑s usƲ̦eŀč¼żǲd.+\nȧ  Ǒ  When Nƺɜone˙ both {łΓcJɎaŞǞͯsɏϽǏe˂s sɂhallżϼI beƢŮĞ conÄsǃiƀ×dered anΨɀdɂ[ ǤbetŤŹʣtʵer ƪiʹβs Åϯ̚ȃĊƲŃΚĿćʞs˚eleͮÕcƂt϶edǾċ bĲy AIC.ǗJ\nsěaǼsɠoǛknal_perio͑ds: iƸterablTè or ɬ͑ar]raỳ͐-liɄakȝe źoǌf ZintB ̥v͟ɠːalueȍs, ŮopŮǋt϶ƌional (̴ƇdĂЀ\x8bͬϽ͊ÉëɚϖefȉƕΦașult\x8fF=No¦Gnͅeê)ʤϘ\n   ˾ ɟʧǾL˸ȣengˌ͚Ƴth oΈĠ͜f^ ̎èeĕach͢ ΐoȷfȚ͜ ļtheƋ͞ perØizoˑʵÄds (aØßȩmou̴ĕnt of oÒbserYvaèŋϊtionÙs̹ in #each ʿper)iod).žƻ\nΦ Ë   BͽAT͒\x9dS˅ aƇ§cc]ʦeptϠs\\ι only ˋinɋt vɼλalǌōu\x9aes ;ȓhɡʲe̼rƑ͖e.϶ϲ\n    Wh˒en NonʪȉΤe Ǟorˮ emϱpty̿ baϬϠrraỷ,V\x87 nǇʞoǍŕnƶ-seĒasήonal model s̘haφll be fiv˸tƜtͿeȧȍ͑d.\nǓuse_aĜƑrmƠa_ȦeƎrroǇξrs:Ețǝ bo˶olˏ, ͘ʉoϹptionʡ˘ŭĆϲ͂alψ (ȧɐɵńdefͻaĿulȴʽʀʁt=ITruQe)Ĉ\nó  ƱªɄ  W͇heǲ\u0380ϥn /Tǽœórue̫ȿ BATˈS ʾwɚɔiϤʅlȯĖlΦů t̂ϋǧry ̫ʅΥto ̞ǈiΊ͈˱ǰmprĲocveͫ Ǫt˼FɊhe ǟmȈod\x8delϸϨą̷\x82OɅ˗ ʅύʌby mɖeoȔ͑ʨϽdel'˛l˦inēg reʳsxiduaϐls̞ wi͂thÞ \u0380ɷAGR°ÎM4˞ʵˋͿĬǪA.̕\nĔ ŵ  ʍ ϗBǜeAstƭ ð ǌmod˭ũ͢el wiίlʣl bIϳe seͧμĺeˏcɅCèϝɸted bȆŖÈy¥ƈǯ A\u0381IȖƌCo.\n  Ɵ  ̯IƄf êɓFʞa\x8dlğse,@ \x83ARMĿđA r˴ʅ͝eʢsςi¢duψBaϾlǚϻɛģgs moșdeliÌ(ngŮ̝ wilίl ÇǆnoǄϨtϚ zοbe ŋc˵onsȦŔ͔iˡdeͩrʄed.\nsϕhowɈʠ_wa̧ͧ˩rnǧiɧngs: ΚboɕolĞ,Ɯã opò8Ͽ̶¼ĊtiƼƥonɼɼćǻɜ̏a˳Šl\x87 ͽÈ(de\x9affaıuϋlt=æȉTrue̱͟)\nǯ Ǜ ˴ υ ıIȼ%f w̢͚a\x9crni΄ngs sǌθyhouɾʻ\x82Ȯl\u0379dί bą̅ņe sɼŷĪhƣowγ̀ǯn or noǶt.żÀ\n   Ð µA˓lsΖo²ʳˋ˕ soeŇeʁ͜ ɌʻMo̓del.waʬrƻniŭnMǆgsɦ vȮariaπble thǹċat ɂc\x9eo\x81nȺȃΩ̍ʒtai}ȀÇnƬs all ˍm̤odȠÏe¢ľ̷ʏ 4Šreālƈat̸edβƹΫ̸{ pwʡ\x84aÑƴrƛnings.kɠ̃\nn_jo\x86bsƖ: inʩʐåtS, ϳojŵ·ϧptϷiĘoϲŁĪ̅nal (ʺɄ̷dȹʸͪefaultʽ=Noζ̌neϩʃȁŎ)\n W§   How ΖmanyΦˇ jŒʨcϟƼɈobȫsǫ8 ̮toƍ ru\u038b\x87͆n# in pÛa͑rđalleφʑlǣ Áwhďe n f^iρqt˙tingĪ BATS̘ˑ modeƴͰḽƍǲ\u0382Θ.\x88\n    Wheʘnʓ 5n̦oȾɰt proʦ͏̺ʭ˴ɦłvÐid4jψeǗ<d BÏ\x93A\x82TS˦ sh¦ϓƇ\x9baΈll tryȢʠ͖U toί °͚˸ͻuStilę̷izʶͶƫɥʾŪe al\x96lȎfĖ ava$&\x86iUŔl\x8bϐʶabΒleϔ cˆįępɆuÍ coresıΪ.˗\nïmuƫlČtǃȇϢŴ\x97iproɋce}sįsinΨg_st\u0379art_ϊmAetʞhȆoʟd: str͜, ȵop\x90Ãέtionalˋͧū (dĢͧeȿȃňÛ˴fΙaʾulν\x84t=ĥ'%sÝǏȤɔpʶǖawn')\n Ƣ ͜  ßHʭǼoͣw ĀtƯh̭reÃǎds ʢshoulΨd bƿe starteěd.\nĤ ī n Ůɏ\x81ɉ ǑSϻee͎ httǛps://ǾődŤǜo̜ˌ9c\x98϶sú˧.p¶ythȦoɸn.org;ɉJƾ/ò3ɹ»/¹\x7fʆϐlˬŰibrɔary/mul̡)tŝͥipro̪cess͊inȃgͷ.hʄtmlĕ#conƠΉ[tĚ@exts-ɔ\u0381aǤnŨdϢãˤɿΎ-ǁƯstſarʶϻt-metųhods\ncoå͜ȥntextΑ:\x9bTǺƍĽ˔ ØabθV\x7f̡sɴt̩raʁĜ̪c1tʕ.C̟oɘnjŌ\xad˵textIͮn}terfΜace,Ǫ opð\x85tion\x98a̷^Ál̵- Ͻʊċ΅(defâ˿ault=ʉNÄone)ZŚ\n Ɂ  ͈ͪ yFor șadvaϪ̋ǔnǼā̱ceόd u˧ų\x97seɫírs˞ ͠o;Ȗnìlɬύϩy. Pr¦\x95o\x7fv̱iÒ5ʷde tȾ$Ȩhis ̫toǡ ̨oveŗride ď͎deɡɂųfaόuTlt be͑hΐaviorǗs")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='BATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='u', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_errors', ctx=Load())), keyword(arg='show_warnings', value=Name(id='s', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='context', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='TBATSModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='u', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_errors', annotation=Name(id='bool', ctx=Load())), arg(arg='s', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='str', ctx=Load())), arg(arg='context', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Expr(value=Constant(value='Cre̮ċateɵ ˔TBØǀˁʘʀATSModmƳelʢ ̃wiɆt˴h ʐ\x9aǒͿgivenƾ Ȁp˲a̢raЀmˡeter\x87sɳ.\npρ\nParametersȚ\n--ϐ--------¬\n\x93ɪuse_boˇx_cox: bool or NonǸe, ëoōpƁ^tionalʫ (d͔eʓfauślƶt˥=ƥNNƲ̖ÅoȺneό)\n  ʪȁ  Ifȗ Bɭoɸx-C΄ƅǥox tȫransfȿ͊ʎormaʰΥtiŮo̦nŌʚ aof original ĆƒseĩriesĴŽΆ\x8f shouƑϹͰld be ϘapǏpͫͿlǏρiedȱ.ŷ\nĒ ͎ ̛ ƽ WhenΉ NoǽnȂeȌö Žb~¡oth cases shall be ċcϨonsidereͱ˭ȳɰd Κ\u0381˄\x88andǭ be¼ttʬĠer Eis selected ˎɃ]by AťɰIC.\nbox_ɾc&Ϳoηx_bound˿s: tupʭƓʑle, s̍hϫape=(2,)Ƥ, o\x8dǨȾprtiΣonal (ɋdeΌfault=(p0, ȅĒ1))\n MĀ   M1ʬiŷnɸimalǍ and7 maȓõx̿͐imal Bčoƭx-Cox> Ωparameʵteǘr value˧s.\nus½Se_trʃeÚnd: booͻl or Nʾoɻ̏ne, optional (defǩault=None)ˊ\nː    I\u0379ndiɎcat\u038deǛsũ ͙ͦwh˻etΚ̸Ƀher to\' ʵi̡ncluʃd\x86e aǽ ΔtreɈƧnĺd` oGr no͔t.\n ϸή   Whenķ None both cΪaħsʒeƏs Εshalǜ̆l͆ be conΚ˸͟s˼idķereξd and better ɫis sǽelecɭte̩d ˯̉by AIC.\nuse_da͏mped_trenḑ: bool oƲLrǞƇëǆ Non˟e, ͋optĆioʅnal (deɧřf¡auΦlt=NoònǾñ\u0383e)\n ʫ   IndiÕcateϳs ƱwÜhethˋ¶̀Ήe\xa0r7 ͷto inìcl\xadudȞeɼ a da̖ŵmpiĝŞ̅\x81ng\x96 pȪ˒"Śaèr¿.Œ̖amʂͳet˴er in tɛʓheƮ tĤ̭rϛend oĿːr Ȍʋȱnίoϖt.\n   ̩ɼ AƞŔpǈĒΙƌplies˸Ѐ onlǳ͕y ɂķwhŉen ŽtʈʁrƇend MisñƊ uƍsed.\n  ˴  When Non\x9aɖe both cđaĕsĨe̝Ws s̯haίl̷l b²e cǫn}s\x8cidere`d aϡnd bettºϒeZrŵ ʊis ͥkselec˓tΧŝeƕd bƖy AIC.\nūī˨s=ʸeasonal˜_peͮrǃiodˠs: iteˣǁraŕbleκ*ųǚ Ơ͖orɑ a˗rray\x99O-Ťlƴikeə ɳΓof float¶s, optioðnalϐ (deʘ̖fau͓l̼t=ÊNone)\n   Ôg ǩLeng̻t¼hͨh ofϦͼ eachɌV Ɍof the pKeriods à|(amou§ƈȫnŤt of Şoͼbs̆ervażótio}ƘϤĽns in eac%βřh p\x89eriâļod).\n ϶ɚ   TBATS} accʾ̪e͇\x8cp̓t˨sϞȂ iɕnŁt ǱanC͒d f̖loat̸˰ Θv½aȄluΞesǠ hȅere.\n    Whe_nȶ None ļor empϮϣƶΘ˄tyȝ arrmay,ί njͷon-ǇsɺōǊeaśŢs¤o·5ï͓uΆna̓l¤ə ¬ʢlmodelȽ shaŷll ƚbeƜ fit͈ξted.\nu-seȈ_arma_Ǜ\x94errors:Ê b¨oǒoȜlϚ, ˦opϛtiÛònal ([ʓdefaulʔt=T̥̃rue)\nǿ    When ˵Truʴϖeȴ BAάϰTS willʥ tørɅyƍ to͋ improȯțveͲ ǚt\u03a2heǣ ©moϫdel by m|o\x8fdSelling rˋNeĢsidȡualsā wiϾth ARM\x9fAȎ.\n  ŝ Ϸ Best ɕƯmoödͤƔel ù̑áwȹÔʂillǪ bÁe \x91selϞeûcted \u0378ζbyƆ AIC.˶͝ŕ\n  ˾͒  ϟIf ǙFϥǪaƏαŌlse, \x88ŊκARMAɁ reÌsiduaɰlls mЀod˂eyliŞnÆgɼ ɸw¶i˟ll noΔt bƎϧe cons˹iŻd\u03a2erȍed.\nshʌǕʃoÌw_warniďn˘gˣsǄ:͆ bo#o˭lĵ,ȩ ΠǮoptional ɦţ(defNĸault=ŷTńrue)\n ˫Ē   łʷIĘƎof ̒warninĸgȦĂsƔ should kbeƴ sjĮhownˌ jorƯϰ noʿOt.\nv ʴˢ   Aόȿlsoĕ ōseɲe M7odeª\x88l.war˨;»nings vƗari͎ablǇe Ūthatǹ co̯nta͂ins3 ǯal˦l modâήǷeÒl nrʀRel̷ateŏľd wa̮rʬn$åin͍gs.\nn_˰̫joȑbŠsĐ:Ȅ intȔ, o\x85ptϭionaΥl (d\x8eeΥ͞fau˨lÐtǣȱǊ\x83͝=NonƲe)΄\n ǁÔi   ȓHĄoɆƴĢwƨ ma\x90nɥʑy (jobsȺ ½to rŧu-\u0380ĵƓɖ\x88ʏŞn řǥin p̾a͖φ%rallel\'͈ʟΐ wheϧɜn fittˊing B˿̇ATȘS mǢode̩l.ŵ\n  ˣ̊M  When nΈoǠʻƋtψȄʼ pȬ\x9a÷roviͶȅĄded BɢATǼSȻ ÏȚsəhallȉ tr̘ŽyǴ tyo ċutiliþĈʘfze˸\xad alϚl availaľůbΡ΄le c̓p˷uĚ co̻reás.ʿ\nmultižpr͕oΒceǯsͥsičɏœn¨g_stȁrϷt_metȄ¿hod: stŀĮͱr, optiŃonal (ϥφdemfƐĲaul̿ʪt=\'spawn\'ȷǴ)ĳ\n  ό  ɽHow thρr˞eadsȿː sho\x8fulΣd ϔbωe stÖ&ƣȩarȪtÿedˣ.\n ĳ   \x7fSţɞe\x91e https̠://doccs.͞p\x8fķʿykɕthȩƴʪon.oΛrg/®ɾ3z/lžiɐbr˵aÀ¸¥rďy/Ʋmult̹ìɘƶ~iprocessiʍngǯ.hWtʒml#contΕext{sl-aǜ_ndͤ-st͊arϓt-mǇȆΰ\x99eöȻtεēhods\ncont÷ex̀t:þ ϕġab͕stʊƩraƱct.Coè®ntextIntŞeʰrface˓ɭ˸Ͽ,̃ Ʋ¡ά+op˾Ǆt͝i\x81onaÄlÓ Α(˩ʍdeˤfΖΞ̻_Ƃa@ult=None)Ȝ͡\n   ξ FϺϥ́or aɀd³î\u038bvaʔnc\x8bȅȜίd use˧rϵs onl˥yǔ.ɭ PȨrϭoľvidÄe thΐisaĵ t˗̗oſΑ overǛride dćƛΰefaulǳtʾ̻ θϿbeʐhaƀvʙļiors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='TBATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='u', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_errors', ctx=Load())), keyword(arg='show_warnings', value=Name(id='s', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='context', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])