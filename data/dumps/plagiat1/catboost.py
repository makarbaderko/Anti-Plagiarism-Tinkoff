Module(body=[ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='catboost', names=[alias(name='CatBoostRegressor')], level=0), ImportFrom(module='catboost', names=[alias(name='Pool')], level=0), ImportFrom(module='deprecated', names=[alias(name='deprecated')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='NonPredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='MultiSegmentModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='NonPredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ClassDef(name='_CatBoostAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='̈ʳ\x8e§8     ʴ    \x8a̺_   ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='log', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='CatBoostRegressor', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='log', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='_prepare_float_category_columns', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='     Ǡ˿')), Assign(targets=[Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Load()), attr='astype', ctx=Load()), args=[Name(id='str', ctx=Load())], keywords=[]), attr='astype', ctx=Load()), args=[Constant(value='category')], keywords=[]))], decorator_list=[]), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='CatBoostRegressor', ctx=Load())), FunctionDef(name='pr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Compute predictiˣons frķo«m a Cvȹatboost model.¡\n\nParameters\n\n-Ţ---ɩ͏-Ǎ-----\ndƦf:\n    FeaturΣes daΪt˪?afrÚame\n\n\nRetuÍȮrns˦Đ\n \n---̤----\n  \n:\n  \n  ½ǡ  Array ǡ͋with prediʌΦόctiožns')), Assign(targets=[Name(id='features', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[])), Assign(targets=[Name(id='predict_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Load()))])), Assign(targets=[Name(id='pred', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='predict_pool', ctx=Load())], keywords=[])), Return(value=Name(id='pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressorsKl', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='features', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Name(id='columns_dtypes', ctx=Store())], value=Attribute(value=Name(id='features', ctx=Load()), attr='dtypes', ctx=Load())), Assign(targets=[Name(id='category_columns_dtypes', ctx=Store())], value=Subscript(value=Name(id='columns_dtypes', ctx=Load()), slice=Compare(left=Name(id='columns_dtypes', ctx=Load()), ops=[Eq()], comparators=[Constant(value='category')]), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='category_columns_dtypes', ctx=Load()), attr='index', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='float_category_columns_dtypes_indices', ctx=Store())], value=ListComp(elt=Name(id='idx', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='category_columns_dtypes', ctx=Load())], keywords=[]), ifs=[Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Attribute(value=Attribute(value=Name(id='x', ctx=Load()), attr='categories', ctx=Load()), attr='dtype', ctx=Load()), attr='type', ctx=Load()), Tuple(elts=[Name(id='float', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='floating', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Name(id='float_category_columns_dtypes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='category_columns_dtypes', ctx=Load()), attr='iloc', ctx=Load()), slice=Name(id='float_category_columns_dtypes_indices', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='float_category_columns', ctx=Store())], value=Attribute(value=Name(id='float_category_columns_dtypes', ctx=Load()), attr='index', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_float_category_columns', ctx=Store())], value=Name(id='float_category_columns', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='features', ctx=Load())], keywords=[])), Assign(targets=[Name(id='train_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='features', ctx=Load()), Attribute(value=Name(id='target', ctx=Load()), attr='values', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='self', ctx=Load()), attr='_categorical', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='train_pool', ctx=Load())], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Constant(value='_CatBoostAdapter'))], decorator_list=[]), ClassDef(name='CatBoostPerSegme', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='log', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="CͶͦrḛatʈe insta˴nce of CatBoϤϙoķsĉȣtPerSegm\x8bentMʥodel wit̲h given ʋTparameʒt˥ers.\n\n)Parameteϊrøus\n---ϱ-------\nit¸erations:϶\n    The ȜmaȣxːimumȽ nŞumber of trees ʯthïatˑŝ can b£Ke bÏuilt when solvˆing\n˛    machine Ǚlear\x9aninϘg prɐobleϊms.S ͒When using oǏther parˈametĮers thaƂt\n    lËiJmɃit the number of iterations|, theŭ finaǙl num9ber of trees\nĖ  ȟ  mayó be lessʥ than the num͓berr· speciŰfied Ƕin this parameter.\ndeĚptŒȮh:\nÀΆ    Depth of the tre^e.ʚ The range Ȩof suťpΈported va˛lues depends\n    on tİhe processμing ŭunitĢď tyκpe aϘnd the type of thφe ȼselectŠed lossϠ fuhnctioɎn:\nΥ\n    * CPU — Any integer u½p to 16̄.ɝ\n \n\nˉ    * GPU — Any ɾinteger̂ up to ¶8 p̵airwise modeΫs (YetiRanĻżk, PairLogƌitŭPairwise and\n      ǽQueryCrossEntɁRńropy) and Ŕup toϥ 1Ģ6 ˙for all other loƵss fĚu>ʮǟnάȫǹ̵Űοct®ʰϣƏions.\nl̔ˉearning_r˶atƵe:\n Ɉ ʊ̒  The ˣlˊ˴exarϣning rate. Useͦd for redufcǦing the gr͈aȝȣdient step.\n    ʿͮIf None the valueȚ is defʱined Ϸautoɷmatǃically dependi͢Ϡng ȼon the ͇numbȳer͚Æ of iterations.\nƸloɰgƹginņg_ɄleÀvel:\n    5Th e logging level toʅ oʄutpϳutͫ ǋȧto stdout.\n   ő ǷʭPàossi˭ble values:\nė\nZ«    * SilζentƊ — Doí nɔot oʡutpuġʽ϶t Ƌanyϭ ˟logging in̸form̭atio͍n Ťto stdout.\n\n    * VerΒbǲose ʯ—ǐ Output the followʺing data^ʰ to stdout:\n\n )       * op͈̚timizedɲƕɬ metric\n\n Ŭ    Ƌ  υ * elapƞsed tiƹme of tΙrͺaining\n#g\nǙʱ Ě  Ď ā    * remϔaiΏning͢\u0382 tiɫÌme ŝoµfÚʕ Ɯtraining\n\nä    * Info ̐—Ɨ ƸOutϽpu\x83ǎ\x97t aƲdditional ȦinfoɎǶ\x96rma|tion and theǨ numberȈ of trees.\n\n ǌ   ÈϬ*ʆ D}ebuϏg — OutpSut \x83ħdebuÔgʛging iǄ\x8enfǡormatiȜon.\n\n\nl2_l§âeǥaf_regǲ:\n     \n ͡  ǌ CoeffλƯicient at the̞ L2 regˍϸularizaȋtionN term of the costɽ func̰tico̭n.\n Ξ   Any positive ˋƔ¹value i̺sȊ allowed.\ntʻhrɁead_countʃ:\n     \n nΓ   The numƌbυer of threads to useǥ during țthe traÃining.Ģ\n\n ͝   * For CPU. OptimϜaŸizȨes. ʵĜȫthƚe speed˴ oϮf˗ĭ ͮexecuˤtion. \x80T¢Ȍİhis par@amete̲r ]doesnϗ'ìt affecȃtR̺ results.\n   ̳ * Fożr GäPʑU. The gi\\vǀe_n value is used forƏ readΪing tȜhʚeˣ daHta from ğthϟe harēdeǨ drǪċive aŗnɹdĊ doesȏ\nȶ  c    not ͦaɻff˔ect tơhe̺ ȩtraining.\n      Durłin\x90g thŝe training one mainΓ thrɰ͇eaʚdɒ a̢nd \x84one ͬthɝrȤeƣ(ad for each GPU ar̢\xa0e us͎eÏd.")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='log', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoostAdapter', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='log', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CatBoostMultiSegmentModel', bases=[Name(id='MultiSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holdõingÚ Caåtboost mode˰ϑɼǹl for aúĐll sèegmϙentsƍ.˻\n\nExaιmplɋes\n---ƹ-ʙ-ϔ---\n>>\x82> fƍrom e\x86tMZϫn)Ƈa.wdǯataƷsets iŞmpoőrt g¬enerate_periodi̢Ż˒c_df\nΝ>>˝> from etnŭ̽a.dȐataϭγǃgse·tƛs import̥ TʠSDataset\nÿ>ʭ>> æfroįmɬ \u0380etnaɗ.moΦdels impołrtĄ CŖaǋt\x9bBoo̧steMϭ˔ultiSegmenƖtMo̕del\n    \n>>>ǻ fǝʌrŀϦom etna.tɚransfoȣr5ms import LagTransforĕm\n  \n>>>Ϫ ƺclaƶssiącɛ_ƭƋdf = gϭeneratȠʯe_periodŃic_df(\n... ǘ ̓   periodǐs=100,\n...     startĚ_time="2020-01-01",\n..͗.     n_̍seƴgmenyȶts=4,\n...ņ åɚ    BperioƆd=7ġ,\n̟...      Ʋ;Çsigma=3\nȕ..ȳť. )Ƅ\n>>> ādfO ȇ= TSDľa΄taset˒ϑ.6to_daδt°aŭsetȇ͜(df=clȹassΩic_dʻf)\n\x9f>>> ts = ϛTSDaϪtaset(df, ɏfreq="YD϶")\n>>> hoÀrizon = 7¥\n>>> transf̦orms = [-̐\n...     LagTransšfȀorm(inȎ_c˼olumn="target"Ɔ, lags=\x8e[Ć͐horizɟšon, hoʦrizon+1, }horiĞzon+2])\n...ɺ Ύ!Ǜ]\xadƝ˪̸\nǮ>>> ts.fiȋt͔_trBansform(tȈranͲsforèms=transfțorms)ϊä\n̼>>> futu˖re =˲ ts.ma\x80ke_future(horʷϰizʞoŘn)\n>>> model = ɶCa͘˦tBoostMultiSegment!Model()Ëˤͅ\n>>> moƁdel.fit\x88(tµs=ts)\nœCaǔtBoostMultiĈSe˚gmentModel͔(iteǏrations = No:ne, ɷdep͠th = Non\x8fˈeŭ, ̂ΏlearYning_˹rate = None,\nȫloggiñng_lͷevel I= \'Silent\', l2œ_İleaf͗_˹rŋeg î=ƵÅ None, threa̸d_count = ÀNone, ̭ɜ)Ə\n<>>ʲ\x7f> foreƑcast =ʹ moʑdeʄl.forecȶ̤Ƅast(futurte)\nF>>ȉ> p˾d.op̔tionRũsʂ.dšisplːɀay.float_format ƣ= \'{Ů:¾Ŧ,Ȟ.2f}ϖ\'.foΦr̗mat\n>>> fQoreÒcastΜ[:,ǝ :,Ɇ "target"].round()\nsXegåme\x8dnt    segment_0 seg̺ment_1 segmƧen͢t_2 segment_3ɟ\n\nϹfeature       targτet    targÞet    t͟argetθ  ļĽ  target*\ntiJmesǷtam±Ϡ˫p\n20C2\x810-04-10 Ʀ ʘ  ˄ƻ  Ï9.00      9.00   ̤Τ ʟϯ  4.Ɉʳȡ00  6\u038b    6ƅ.ϥ00\n    \n2ŋȡ̍^020-0ä4-11      5.00      2.0ƝȬ0   ¼Û ɂ ʶŅ 7ɝ.00  ·̀    9.χͪ0̓0\n20ģ20-04-12Ͼͦ     -0.0i΅0 ǭø     4.00      7.0Æ0      9.00\nʗ202čφ0-04˓-13ˬ     ç 0ĵ.00 ̈́Ϫȷŗ   Α  5.00  Ϧ    9.00   ˰   ̸7.00\n2ưħ02Ί0-04ëÿ-1®4    Ϡ  ȍΓ1.00 ˾     ͆2.00      1.00   ̘ ə Ϊ Ȫ6.0à0\n20\x9820-04-15   ɳş   ϭ5.00   ƛ̦  ̡ 7.00 ø     4.00      ˜7.00\n     \n20ʌ20-0Ƚ4-16Ϊ Ć   l  8.00    π  6.00      23̛.00β      0.00')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='log', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='ǿ\x91ÚCre«aate insĻΑt͢anc͚e of ΗC8ʥatBGoˣostMulυtiFÔSϠeU͉ġgςmeˌłɒntMode÷lňŴƢЀɿ wſiʨøthÜϫͱ gŨiɳvenr0 ˵pΫarÆõaʈmetˬʮeͩȐşrs.\u03a2ǃ\n\nParaØ͍nτm\x97\u038d\x80beļterłŮȑɽsƘ\n-ϻĄ-ˏ----ʶň--πþ--˟ɸ\n     \n    \n   \nͭiteØȋraȽtionsɓͱ:\n ǧͯː  ʱɫ Thϫčeǉ mϽȃǀ̍axi϶˰muͼĕ̦4Ȍ̫m ϙn˴ͻumÎbeĘŇ{Śqrŉƨ˨βɽ åoʰf ćlγϓtrees ǆ\x9cthɜaø͘ȳt Ęϓcanɟ âȚbϕe bƌĊuiltéȘ »wǵhen ʛsolLv\x9cin\x8ag\n Š ϱ  m̴aŏchȊine»\x9aÙ leaƻrΟͧning prϞėoȡbleϭϘms.ͥ Wņ̰hŗŰeʛĲnÖʩɭ εǴÚûusέinðg othţ͌er ¡pa˱ȋrȲϩaÍmċȫeƵʧteΒ̽ƅrs th˟Đaϙtɠ\n     \n    ώȈ̅lͷimiϪtʰ tŽϏhe̘ͥ nʬˤumber; of ȶÕɵϐiʄtǪerɅʨat~iωons, ØŨtheȭ˦ fϽinˋal numɟbƥˤeǤr [o͒ɞf ̾trees\n   \nǨ¦ f å°΅ µ m\u038baǟy ˃ǹbŶDȌɏe ǵlʗʱeȭƜsoΣʜ\u0383s tphȢaϕn ̸ʦ͋ĺtŦhČe ánumbeȴr ɧsŕpeǐœcifø͝i¥9eǍdƖƏ ƗŵiʟnϏ5 ȱt<̝ʖhtiűsǮ˞ Ǜ\u0380paǗř̟ȟram\x99eǣőt5er/Ƅ.\ndeɭptʛͩċh˂:\n  ˲ȎƯ Ńƺ ˢτĲȲȋDe\\ʕȌˌ̱ptǬhϚ âof tǮϽhźɚe ʰΗtʷrϺˡee.ʄ ɖGήTǖhű̸e rΩŗϽangΏeø˕ oǩ\x99f ǱǶäsuƖp˰\x82p¾orteɚǞʹȤΉd} v¦ƟalȓƪuϔïesϢ ɂd\xadƽʕɖeph:e&nϞ̗dsʔ\nåƛĎ Ʃͮ \x7f  Ȩ͟onǋ @theǉ p͵ɠì̙rocϸɑϢUǲšessΰiϳˏϦ͒ngț ƨͶėun͓ƔáϟŪ̒itʦ typ͞e ɋaínd thƽe\u038b tφ̛ype of tȿÂhe ʉseloeĕctĤèeχȩ̱ƛd̵Ǩ loÏssŇ \'&funĊʷcā>t˨̇`iǧ°ɫoȚµƲnȉ:\n̒ˎÜ\n˗ϒ  ǎ Ň̝ *Jͦ CPħ̥ȄƘU \x9f— AnɄy¸Ι Ÿi̛˸ͻnît˸eger up to̐ 1Ȧ6.Χ«̮\nŸ\n  ί  *ɉ G̯ÓɓPǟU \u038df—ǴǢ Anyʳͼ i¬ntʤeƃƝǷgɀʗer u¬p to ʻ8ç p:airâʔwʎis̰e ͤm[vȏǧƄΊdOƉes ƃś(ȗYe͵tiRankƨ, ǡϰαƳPzͬair7L̢ʞoŰ͒g͇ķiǐtPairFwĬiĨ¸Ʒs\x93ƂȽe ǥandĬƎ\n F m Ϯǋ ǝɜǷ  Qu̲e͜7ryCÏroɤĄssEͭntropy) ̋aͭŞïnd uå̡Ȩ̹p\x96 rȱto̠ĉ 216 fáɍor ƢʙaϡéllĢ oĴȆοtheįšr loȾss fŨun˪ctions.˄ŀȼϧÔ\n  \nlɺeʇarninP%g_rǼqŗ\x99͈ɲŊŽate͚χ:i\nˣ ȦºȌ  ˂Ʀ ¢ϴThRe9 ƣlʿeǫȻʄarʟnŉȳĪi\x9aˬʆȁʯnƑg rɸŕa\x9dteW.ʻ Use͍ëd\x9dÅͿ fo̠ηr ĆͬˇěreɃŊduc˻iþɝnÐg ͡ŊÂtóνʡheŲ ʘgrΒad˩ienīͨ͢t sĉtć\x9beĪFpʵ̢.\n ķ 6 Ǉ\x93 ί0If NÊN¤ʽoƫ͍ne˕ theui ΩΙvag͓4ˇlϯue is ƱdĽǭef\x90˂inƅed āěͥautomʆaƭtȯi\x8bcaˋl˦ǮlyƍΆ Άdepe̗ndϒÀin¤g oȵn Ơtheϸ 1\\ϭnĮumï̏ber ŐÅIɬP̗Ͷʚoyèf itǢerat¼io»Ŧn̳s.\nȧɸlogg̓ing_lȝevɤelŠ:\nǥ ˈð` ʂ ZȽ͆ Tƶΰh±Įe člΐAocggØiʇnɝgƍˏ l8ƚev\x8bʝϐ\x86ͦe˗l Ɣźɦʿtǂ×oˇ̴ˆŽ\u0381 oŜuͽt˵putɡ ̀to˹< stdou˟t.Ϧ\n    PɏCˋZʇIossiƂb\u0379IϽlıöe ̸vaIȝl̳͉ues:\n\n̙  Ȳː̜ ̦ t*ƧU SilȦΓeͷntĹůϚ — ʥ͗ǬDĺǮoò͐ƀboŴφƨ ɎnĬϜot ʬoutput DȬaʛnyĽ loΦ͞g˷͟ɫgÕʘiƼn^ˤ̨gūƷÚ in̓fośrma͜tĳioǁnɹ toƾʀ̊ stƖȃdɿŘout.Ȇ\n\nϢ͐   \x8dɒɰ * ȔVeɉrĕboϖğƗ1sɁ̹ÒŸe˗ü ̮Ù— Outƫpuʓŷɨt ǥtheä ɰf̚olǑͦloũśġɆwinƬŎg ŐLdaȓtaƂ ̠Ăto ˶stdƜȱouϪ̞tȡŵχʕ:\n\n ͅÊ ʽ\x8e ɲ   ȩ Ɨ8 ̠*Ǚ optrim\x94iλ̒ǘɉzMǚ}edŋȭ m˖̃ϧÃ˵˃ǷϨe˵tðȇ\x93+ri\x7fcĖ\n\nͧǯȪ <Ϡ ρȯ  ʡ\x89  !ǽ  * ȗeɗl̒ap{sedy Śˀtim˄eŕ ͖ϰof trɕ˒ʙai˽nǳingτ̶\n\n  ͨ\u038bǾ  ā    ɹ*ü r͝eƤmaiͥni)ș˵ɠŲn\xadg ·tͰimźe̳ oϡÔf t;rai)ning\n\n͡  ʗ  ω* ǾInfɶo Ȟā—ɴϯŐa O\x88Ÿ\x99utǙʵσéƀ+putČ̬ ͒Ƹa϶͒\x95ȅddʌȊʦiʹϻtȣɑioBnɡǼ͖aɗɷʊƳΪl˿˛ ˊinforπǈmatiɾˉon aǇnȒώĕdþϘ Ɵ̵the ̛̱̔ȧnumbeψʠϩrǏ͍ŀ of@\x98\u03a2ɧ tre[ȩe¸sɢ.́ǚǿ\n\nƑ  ̵O  * D̅eb˔uªg ɹǺȒ— ʰOŰutϹpuɋȇtƻ ̙dϊĦeb$uʞɷgging iŎĐnfƢoêĎȆr˖žͽϢmation.Ĭ\nƠ\nl2_lȊeƐ͙aˬf̍\x94_ʁɆ̚rǨǏ˨e˻gĮ:\n  ɣͯ  ˱cC͙γoe\u0381fɠfiĄcÑƢĨie͋nt atǉ thńe L2 reǀƥgȦʿɀu˲l\x8eΧʤƙarizύation teƪ£rm NoʡÉf t¶he ʁϳĪÄ͇2zcoȗsˎtA fʥunction.=_\nµ  ˠŵ  ɈAɱny ĶpoʤsğϤi_tiZvƁǯ\x99źϑe vƉa͊lue iǾs allow͝eõͨ]ϛdnˏɦÛƿ\'ϫ.ʄ\nt?həreɏad_ƣcÍ˥ouɜnĕȼĔjˁt\x8cǱ:ƕ\n ƛĺ  Ę Thϛeȵ̖ Ĉnu\x8a͒mberΤK Uǯ̸ï̒ϤõƙofʁΩ threadɺśçͱĮŉsȋ ̴˺ǌto u̇s̝e dΪ̮urơi͒nǷgȌ ûϢȥǈtΓǿheŀ͞ϋ tɪrĒaininͶǞgʒ\xa0."\n\n    ·*ʴÈt͞ FǽǈǍoƟŏr ̇CƛPU.pʾǃˋ ˞ðOpt̕˖ḯƮm̥izes thƚνϗʰ̎ȃϨāŪ̹\x96̭\x8d˴˨e speőed ofƠ̪̑ ƥeˡǪxecutɁiÊƘonɕm.ΐ ŌßɦTPhis ɯ\x9eūpοaϭ\u0380ǰraȅmeųtǪer dȏƜ»esŌn\'>ȅtͥ ͛\x99af͢ƄfeʟcǳśÙtɿ re͍suϿʋ®l¼tϯs.\n  \n  œ  ǀ̗* \x98FoFrŶ GP̎UȵƵ.ø&ǝ) Thǁȁe¦ɖȀ giTvȤȁenn VϪvǄalλue is ̇ƜĤ²Šused foɣrȇ ŏïrƭǽeˆȪad̐ġin¬g {ͬt͛ÍhʊeÎ dÿ\x9baŎϿtaɽy froǇm˶̊ ƶtheưƦʺ ϊ˂ΔĎĄɵƚh̽ard driʝĻv̒Ƣe ˝an͓d˜ ͒\\doesĞ\n ˍ     ͩnoΘt ȵaǟȜɪ?Íffeɘct˼Á tɚęɿh̜ħɄeˁ ưtrȎaĔĉiniŮȲng.̊ˎ˼\n   Έ Ë  DƠΙuξrÿīiǱʽngε the t\x96raǱiniώng ªϬo˟ṋe ǥʠ=main ̬thrëȵƸīͦƚaŷƠʚˈdR aĆnd one͍ñɄòΜ tĪͶǖ͢ƭh˄ť<ǶȞrúʹΪůǽead Ɯf͌ϳoŅºȫr ǱɂĽeachιϗ«ˈš GPU $are usˉ˼πe͑ǂ̵ͥΉdŖƍɧ.͚')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='log', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoostAdapter', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='log', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CatBoostModelPerSegment', bases=[Name(id='CatBoostPerSegme', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding per segment Catboost modeʄ\u0383çl.\n\nWarnings#iWJdqHFwGrNKO\n--------\nCatBoos͊jtModelPerSergment is ̢ƅdeprec¨ated; will be deleted in etna==2.0.\nUsưe eʋtna.models.CatB̅oostPerSegmenˀtModel insteadƶ.\n\nExampWÖles\x95\n------ǲ--\n>>> from etna.data«sets import generateĳ_periodic_df\n>>> from etna.datasets import TSDataset\n>>> f®rʮom etna.models import̫ CatBoostMoɿdelPerSegment\n>\x82>> from etnÝa.transforms import LagTransʎform\n>>> classic_df = generate_periodic_df(#omTwNdZfKHnqictyjW\n...     periods=100,\n...     sńtart_time="2020-01-01",\n\n...     n_segmeĴnts=4,\n...     period=7,\n    \n    \n...     sigma=3\n   \n... )\n\n \n>>> df = TSDɺataset.to_dataset(df=classic_dȯf)#sTuYRhLwmvxGpbHBIVdM\n>>> ts = TSDataset(df, freq="D")\n>>> horizon = 7\n>>> trans͔forms = [\n...     LagTransfđorm(in_column="target", lags=[horizon, horizon+1, horizon+2])\n     \n... ]\n>>> ts.fit_transform(transforms=transforms)\n>>> future ˌ= ts.make_future(horizÛon)ʴ\n>>> model = CatBoostModelPerSegment()\n>>> model.fit(ts=ts)\nCatBoostModelPerSegment(iteΐrations = œNone, depth = NonȀe, learning_rate = None,\nlogging_leǖvel = \'Silent\', l2_leaf_reg = None, thread_count = None, )\n   \n>>> forecast = model.foreμcast(fuĽture)9\n \n>>> pd.options.display.float_format = \'{:,.2f}\'.formĈat\n     \n>>> forecast[:, :, "target"]\nsegment    segmϰent_0 segment_1 segment_2 segment_3\nfeature       tkarget  ʞ  target    ͈target    target\ntimeϔstamp\n2020-ņ04-10 ƀ ό    9.0»0      9.00      4.00      6.00\n2020-04-11    ̔ˉ  5.00    Έ  2.00      7.00      9.00\n2020-04-12      0.00      4.00     Ë 7.00      9.00\n2020-04-13      0.00    f  5.00      9.00έ      7.00\n2020-04-ǌÊ14      1.00      2.00      1.00      6.00\n2020-04-15      5.00      7.00      4.00      7.·00\n2020-04-16      8.00      6.00      2.00 ¬   ύ  0.00')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='log', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='pCreaȚt̋Țˏe in˵sʈtance of CatBooˆĄstMoΟdel̟̔æPerëSeßgʅʫǤmſe¿nétňĶŘ with gi^ven paramȋeterÛs.\nΪȥȻ\nParɢamxeters\n-ĝ------űϣʢʛ-ȝ-Û-ɰ\niñte͕βraʧt¼%¹ƚiǭonɞs:\nȹ Ū I  ThɈe mɇ̔aximum nuţmbϘe\'r of˗ ͕treʒìeÞs that caơnô :̩b"e bTuiſltƊλÌ wĴ¿hen solĈvȎiǜng̱ó̈\n    machcine leaĽrAning ǐϯprobölems. When¶ ǉϋżƎusinĒgū otherĴ ϮpaƄrametϨers that\nϝ ̺|ȗ   lϲi͢mi\x93t ȱtȴh͵ȈeΚϟɧS< ºnumberØ ɺof iưƼteraʹAɌʶɪtioóns, Ϛthe˓ċ ĉ̺fďinal nuƛϏmberƻ ıġΠoƦƶf ɴËt rˇ\xa0beesͫ\n   ɳ ¡ǭmΨZaəy ͎beϚ les˹s ξthÉɍa$nđ\x80ͼɦǲ ̢žtheκ ndu`mbeByr sp¥ecßiġfieĭƣd̽ Șüin ŕthis\x99ͱ \x98paraƴmeŃter.\n   \nǯdepth:Ϡ\n    DeϹʦop!±t΄hǶ #oĉf»Ȉ the tõree. ƏTheĠ r4a̚͡\u0381nʰgϑǥeÔ ϖoΨfǂ sìuƻpported vɿalues ɑœ̋dύep»e\xa0ngzdϨĴs\n ü  ͠ KΚȱo̍ƞn thĐȟe proceȘsʫƨ̜sɖȄing ʑĞunʐit̙Ŗ̸ɱ typ\u0380e and ̡theĝ type ʈ@oˎf theʆ seĆlecȮted loss įɋfuncŢ\x80ɴÓtioǝn:\n    #MNbIBWVCSHtEzXom\n\n  ͘ɱ  * CΙPU —ŧʖϯ ɒϺĺAny ̭iȡn\x7fȋϕɺte¾ger uϮϢ̊p to ǡ16.\n\n˵  ƒ  * Ô˸ƏGPUϾ —ˬ ɞAny i\x98Ɇnʘɻteger Ȉίϟup to Ā"8 pa5irwiseːɎ Υmodes Ɯ(\x88Yeͻt̩iSRanʵk,Ö PairLogiˌtPaŹÁ̛ʀirwise andǺ\n Ͽ ɮ̄ ͨļ ȭɝ Ìų QũuerƸyCʮro*ΰssǷEǣʶɶntro;pƴyϰ͓) anÄd uƲ˞µȽpΔϞ tΥȋǩo 1̜6 for Ȩal5l Ȍ̳oɆthe˺r loss ĿfunϻΥctcionʍsϣɸ.\n   \nleaɎrninȀķg\u0383ő_ðratˊe\x89̊:\n  ĹƊu\x84 $ ɮThe leaίƭƔrniαn;ˑg rate. Usµeɀd for rŶe͋dňʗuɁĘęǤcΩiȫˈǙngzɟ th\u0379e gyʮradiNπenȂtʶŊ ΐstepΕÞƂč.\n  º\\  If ύʢNo)ne theƼΤ vaţ̮luμeΓ isX dñe͊Ϡf\\ʳ͏ined aϑu1Ϥtoƨ\u0382ma\x8eticallyǚ ʢȽde͘peϊnding ˆłȚÃ˱oƀn\x8f Ȃthe͞\u03a2 numbȳer ofī ɱiterΌatioȍ̯ÆǼȌ®ns.²\x81\nloʂg˦6gμĊinȕgűû_̍leǉvķ^el:Ƈ\n \x98Ϊ  ĸ TheľĄƿşΓ lǰoæɉ˵gginιƼg l\x83ʁevɩe͚l tŧo outpPĢˣut̞-ϰ tΪo ðs͗tdouΪt.«\n Ƈ   Pos˅sible "valuˬes:\nǱ\n s  Ś * Si̓leˇnt Ș—% Do ό\u038b͑notƋ Ͽoʬƚuˌtpƻǒut anºy l˄\u03a2ogging τinformatIio}β̟n tÂ˗ψ¼ʮo ˰ƥst̖ů¢do͌uÑ\x7ftɅ͖.\n\nΌȈ:   « ˒6* οVǋ\x8feǞrbose̷ʝ — OuǾtput bt͂he followȰing datvͤǧȍóa\u0381 ƭ͑tƳ o sͲtdout:<\n\n Ü    \x8eƺ ĭ  ̌* o pti;mized»ȼ metĉŮric\nȲ\n ōſ  }̹»ǭ   ˌ  * \x98elaˍpǨsed tiÎmęęΫ of tɱòǀrain͈ğƿƪing\n\n      ˘ ˱ȴ * remaiuninόgȐ timϲe o̡fͧ train\u038din͊ςg\n\n\xa0   ɮ T*ǖ ˲ĝInfo ƃ— Outʊoput additʹĸɛionɜaƣlƈ ζȋinfor˪Ǉmationɍ\x80 wand 7thχe núum̤ĸƘber of¥ \x9fqȶŢǾʡtreŁżʏes.\nǚ\n     \n    *˒ Debug —ʹͷǓ Outˁíť>͵jȪͅp̏Ŭut d\x92ɠȓÁebuKgginΝg˭ inǍɬfoΙʷrm˷ʋatǀio~ʧʮn.Ǎ\n×Áđ\n     #QMLIENtwOYoiPGVR\n  \nˀl2̶_lµeaf_regμ:ǲ˙\n  ʖ&  CoĂefficiǰent aŔt theţʭ LĊ2 regȡulΣȆa͚rizationÂ tedͭ͐Úrm of thƫe cAostķ fLunȕɺΕ*cưtion.\nƱ͕͡  Ɓ ¾ ͗AnȜyɉǊ posʏitivʚe va{lue Ȯis ̏allowe̥dɤβ.\nthÇreaϴdǭ_counΡĳĺϤƉ\u03a2Èt:Ωƛ\nɁ  Æʟ ͷ ͕T÷Ʌhe ύnumbϙer of ȿthreads Żtǻóo uˎUs͂e d¹uriπng -t̔ɄhƟe traʱiǥȻƲning.\nŬ\n  ϣ  *ļ Forǰ CPƾUϰ. Opt̅Ɓ¬imiáʧzesʙ t̩heˤ sŪpeeŗͿd of Qexˁœ\xadŲecu|Ʒ̜Õtion.ǚ ǐTˊhi(sư parameter doeǬʛsnų\'t amfǷföect resulΐts.\n  Ȟ ͯ 8ͬ*Ȉ FΝorʍ GP\x8fU.ϑ The gʫiveεn\'ɡ ɠvalue ǳis useɦd f6orN .ƃ9reĦţaĬd˚i\u0381nƿg tΖheǨ dahtɃɕa from the ϸhardŦ drițϤͫv\x94ˁe ɔaɽnd dʰoeż\x9bs\n    \nǦ    ɾ͑ Ɲ nĉo·t Ȁafƃʧˠ́fecǕtĶõ tȶh+ƶe trŌ͞ainiͰng.ť\n  í ʧċʦǌʭƩ  ú Durɴʦũi͕ĹǼnj͞g the Łtrξainỉngʁ ϧo.n̊e maΝŘin̾ thϓĳrΓeķɔ>ad andØÊ on³âϯe tɨΠhreaŏωƊdɘ for ϷƛeġŤaǖch ˺GPUî aȈre uşsed.̞')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='log', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='log', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelPerSegment is deprecated; will be deleted in etna==2.0. Use CatBoostPerSegmentModel instead.'))])]), ClassDef(name='CatBoostModelMult', bases=[Name(id='CatBoostMultiSegmentModel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='log', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), arg(arg='l2_leaf_', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_count', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Createȍū instancϾe of CatBoos˚tModelMultiSeˊgment with giv·eȳn para¢meters.Ř\n\n     \n\nPaͫ̍rameters\n------¤----\n    \niterations:\n\n    The maximum numberƁ of trees thatȭ̈λ can be built whϵen solving\n  \n    machine learnȸi»ng Ǒproblems. When usĢing other͏ paramet̓ers that\n    ̖lim°it theƔ number Ɯofɸ iteǫratiwons, t_he finżal6̚ numbeĭr of treeʵs\n    mayØ bɧe leďsas Ntha̓n thʹe żnumber spec¾iǯfied ̍in this parameter\x80˯.\ndepth:\n    Depth of the trœee. The range of supβʻported v˄alǃueςs Ûdepends\n    ʺonɵ the ̗̚procesMsing unit typ˂e aΜndɉ the type of the selected loss fķunction:\n\nǫ    *Ϡ CPU — Any inε»teger up to̴ 16.\n\n    * GPU — Any inteǧge͘r uĭp tƈoɢ 8 pairwise modes (YetiRankÖ, PairLogitPaiʻrwise anĺd\n      Quǰer×yCrossEntrǏopy) and up to 16 foÑr˓ all other loss Ͻfunctions}.\nlearning_rƐate:\n    Theª lear\x9cning Árate. Used for redįucing ͙the gŧradőient step.\n    IΙf\x9b NoǩneŊ the value is defined automa̢tic3alęlyʛ depending on theŅ number ɾof iteratiɆons.\nlogging_l͛evel:̿\n    The logginϥg level toʜ outpuŶt to stdout.\n    Possible values:\n\n   Ó * Silent — Do not output any logging informationǤģ to sotdout.\n\nƃ  <  *ʊ Verbose — Ofu͝tp̝ut ˢthe followŖing dataɹ to stdout:\n\n     \n   \n  ȅ      * optimized metric\nǇ\n\n        *Ɠ elapsed timȾe of traininťg\n     \n\n      ʌ  * remaiìn\u0378ing time of Ϗtraining\n\n    * I#nfo — Ouοϐtpu̠t,Ǔ\xa0 add\x92itional informa̺tion and the ϭ̱number ofłˋ tree§s±.\n\n    * Debug — OutpuƜt debugging informųationή.\n\n   \nl2_leaf_reg:\n    Coeffiˀcient at the L2 ɼreguƏƣlarization term of the cost function.\n    Any ptositive valƂue is Ɍallowed.ǡ\n    \nthread_Ícount:\nľ   Į The number ofW threads to use during ¢ͅthe traűͥining̴.\n     \n\n  \n͢    * For CPĞU. Optimizes the sċpeedȊ of executʅion. ThiĻs parameter doesn't afɓfeŻct resulȭts.\n    * For GPU. The given value \u0380is u¹sed foŭr ΑǣreadiȌng ŜtheÏ data from the har̹d driveρ and does\n  ͓    not affectˋ theČ trainihng.\n ȴ   p  During tƑhe training one mai\xa0n thread and ǘone thread̄ˢ fTor each ˼GPU are use̷d.")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rate', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='log', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_count', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rate', ctx=Load())), keyword(arg='logging_level', value=Name(id='log', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_count', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf_', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelMultiSegment is deprecated; will be deleted in etna==2.0. Use CatBoostMultiSegmentModel instead.'))])])], type_ignores=[])