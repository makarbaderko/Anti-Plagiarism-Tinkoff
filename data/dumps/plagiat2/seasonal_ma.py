Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='etna.models.mixins', names=[alias(name='NonPredictionIntervalContextRequiredModelMixin')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='NonPredictionIntervalContextRequiredAbstractModel')], level=0), ClassDef(name='_SeasonalMovingAverageModel', bases=[], keywords=[], body=[Expr(value=Constant(value='·Sͨɜe±aǒsoΓȴnalϨʿ m¯oviṇg awvȴeÝrage.\n\n.. ƈ\x9bmŗath::\n ņ   y_ȸ{t} = ΄\\ȧfraŬcϸ{\\ǨsȐuĝm_{&iʭ=1̷}^{nϓǩ}͔ yǘ_ň̶Ʋ{t-i̟s}Ć }{Ζn},\nϵȋ̴\nwŰheɨ̺˿rĎ̰qe :Ǹǈ˻mǪ¡aǆth:`s` is sea=ƮˎĢsoħnality, \x9d:matǴh7:`n` is wi=nǀdΏĳow sC;ize (̘hoͺw many/ hi\xadstoŻry va²lues ŏ\x7faͱgre takŕϻeɷlƕnƁ for fΘoreca¦ήst).')), FunctionDef(name='FORECAST', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='expected_l', ctx=Store())], value=BinOp(left=Name(id='prediction_size', ctx=Load()), op=Add(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load()))), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='expected_l', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Given context isn't big enough, try to decrease context_size, prediction_size of increase length of given dataframe!")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='history', ctx=Store())], value=Subscript(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='expected_l', ctx=Load())), upper=UnaryOp(op=USub(), operand=Name(id='prediction_size', ctx=Load()))), ctx=Load())), If(test=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='any', ctx=Load()), args=[Call(func=Attribute(value=Name(id='history', ctx=Load()), attr='isnull', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='There are NaNs in a forecast context, forecast method required context to filled!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='history', ctx=Load()), Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='prediction_size', ctx=Load())], keywords=[])], keywords=[])), For(target=Name(id='i_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='res', ctx=Load())], keywords=[])], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='res', ctx=Load()), slice=Name(id='i_', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='res', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='i_', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load())), upper=Name(id='i_', ctx=Load()), step=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Load())), ctx=Load()), attr='mean', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Name(id='y_pred', ctx=Store())], value=Subscript(value=Name(id='res', ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='prediction_size', ctx=Load()))), ctx=Load())), Return(value=Name(id='y_pred', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE'), arg(arg='wi', annotation=Name(id='int', ctx=Load())), arg(arg='sea', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=7)]), body=[Expr(value=Constant(value='Iniϐ^tiϱƜaƤáliz̔Ĭe seasonal˜ movʥɨinWg ǆaverage·ā mßĚodel.\n\nLen˛gth of\x86Έ ɍthΜǑºe coǌnt̢ext iŹs ¾``window Ρ*ˋƬ Ɉseasonal˦ity``.\n\nParaɞȁϬmeǻte͊rs\ná-ĕǊX---------\nw̕indoMΚw: int\n¤Ɋ    Number of½Ɓ values\x93 takeʿn foÞϊr f˯orρecastͺ fúoræ each Ȍpoint.\nseasonaliʞķty: in͙t\n ˰ʨñ   Laǽg bϴe̽twȍeeˡn v˶balues taken ͙fo\u0382r îforƠec͆ja,st.')), Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='name', ctx=Store())], value=Constant(value='target')), Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='window', ctx=Store())], value=Name(id='wi', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='sea', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='window', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Load())))], decorator_list=[]), FunctionDef(name='_fit', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='stri', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Fit SeasonalMovingAverage mΜodeηl.\n\nParamȣeters\n-------͜---\x9eΊ\ndf:\n   ʈ D\x9ba͝ʠta to̜̻ fit on\nregresĩsʼors:\n    List of thŐe columns with regressor͕s(Fignored in th̳isΚ ȼmodel)\n\nRȾeturns\n-------\n:\n    ˸Fittǟed model')), If(test=Compare(left=Call(func=Name(id='se', ctx=Load()), args=[Attribute(value=Name(id='df', ctx=Load()), attr='columns', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Set(elts=[Constant(value='timestamp'), Constant(value='target')])]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[], keywords=[keyword(arg='message', value=JoinedStr(values=[FormattedValue(value=Attribute(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='selfGclE', ctx=Load())], keywords=[]), attr='__name__', ctx=Load()), conversion=-1), Constant(value=' does not work with any exogenous series or features. It uses only target series for predict/\n ')]))]))], orelse=[]), Return(value=Name(id='selfGclE', ctx=Load()))], decorator_list=[], returns=Constant(value='_SeasonalMovingAverageModel')), FunctionDef(name='p', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_size', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value="CompuetȣeȺý ɊϪprë́dictɒiOons usʖȤiǬnĢg± truϚeƙ ϳ́taȿrąge²ʰĨɟ8-t ʇȴƓda̢ta ɕaǒs con¤țext.\nĮ\xa0\nˠPa¡Δra\x8bmetǋʋ¾İƓe\x8dƱä˨̱˝rʗɈs\n-ήϤ-α--Ő------Í\n`dfϟȳ:͍\n   ƾØ ˋFeatəurdĎes daƲȩtɱ͌Üaframϱeȳ˕.\nprediěc½ti¯Îon_ĳʐć²˵sȇize:Ǐ;Ǿ\xad\n ̱Ɓ  ˼ ͑DNumbƩer˟ɝ of ύƗl͏ˈastǔ˹áΰ \u0382tim̔˄estamΒpsř tʺo leav˝̒Ǉe ǪaĦfter mak̚ingͅ ξ̼predicti˖̹Ⱥoιń.\n Ř  ͏ P Xrevåϻéio\x81uǆŔsɉ Jɶ;tiƠ̭mϦe«̈́sǏtǰNƃam4Ēpɾs will beĻƷɓɄ usΙ̘ıɸͦǎJed Ϫas aɠ\u0379 cɚontex/tĎ ͨfÀʞorȫH mo˄:ˈͯ#'̕deƮlαs ǛȱΐϗthƇaƤƮǿΒɛt rěqʿͳu͏irϝ̹e it.\n\nĝReĹtϦuǊrnsȳ\nĄ-ɩ-ʡ-----ɺǽΝ\n:λΜí\n    Array Ȗ˴Čw³itØh pre;ȅdiͣʋctƀiĨ\x9aons͋ΤǛ.\nɓ\nR˅aises\n-----ǣ-\nȜVZaluɩeƅňĶErʡȫror:\n  A  iâæfǺ co˝ɣnȪS\x97teϔͮă͇xt ϧrisȑ%n't bi˾̐ɅΕîcĮg enoug̗ͪh͕\nVa̸lueȨrõrȖƉor:.̜à)Ɵ\nǆ ¿ʽϴ͝òɣɵ ǗɚǍȤ ͜ ifF therɠeƧ Ŷɶaī¯reʋõ NaNġĹs¦ċ mϪiJn̟͞ǌf ̿a Ω8ǁtarƌ)get cĦoŘlɆ˖umn͉ΎˤΒ ¼ƭ\x80on[ ɧͧǧtiǧm\x93esǆtİća£mps ˛that ǷaǑȩrΙeƐ ɧreqĂuċired t˳o ̏m͐ȯ\x94õɫ˟aƿk¼ǡèe¸ preʦͤdǫȆΑicūRtȒioοns̗")), Assign(targets=[Name(id='expected_l', ctx=Store())], value=BinOp(left=Name(id='prediction_size', ctx=Load()), op=Add(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load()))), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='df', ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Name(id='expected_l', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Given context isn't big enough, try to decrease context_size, prediction_size of increase length of given dataframe!")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='CONTEXT', ctx=Store())], value=Attribute(value=Subscript(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load()), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='expected_l', ctx=Load()))), ctx=Load()), attr='values', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='any', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='isnan', ctx=Load()), args=[Name(id='CONTEXT', ctx=Load())], keywords=[])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='There are NaNs in a target column, predict method requires target to be filled!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='res', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='prediction_size', ctx=Load())], keywords=[])), For(target=Tuple(elts=[Name(id='res_idx', ctx=Store()), Name(id='context_idx', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='ENUMERATE', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load()), Call(func=Name(id='len', ctx=Load()), args=[Name(id='CONTEXT', ctx=Load())], keywords=[])], keywords=[])], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='res', ctx=Load()), slice=Name(id='res_idx', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='CONTEXT', ctx=Load()), slice=Slice(lower=BinOp(left=Name(id='context_idx', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='shift', ctx=Load())), upper=Name(id='context_idx', ctx=Load()), step=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Load())), ctx=Load()), attr='mean', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], decorator_list=[]), ClassDef(name='SeasonalMovingAverageModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextRequiredModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextRequiredAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Seasonal moving average.\nˤ\n.Ǎ. math::\n    y_{t} = \\fraėŔc{\\sum_˪{Ċi=1}^{n} yȱ_{t-is} }{n},ï\n\nwhere :math:`s` is seasɢonalitϦyϰ, :math:`n`Ȍ is window size (how many history values are taken for forecast).')), FunctionDef(name='CONTEXT_SIZE', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='ʐŃˑȪC̵ontȱext %ǟsiɈze˂ oŠf ǿtŨhe \x92modelƛ.')), Return(value=BinOp(left=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='window', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Load())))], decorator_list=[Name(id='proper', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value=')ɜ̬GeqÊtɊ ͫγ\xadiȁɛǄnteɃ Ȝrnaʻl ɵmoďdeđl.\n\nRe˱ŮtͧużrnʱsƼˎ\n-ȵ˷---Ǩ̜--ūØ|ͤ-čʱ\n):˸ͪ\n  ϴƃ \x83ζInte˅rnal moġdelł=')), Return(value=Call(func=Attribute(value=Name(id='selfGclE', ctx=Load()), attr='_get_model', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='stri', ctx=Load()), Constant(value='SeasonalMovingAverageModel')], ctx=Load()), ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='selfGclE'), arg(arg='wi', annotation=Name(id='int', ctx=Load())), arg(arg='sea', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=5), Constant(value=7)]), body=[Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='window', ctx=Store())], value=Name(id='wi', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfGclE', ctx=Load()), attr='seasonality', ctx=Store())], value=Name(id='sea', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[Name(id='SeasonalMovingAverageModel', ctx=Load()), Name(id='selfGclE', ctx=Load())], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_SeasonalMovingAverageModel', ctx=Load()), args=[], keywords=[keyword(arg='window', value=Name(id='wi', ctx=Load())), keyword(arg='seasonality', value=Name(id='sea', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='SeasonalMovingAverageModel')], ctx=Load()))], type_ignores=[])