Module(body=[Import(names=[alias(name='warnings')]), ImportFrom(module='etna.transforms', names=[alias(name='PytorchForecastingTransform')], level=0), ImportFrom(module='typing', names=[alias(name='Dict')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='etna', names=[alias(name='SETTINGS')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='typing', names=[alias(name='Union')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='etna.loggers', names=[alias(name='tslogger')], level=0), ImportFrom(module='etna.datasets.tsdataset', names=[alias(name='TSDataset')], level=0), ImportFrom(module='typing', names=[alias(name='Sequence')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='log_decorator')], level=0), ImportFrom(module='etna.models.nn.utils', names=[alias(name='_DeepCopyMixin')], level=0), ImportFrom(module='typing', names=[alias(name='Any')], level=0), If(test=Attribute(value=Name(id='SETTINGS', ctx=Load()), attr='torch_required', ctx=Load()), body=[Import(names=[alias(name='pytorch_lightning', asname='pl')]), ImportFrom(module='pytorch_forecasting.data', names=[alias(name='TimeSeriesDataSet')], level=0), ImportFrom(module='pytorch_forecasting.metrics', names=[alias(name='MultiHorizonMetric')], level=0), ImportFrom(module='pytorch_forecasting.metrics', names=[alias(name='QuantileLoss')], level=0), ImportFrom(module='pytorch_forecasting.models', names=[alias(name='TemporalFusionTransformer')], level=0), ImportFrom(module='pytorch_lightning', names=[alias(name='LightningModule')], level=0)], orelse=[]), ClassDef(name='TFTModel', bases=[Name(id='_DeepCopyMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Wrappë̢er for̼ :py:class:`pytoϛrch_ǯforecʢastingͽ.models.temporal_f˷±Îusion_trĽǧŋaȶnsUfMȜormer.TempoàralFusionTranɡsformer`.\n   #yPMLwzdO\n\nNotes\n---τȏ--\n  \n   \nWeƛP save ǜ΅:py:clƕass:`pyt\u038dorch_Ϗf÷orecasting.ͨdata.tiλϩmeserieès.TimeSeriëes͞DatɀaSetǰ`Ã in instance to use it\u03a2 i¶n the model.\nIt`s not rϘight patte˥rnƥ of using TransʉãfȽorms and TS̗D̿ataset.')), Assign(targets=[Name(id='co', ctx=Store())], value=Constant(value=0)), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG'), arg(arg='max_epo', annotation=Name(id='int', ctx=Load())), arg(arg='g', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='int', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='gradient_clip_val', annotation=Name(id='float', ctx=Load())), arg(arg='learning_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='batch_s_ize', annotation=Name(id='int', ctx=Load())), arg(arg='context_length', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='hidden_size', annotation=Name(id='int', ctx=Load())), arg(arg='ls_tm_layers', annotation=Name(id='int', ctx=Load())), arg(arg='attenti', annotation=Name(id='int', ctx=Load())), arg(arg='dropout', annotation=Name(id='float', ctx=Load())), arg(arg='hidden_continuous_size', annotation=Name(id='int', ctx=Load())), arg(arg='los_s', annotation=Constant(value='MultiHorizonMetric')), arg(arg='trainer_kwa', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='_str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='quantiles_kwargs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Dict', ctx=Load()), slice=Tuple(elts=[Name(id='_str', ctx=Load()), Name(id='Any', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()))], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs_'), defaults=[Constant(value=10), Constant(value=0), Constant(value=0.1), Constant(value=None), Constant(value=64), Constant(value=None), Constant(value=16), Constant(value=1), Constant(value=4), Constant(value=0.1), Constant(value=8), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='los_s', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='los_s', ctx=Store())], value=Call(func=Name(id='QuantileLoss', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='max_epochs', ctx=Store())], value=Name(id='max_epo', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='gpus', ctx=Store())], value=Name(id='g', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='gradient_clip_val', ctx=Store())], value=Name(id='gradient_clip_val', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='learning_rate', ctx=Store())], value=IfExp(test=Compare(left=Name(id='learning_rate', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='learning_rate', ctx=Load()), orelse=List(elts=[Constant(value=0.001)], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='horizon', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='batch_size', ctx=Store())], value=Name(id='batch_s_ize', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='context_length', ctx=Store())], value=Name(id='context_length', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='hidden_size', ctx=Store())], value=Name(id='hidden_size', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='lstm_layers', ctx=Store())], value=Name(id='ls_tm_layers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='attention_head_size', ctx=Store())], value=Name(id='attenti', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='dropout', ctx=Store())], value=Name(id='dropout', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='hidden_continuous_size', ctx=Store())], value=Name(id='hidden_continuous_size', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='loss', ctx=Store())], value=Name(id='los_s', ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='trainer_kwargs', ctx=Store())], value=IfExp(test=Compare(left=Name(id='trainer_kwa', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='trainer_kwa', ctx=Load()), orelse=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[]))), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='quantiles_kwargs', ctx=Store())], value=IfExp(test=Compare(left=Name(id='quantiles_kwargs', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='quantiles_kwargs', ctx=Load()), orelse=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[]))), AnnAssign(target=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Union', ctx=Load()), slice=Tuple(elts=[Name(id='LightningModule', ctx=Load()), Name(id='TemporalFusionTransformer', ctx=Load())], ctx=Load()), ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='trainer', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Attribute(value=Name(id='pl', ctx=Load()), attr='Trainer', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Constant(value=None)), AnnAssign(target=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_freq', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='_str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0)], decorator_list=[]), FunctionDef(name='_get_pf_tra', args=arguments(posonlyargs=[], args=[arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='ɴϸGeʺ̞t tíɀŐLP˫yʋtoβrʸ̥͌cËhForecast˿i\x9bngTǆražƻ̋ȘnéżŌôɡs^̾for͢mȿm˼ Ɗfrŗomƹŋ\x81j˚ tƴũs.trMansfor¸ms ³͟orȖǣ raɜiâse ȢĄexΞcèption iϠf noŦt fouͤnǔd.')), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='ts', ctx=Load()), attr='transforms', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), Call(func=Name(id='isi_nstance', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='transforms', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='PytorchForecastingTransform', ctx=Load())], keywords=[])]), body=[Return(value=Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='transforms', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()))], orelse=[Raise(exc=Call(func=Name(id='ValueErr', ctx=Load()), args=[Constant(value='Not valid usage of transforms, please add PytorchForecastingTransform at the end of transforms')], keywords=[]))])], decorator_list=[Name(id='static_method', ctx=Load())], returns=Name(id='PytorchForecastingTransform', ctx=Load())), FunctionDef(name='_from_dataset', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG'), arg(arg='ts_dataset', annotation=Name(id='TimeSeriesDataSet', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='đǧCoʴnstŚ˞ruƱšɳctƽ´ ĶTempoͤraπliF¸͆ˉϺusio©nŃʻÕπ9Tr͎aˍnsfor˺ƖΜϕmϲeέr.\n  \n  \n\nReturh\x8bnsr\n  \n-ę-³-----\n  #lnCUViPymAgoxFHXtD\n\n   \n̷Ligh˵ŷt\x93̥nőiʲȔngMoƏĺdΚǭǻ̘uΞλͬle ŸclȧsˡsƣǕ ̻iȝŽɒnsƥϛȟtΧ́aL̲ncƕͦeȄģ.')), Return(value=Call(func=Attribute(value=Name(id='TemporalFusionTransformer', ctx=Load()), attr='from_dataset', ctx=Load()), args=[Name(id='ts_dataset', ctx=Load())], keywords=[keyword(arg='learning_rate', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='learning_rate', ctx=Load())), keyword(arg='hidden_size', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='hidden_size', ctx=Load())), keyword(arg='lstm_layers', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='lstm_layers', ctx=Load())), keyword(arg='attention_head_size', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='attention_head_size', ctx=Load())), keyword(arg='dropout', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='dropout', ctx=Load())), keyword(arg='hidden_continuous_size', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='hidden_continuous_size', ctx=Load())), keyword(arg='loss', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='loss', ctx=Load()))]))], decorator_list=[], returns=Name(id='LightningModule', ctx=Load())), FunctionDef(name='forecas_t', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bo', ctx=Load())), arg(arg='quan_tiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='Make pʚredictio\x91ns.\n\nϽTˬhiƹsδϨ m\x9aeth̝od wiȃ\xa0ll ˸makəʩe auͮtoregre̎ü˗ssÕiɰýve predictions.\nȋ\nParašmĮeşte͡rϓs\n-------;-Ɏ--Ά\n  \n   \n  \n \nt̎Ĭsļ:ɸ\n Ď Ϣ  DaϙtŹaset wit\u0379hƛ featurɩes\npʲrƥedi©ctionʶ_interval:\n  ͓  If True r_θeǵt©u̚rns predǗictionϡ iƆŶn̐teǸʉr\x8evaņl¡ ̱for fΟo@ϖre\x8ecŝas¼ctʍŜϱ\nquantĿi\x96lesͮ:\n  ̠  Levels of̪ Ʋ̏pre̜ȟdicB϶Śt˚i˅ģonʞ dis˦tribuǔtion.̥Ĉ ʶBσy ŌȻ¯defau˅lt ¿2.5%̕ ¤Ρanʿdõ 97.L5% areġȮ takenȖ to fǿorm Öa 95%˗ predi̷2ctionÎ inteʩrżva\x95è̱l\nά\nReturns>\n\n--ǚ-Ö----Äʕ\nTSϥDϷatasēt\n  TS˩Datĥa\x82źs¬Ŷetɯ Řwith ÈϢƢƜp¸rediϲcẗ́ʶionsP.')), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='index', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[LtE()], comparators=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_last_train_timestamp', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='NotImpleme', ctx=Load()), args=[Constant(value="It is not possible to make in-sample predictions with TFT model! In-sample predictions aren't supported by current implementation.")], keywords=[]))], orelse=[If(test=Compare(left=Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='index', ctx=Load()), slice=Constant(value=0), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='date_range', ctx=Load()), args=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_last_train_timestamp', ctx=Load())], keywords=[keyword(arg='periods', value=Constant(value=2)), keyword(arg='freq', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_freq', ctx=Load()))]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='NotImpleme', ctx=Load()), args=[JoinedStr(values=[Constant(value='You can only forecast from the next point after the last one in the training dataset: last train timestamp: '), FormattedValue(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_last_train_timestamp', ctx=Load()), conversion=-1), Constant(value=', first test timestamp is '), FormattedValue(value=Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='index', ctx=Load()), slice=Constant(value=0), ctx=Load()), conversion=-1)])], keywords=[]))], orelse=[Pass()])]), Assign(targets=[Name(id='pf_transform', ctx=Store())], value=Call(func=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_get_pf_transform', ctx=Load()), args=[Name(id='ts', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='pf_transform', ctx=Load()), attr='pf_dataset_predict', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueErr', ctx=Load()), args=[Constant(value='The future is not generated! Generate future using TSDataset make_future before calling forecast method!')], keywords=[]))], orelse=[]), Assign(targets=[Name(id='prediction_dataloader', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='pf_transform', ctx=Load()), attr='pf_dataset_predict', ctx=Load()), attr='to_dataloader', ctx=Load()), args=[], keywords=[keyword(arg='train', value=Constant(value=False)), keyword(arg='batch_size', value=BinOp(left=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='batch_size', ctx=Load()), op=Mult(), right=Constant(value=2)))])), Assign(targets=[Name(id='predicts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='prediction_dataloader', ctx=Load())], keywords=[]), attr='numpy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='ts', ctx=Load()), attr='loc', ctx=Load()), slice=Tuple(elts=[Slice(), Subscript(value=Attribute(value=Name(id='pd', ctx=Load()), attr='IndexSlice', ctx=Load()), slice=Tuple(elts=[Slice(), Constant(value='target')], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Store())], value=Subscript(value=Attribute(value=Name(id='predicts', ctx=Load()), attr='T', ctx=Load()), slice=Slice(upper=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load())], keywords=[])), ctx=Load())), If(test=Name(id='prediction_interval', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isi_nstance', ctx=Load()), args=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='loss', ctx=Load()), Name(id='QuantileLoss', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Constant(value="Quantiles can't be computed because TFTModel supports this only if QunatileLoss is chosen")], keywords=[]))], orelse=[Assign(targets=[Name(id='quantiles_predicts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='prediction_dataloader', ctx=Load())], keywords=[keyword(arg='mode', value=Constant(value='quantiles')), keyword(arg='mode_kwargs', value=Dict(keys=[Constant(value='quantiles'), None], values=[Name(id='quan_tiles', ctx=Load()), Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='quantiles_kwargs', ctx=Load())]))]), attr='numpy', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='loss_quantil', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='loss', ctx=Load()), attr='quantiles', ctx=Load())), Assign(targets=[Name(id='computed_quantiles_indices', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='computed_quantiles', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='not_computed_quantiles_', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='quan_tile', ctx=Store()), iter=Name(id='quan_tiles', ctx=Load()), body=[If(test=Compare(left=Name(id='quan_tile', ctx=Load()), ops=[In()], comparators=[Name(id='loss_quantil', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Name(id='computed_quantiles', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='quan_tile', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='computed_quantiles_indices', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='loss_quantil', ctx=Load()), attr='index', ctx=Load()), args=[Name(id='quan_tile', ctx=Load())], keywords=[])], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='not_computed_quantiles_', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='quan_tile', ctx=Load())], keywords=[]))])], orelse=[]), If(test=Name(id='not_computed_quantiles_', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[JoinedStr(values=[Constant(value='Quantiles: '), FormattedValue(value=Name(id='not_computed_quantiles_', ctx=Load()), conversion=-1), Constant(value=" can't be computed because loss wasn't fitted on them")])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='quantiles_predicts', ctx=Store())], value=Subscript(value=Name(id='quantiles_predicts', ctx=Load()), slice=Tuple(elts=[Slice(), Slice(), Name(id='computed_quantiles_indices', ctx=Load())], ctx=Load()), ctx=Load())), Assign(targets=[Name(id='quan_tiles', ctx=Store())], value=Name(id='computed_quantiles', ctx=Load())), Assign(targets=[Name(id='quantiles_predicts', ctx=Store())], value=Call(func=Attribute(value=Name(id='quantiles_predicts', ctx=Load()), attr='transpose', ctx=Load()), args=[Tuple(elts=[Constant(value=1), Constant(value=0), Constant(value=2)], ctx=Load())], keywords=[])), Assign(targets=[Name(id='quantiles_predicts', ctx=Store())], value=Call(func=Attribute(value=Name(id='quantiles_predicts', ctx=Load()), attr='reshape', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='quantiles_predicts', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()), UnaryOp(op=USub(), operand=Constant(value=1))], keywords=[])), Assign(targets=[Name(id='d', ctx=Store())], value=Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load())), Assign(targets=[Name(id='segments', ctx=Store())], value=Attribute(value=Name(id='ts', ctx=Load()), attr='segments', ctx=Load())), Assign(targets=[Name(id='quantile_columns', ctx=Store())], value=ListComp(elt=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='quan_tile', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), generators=[comprehension(target=Name(id='quan_tile', ctx=Store()), iter=Name(id='quan_tiles', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='col_umns', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='pd', ctx=Load()), attr='MultiIndex', ctx=Load()), attr='from_product', ctx=Load()), args=[List(elts=[Name(id='segments', ctx=Load()), Name(id='quantile_columns', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[Subscript(value=Name(id='quantiles_predicts', ctx=Load()), slice=Slice(upper=Call(func=Name(id='len', ctx=Load()), args=[Name(id='d', ctx=Load())], keywords=[])), ctx=Load())], keywords=[keyword(arg='columns', value=Name(id='col_umns', ctx=Load())), keyword(arg='index', value=Attribute(value=Name(id='d', ctx=Load()), attr='index', ctx=Load()))])), Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='concat', ctx=Load()), args=[Tuple(elts=[Name(id='d', ctx=Load()), Name(id='quantile', ctx=Load())], ctx=Load())], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Name(id='d', ctx=Store())], value=Call(func=Attribute(value=Name(id='d', ctx=Load()), attr='sort_index', ctx=Load()), args=[], keywords=[keyword(arg='axis', value=Constant(value=1))])), Assign(targets=[Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Store())], value=Name(id='d', ctx=Load()))])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='ts', ctx=Load()), attr='inverse_transform', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='ts', ctx=Load()))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='get', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='ʈ"G˯et internɏal moɝdel tƓYɖhaʉt \x8bis usÜed Ĥinsid͕\x90ŬƸŕeqa etn̗a clŷasɷs.\nǍ\nɝInȷternal moʅʐŚƼʂděl ŶisɩͶ a model˅ tǹ²·haǓtŲ is usedǯ Ϥinside etna toʷŜ forecastƋ˳ se¬gξmȸ\u0380ents,\n   \neͧ.Ż9g.Ã :pyÌ͗:cɭulaǑs̆s:Ȏ͏`cȻϏatbͦ˱oost.CǟatBoostReΚʅÃǈgressor` or :ϷƤ\x93py:class:`sklϛ<eaɤrn.ɝlinėa\u03a2rþ_moʨŽdel.Riȫdgeų`.#fXlenQkKuhpGOJ\n\n\nReɿČǋturns\nŝ---˧-m---\n:\n   \n \n   IÆntÿerϘnal mʜoȸdelȇΥ')), Return(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='Any', ctx=Load())), FunctionDef(name='predict', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bo', ctx=Load())), arg(arg='quan_tiles', annotation=Subscript(value=Name(id='Sequence', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False), Tuple(elts=[Constant(value=0.025), Constant(value=0.975)], ctx=Load())]), body=[Expr(value=Constant(value='\x95Mʭ\x83aͳǥkǾe pr˳ediΦctions.kŇ\nûʴ\nΎTǒ%hisn me^tçĚhϝoʂd ͙wilqlˉ make ˌpredictionȾs usi\x87nώg ĉtrÄuϤe valÎuȪes̵ iŖnstead of p˳rɸ̓-e˟dicted Ǉγon Ŗa previous ëste͑p.\nIt can bñŦe̩ usΔ˕efulȶ fo̤r ʚmak˜ing in̍-sampơley f\x8fʣor_e\x93castsn.P\n\n  \nParaʡmeteʆrs\n---C----Ϋ-Α-\x84-\n͉tsμ?ō:2\n  \n  D7atase͐ňĮƺͲǝƎǲ̣t with feat̎u͊res\n   \npͷǊ\u038bˢred\x80ictiĲoǹ_int¦e4rval:\n ɼ ʦ  ŷIΖfÕ ̼TζruĴŋeʅ reǊʚturnɜs ̣Ŵpͮrɖedʖicɟtiońð ÅinteĴĸrval for foreUcńastɑ\nʡqǵȆuaŋntƗiles:\n   \n8\u038b  ǒ  Lev\x83els of ʐprǬe̼dȮiction disʀtr¿ibutionȗ. By defaϥψult 2.\x9f#5% anϸȂdċ 97.ɭĄ̞ƌ5%˱Ǽ aǧ\u0381+reÆ t̙aken͈ è˄toͫ form a ͞95̣% ̈́ƥȈpredicȼtùion \u0378iƽntervȒ͈al#YrxZtKvTzujOMGLSm\n \n\n  \nRetưurns#iMDcRyx#AYJVpbjNME\n-²----Ƙ--#Dtkxypq\n   \nTÎƒSDatʫaseΛ˕ƞt\nɭxȘȾς  Ĵ  ʚTϠƇSDa˂ƕłștasset ̗wǥitƻh predicītiọns.')), Raise(exc=Call(func=Name(id='NotImpleme', ctx=Load()), args=[Constant(value="Method predict isn't currently implemented!")], keywords=[]))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Name(id='TSDataset', ctx=Load())), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='selfjEveG'), arg(arg='ts', annotation=Name(id='TSDataset', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Subscript(value=Attribute(value=Attribute(value=Name(id='ts', ctx=Load()), attr='df', ctx=Load()), attr='index', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_freq', ctx=Store())], value=Attribute(value=Name(id='ts', ctx=Load()), attr='freq', ctx=Load())), Assign(targets=[Name(id='pf_transform', ctx=Store())], value=Call(func=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_get_pf_transform', ctx=Load()), args=[Name(id='ts', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='_from_dataset', ctx=Load()), args=[Attribute(value=Name(id='pf_transform', ctx=Load()), attr='pf_dataset_train', ctx=Load())], keywords=[])), Assign(targets=[Name(id='trainer_kwa', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[], keywords=[keyword(arg='logger', value=Attribute(value=Name(id='tslogger', ctx=Load()), attr='pl_loggers', ctx=Load())), keyword(arg='max_epochs', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='max_epochs', ctx=Load())), keyword(arg='gpus', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='gpus', ctx=Load())), keyword(arg='gradient_clip_val', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='gradient_clip_val', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='trainer_kwa', ctx=Load()), attr='update', ctx=Load()), args=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='trainer_kwargs', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='trainer', ctx=Store())], value=Call(func=Attribute(value=Name(id='pl', ctx=Load()), attr='Trainer', ctx=Load()), args=[], keywords=[keyword(value=Name(id='trainer_kwa', ctx=Load()))])), Assign(targets=[Name(id='train_datalo', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='pf_transform', ctx=Load()), attr='pf_dataset_train', ctx=Load()), attr='to_dataloader', ctx=Load()), args=[], keywords=[keyword(arg='train', value=Constant(value=True)), keyword(arg='batch_size', value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='batch_size', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='trainer', ctx=Load()), attr='fit', ctx=Load()), args=[Attribute(value=Name(id='selfjEveG', ctx=Load()), attr='model', ctx=Load()), Name(id='train_datalo', ctx=Load())], keywords=[])), Return(value=Name(id='selfjEveG', ctx=Load()))], decorator_list=[Name(id='log_decorator', ctx=Load())], returns=Constant(value='TFTModel'))], decorator_list=[])], type_ignores=[])