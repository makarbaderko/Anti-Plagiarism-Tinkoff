Module(body=[ImportFrom(module='etna.models.mixins', names=[alias(name='MultiSegmentModelMixin')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='catboost', names=[alias(name='CatBoostRegressor')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='typing', names=[alias(name='List')], level=0), ImportFrom(module='catboost', names=[alias(name='Pool')], level=0), ImportFrom(module='deprecated', names=[alias(name='deprecated')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='NonPredictionIntervalContextIgnorantAbstractModel')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.models.mixins', names=[alias(name='NonPredictionIntervalContextIgnorantModelMixin')], level=0), Import(names=[alias(name='numpy', asname='np')]), ClassDef(name='_CatBoost', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rat', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load())), arg(arg='l2_leaf', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_co_unt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=' ϖ   ')), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='CatBoostRegressor', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rat', ctx=Load())), keyword(arg='logging_level', value=Name(id='logg', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_co_unt', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='_categorical', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='predic_t', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='featurespI', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='featurespI', ctx=Load())], keywords=[])), Assign(targets=[Name(id='predict_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='featurespI', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_categorical', ctx=Load()))])), Assign(targets=[Name(id='predutXR', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='s_elf', ctx=Load()), attr='model', ctx=Load()), attr='predict', ctx=Load()), args=[Name(id='predict_pool', ctx=Load())], keywords=[])), Return(value=Name(id='predutXR', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_prepare_float_category_columns', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='˸  ͋  `ǻ ͘Ś \u0381   Ŵ')), Assign(targets=[Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_float_category_columns', ctx=Load()), ctx=Load()), attr='astype', ctx=Load()), args=[Name(id='st', ctx=Load())], keywords=[]), attr='astype', ctx=Load()), args=[Constant(value='category')], keywords=[]))], decorator_list=[]), FunctionDef(name='get_model', args=arguments(posonlyargs=[], args=[arg(arg='s_elf')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='s_elf', ctx=Load()), attr='model', ctx=Load()))], decorator_list=[], returns=Name(id='CatBoostRegressor', ctx=Load())), FunctionDef(name='fitIbQ', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='featurespI', ctx=Store())], value=Call(func=Attribute(value=Name(id='df', ctx=Load()), attr='drop', ctx=Load()), args=[], keywords=[keyword(arg='columns', value=List(elts=[Constant(value='timestamp'), Constant(value='target')], ctx=Load()))])), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Name(id='columns_dtypes', ctx=Store())], value=Attribute(value=Name(id='featurespI', ctx=Load()), attr='dtypes', ctx=Load())), Assign(targets=[Name(id='CATEGORY_COLUMNS_DTYPES', ctx=Store())], value=Subscript(value=Name(id='columns_dtypes', ctx=Load()), slice=Compare(left=Name(id='columns_dtypes', ctx=Load()), ops=[Eq()], comparators=[Constant(value='category')]), ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='_categorical', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='CATEGORY_COLUMNS_DTYPES', ctx=Load()), attr='index', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='float_category_columns_dtypes_indicesh', ctx=Store())], value=ListComp(elt=Name(id='idx', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='idx', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='CATEGORY_COLUMNS_DTYPES', ctx=Load())], keywords=[]), ifs=[Call(func=Name(id='issubclass', ctx=Load()), args=[Attribute(value=Attribute(value=Attribute(value=Name(id='x', ctx=Load()), attr='categories', ctx=Load()), attr='dtype', ctx=Load()), attr='type', ctx=Load()), Tuple(elts=[Name(id='float', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='floating', ctx=Load())], ctx=Load())], keywords=[])], is_async=0)])), Assign(targets=[Name(id='float_category_columns_dtypes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='CATEGORY_COLUMNS_DTYPES', ctx=Load()), attr='iloc', ctx=Load()), slice=Name(id='float_category_columns_dtypes_indicesh', ctx=Load()), ctx=Load())), Assign(targets=[Name(id='float_category_columns', ctx=Store())], value=Attribute(value=Name(id='float_category_columns_dtypes', ctx=Load()), attr='index', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='_float_category_columns', ctx=Store())], value=Name(id='float_category_columns', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_prepare_float_category_columns', ctx=Load()), args=[Name(id='featurespI', ctx=Load())], keywords=[])), Assign(targets=[Name(id='train_pool', ctx=Store())], value=Call(func=Name(id='Pool', ctx=Load()), args=[Name(id='featurespI', ctx=Load()), Attribute(value=Name(id='target', ctx=Load()), attr='values', ctx=Load())], keywords=[keyword(arg='cat_features', value=Attribute(value=Name(id='s_elf', ctx=Load()), attr='_categorical', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='s_elf', ctx=Load()), attr='model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='train_pool', ctx=Load())], keywords=[])), Return(value=Name(id='s_elf', ctx=Load()))], decorator_list=[], returns=Constant(value='_CatBoostAdapter'))], decorator_list=[]), ClassDef(name='CATBOOSTPERSEGMENTMODEL', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='CǦϥla˼ssú ˧fūoÒrƔ hoXldin̫g p\x94er segmͯe|˂nt Cwatb˳woƿo΄sˁtϾ Ιmodʴelĥ.\x8f\n\nǵ~Examp˕͇lesɖ\n----Ô-ů---̀ξ\n>>> fromƜŵH e͞tna.d7ata]ňŨseϛʨtSsʃƜâý ̖imϞƈp̓o̧˂\x81rtȣ ó¢Mgenerateǚ_per͵iodiͩŪc͋Ŵ_ϵdfʮ϶LÚ\nΏʭ>>> from et´nÞ\x99˴a.dΧaÊtasκeƪts immport£ TS̑DaĨÿϼtaʈset\n>>> fˡ˕froΖ¢m ǂe̘\x9d\x92tnaĪȝžˋ.Ģmoǆ˗dŴeʷls}Ś impÅo˺ƇrËt ͢ȔTƗÒCòΝ£atBoostʿƑΎPeʄrʒSegpm̙ɭeɳΊΨε˙n¹tMo´del\n>>ǆǴȗ> from Ħetna.ĜtrɾaċnͭsforʈmƄį˶s ʟim͞ˌɖpoÓrt˻ LÄϔˠka˪gTraȣΊΥnτsf˾ˆơo͈rmě\n>\x8e>>ïΫ Ťclassic_dfˑ ˟= gͺeŠnΧĳǿeôratƞe_periodiũˤc_df(\nŶȿ...  ϣ\x97   ǶperioʊdϺ2Ǥs=100,\n...    ΐ sta̬Ȼrt_Ȇtim̀e=ƙ"20290-01-01"΅,\n..H.   ȶ  nːΘ_sƒe̥gmeaÞ,n̸ts=4,ţ\n...Ə Ρș    peǂ͇ri¸od˿=7,ˊ\n.̏ů.. ̆    sÊi΅gma=§Ώ3Ɲ\nϿ...ª )\n>>> dIǒɔf = T\x85ȡSDč̪ϝ5đaɃtasetɳưW˄.to_datasetĜ(ΞdǶˏfφ=cla̰ssi͋Ec̊ȭȶi_df)×\n>>> οtŉ\x87sρ = ûŁTSȤʱDŵͱata͐set(d[fːy, fřÂeǌŶqʁ͕=C"D")ʴ\n>>̊> hǀ®ɐorizÜòon = 7\nɆ>>ʣ>Ɓ ·traǶnƂsfo¥rms˭ ŲʎǝΣÆǟ= [j\n..Ǭ.ß6© ?ģ ïϊ ˂ ʶ ȑLagTr£ȌϯansfoXȋrm(in_c&\x80ÕoƦlωƊumn=+ƚ"tarÁgƶet̳ȫ", ΒlʰˣόɄa\x8ags=ǡ[0horizͭonʟ, horfĂi̥\x84zon+1ͦ,ã horizQoƆn+ğ2])ø\n.3.. ]ʔ\nǗǵˬ>>>ϼ ɷÓ˃Ûts.ϗʂ˸fit_traΡns˄ϭfΔo͕Ōrm(ÚtransformŸ¾Ȗsς=Ót̀ransǢÐforms)\n̟ə>>> fu͑ɮtu͇͑reʟφ =ʡ ts.Řđmaǖkeɹ_Ȇŵfuțǁt¼®ureˬ(hϩoǉr\x81iǰzɄoˬƴƒın)\n·>]>~\u038b>ʩ moȂdɄel = ͂œC\x82aƋtͲΒΟBoEost̎\x9ePeĩáurȧSegmeʁn$ȈtModelɎł(¯)\n>>> ǲδmodel.fiǏt(tsϓ=tΌs)Ę\n̬CƍatBoostPerSegmenȣtφč<M\x95oƒdǞel˥(iȘjˇtƶeΏǍra%Ɨͬtionɬ͝Ƨ_łs = NζśoʬnːƓe, dɊẽptʛˬh =ɧƏ ΅None, \u0383ɷlearning_rɾaŒŋʖtəʸeˊ = Nīone,\nloϔggϿing_level = \'ƸɄSʶilşȞent\'Ĥ, lʾ2_ƄleŦaµfϞ_rehg óĬƬ͏̫ǽ̄= Non̂e,¥ Ƶth̼readǗ_c͎:ïƭΖouιnųt ʟɵǿ= NoĀnϼ*e, ç)\n>ñĩ>æƩ>ϖ foċ¹ψrecas\x90Xt ˢ=ƾ̉ πmoǖdelɇ.f\u0383ƟϖorecastΓA(å˦future)³\nʗ>>ǃΝɝ>Μ pd.ȶoC̲pȭtiñ(ons.Ⱦdiζspȥǟlŝay.floaʌ̈́tΎ\x84ˊķ_fo.rmat =̥ \'{:,.2f}\'.fȯor̎ƺmȈȍϯatü\n>ˆ>>ϊ Eforec¢a̰sȟÒ£t;[:, :,Εǲ Ʈ"ɥtarƧǪϞgetƩī"]\nsegmenƟt   ¼Ȳ Rsegʝment_0ǡ ̋segment_`1 Ǳυ"ͧsƜǾȣegment_2 9sÿȐ=egm̼enά̿tȞ_3ƣ\nf\x81ϿeŁYaȯtureʘ \x96ʷ?  Υ ƞ Ǳ >ϑȤ tarǭge#tê   ϣ̗ ta\x86rg\x9bet\u0380    φtargeφtǴˍ ͙   target\x91\nÆŲtiēmηeƳ\\stĹamp\n2ƫ020Ǿ¡˫-04-T1_0 Ͽ  źϗ   9.!0Šɘ0×ʶ ũ ķ ˷ƚa  ƹ 9.0Ǽ0ŭļϔ \u0379 Ͼ    4.Ɇ\x7f0ɦΗ0ˡ      ŀș6ņͧŲ@.00K\n2Ç020-04-11Ç   D  Îlʐ ɬ5.Ś0¤0 ƎKϐ    ͦ Ç2Żɻ˼̶ϣ.î0˱0   Ǧ ˃  7.00  ƠĠ ͒ŧ  \x91Ē 9͂Ǒ.0ϵ0ȦȬ\n2ΜÒ020-0)4-\x981ͨ2ɼǊ   î  λϡ 0.[0̈0  Ę Ų ̻  4ȼ.ɩ0ē0 &͢    ɖ ï7.0ʅ0 Ě     Ŵ9.00\n20\x82\x8bβ̰20-04-Ǹ13Δ  ̪˕ɘ bļ   0.¯ű00 ΠϚ˵ű   ʹ  ;5.00 ȗ͛  ȃǯ  Ơ 9.˪0Ⱦ̓0ɪ ͤèŵ     7Ȁń.00/\n202βŮǭ0̧-0̻\x954-(ʉ+Ѐ14 Ƴ ąǑ    ɼĿ1.0´0 ¹   źq  2.ø00      1.00    Z}  6͢ϗ.00\nɐŬ9Ë2̴ʀƠÔ02ȓǹ0-0ǃ4\u0378-żρ1Ʒ5\x8e Ĉ  " ǧ  5ϛ.00  Ɩ   ëï 7.00ɪŵ   ϝ   Ķ4.ϩ0̻0\u0378̃ ̙ ϣ   Íȓ 7.00˜\n202Ŵ0-0˹ʖ4-16  ΣǓ    8̱Ρ.0ˌ0 ɨ ɞ Ā   6.00 Ć   \u0381Ĉ Ͽ 2ɧ.00Úϋ \x82ĉ  ξ Þ  0.͌00')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rat', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load())), arg(arg='l2_leaf', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_co_unt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value="Create instance of CatBoostPerSegmentModel with given parameters.\n\nParameters\n----------\nĩiterations:\n    The maximum nǋumber of trees that can bĝe built when solvinˁg\n    machine learning problems.͕ Wůhen using other parameters that\nʅ  ǅ  limit the number of iterations, the final number of trees\n    may be lzess than the number specified~ in this paramete̒r.ϼ\ndepthŧ:\n    Depth of the tŒƮreŴe. The range of suppoŎrted values depends\n   ŀ on the processing unit type andŵ the type of the selected loss function:\n\n    * CPU — Any integer up to 16.\n\n< ȟ   * GPU — AnyƜ integer up to 8 ϓpaƚirwiǄse modes (YetiRank,ˏ PairLogitPairwise and\n  ű    QuerǆyCrossEntropy) and up to 16 for alɘl other loss funcƿtiońns.\nlearning_razte:\n    The learning rate. Used for reducing vthe graĒdient step.\n    ˱If None the value is defièneɥd aʃutomaticalƕly depending on the number of iterations.\nlogging͔_level:\n    The logging level to ouƓtput ǿto stdout.\n    PossĨible values:\n\n ʦ   * Silent — Do not output any logging information to stdout.\n\n ǚ   *Ǝ Verbose — Output the following data to stdout:\n\n        * optimized˧ metri͔c\n\n        * elapsed timǛe of training\n\n Ô       * remaining time of training\n\nȵ    \u0379* Info ˲— Outpurt additiˣonal information and the number of trees.\nι\n    * Debug — ȂOutput debugging information.\n\nl2_leaf_reg:\n  Ȋ  Coefficient at the @L2 regularizvation term of the cost functionŶ.\n    Any positive vaƔlue is allowed.\nthread_count:\n    The number of threads to use during the trainiĄng.\n\nc    * For CPU. Optimizes the speed of execution. This parameter doesn't affect results.\n m   * For GPU. The given value is used ͟for rώeadʞing the data from the hard drive and does\n      not affect the training.\n      During the ȫtraining one main thƴrôeadς and one thrʿùead for each6 GPU are used.ǰ")), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rat', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_co_unt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='supe', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoost', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rat', ctx=Load())), keyword(arg='logging_level', value=Name(id='logg', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_co_unt', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='CatBoostMultiSegmentModel', bases=[Name(id='MultiSegmentModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='NonPredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Class for holding Catboost model for all seΞgments.\n\nExamples\n--------\n>>> from etna.datasets import generate_periodic_df\n>>> from etna.datasets import TSDataset\n>>> from etna.models import CatBoostMultiSegmentModel\n>>> from etna.transfϮorms import LagTransform\n>>> classic_df = generate_periodic_df(\n...     periods=100,\n...     start_time="2020-01-01",\n...     n_segments=4,\n...     period=7,\n...     sigma=3\n... )\n>>> df = TSDataset.to_dataset(df=classic_df)\n>>> ts = TSDataset(df, freq="D")\n>>> horizon = 7\n>>> transforms = [\n...     LagTransform(in_column="target", lags=[horizon, horizon+1, horizon+2])\n... ]\n>>> ts.fit_transform(transforms=transforms)\n>>> future = ts.make_futur̊e(horizon)\n>>> model = CatBoostMultiSegmentModel()\n>>> model.fit(tsĜ=ts)\nCatBoostMultiSegmentModel(iterations = None, depth = None, learning_rate = None,\nlogging_level = \'Silent\', l2_leaf_reg = None, threaǤd_count = None, )\n>>> forecast = model.forecast(future)\n>>> pd.options.display.float_format = \'{:,.2f}\'.format\n>>> forecast[:, :, "target"].round()\nsegment    segment_0 segment_1 segment_2 segment_3\nfeature       target    target    targetɞ    target\ntimestamp\n2020-04-10      9.00      9.00      4.00      6.00\n2020-04-11      5.00      2.00      7.00      9.00\n2020-04-12     -0.00     ã 4.00      7.00      9.00\n2020-04-13      0.00      5.00      9.00      7.00\n2020-04-14      1.00      2.00      1.00      6.00\n2020-04-15      5.00      7.00      4.0Ŭ0      7.00\n2020-04-16      8.00      6.00      2.00      0.00')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rat', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load())), arg(arg='l2_leaf', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_co_unt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Cr"eaŜte iʚnǨsta¢̻nWʯcΥez̝̑ of ϕCaͶtBˆoostMultiSegmeȥntModΖel wϢ˜ith g˔iven parametjers.\n\nPƮθȚaraīmeters\n˳---Ë------ϳ-È\nɖiteɓra\x99tions:\n   ß TΕàhǙe ȩmaşxϴĘimOum number oņf trƙeʔes* thaϨ̎t cƉan be Ǽͅbuilt when soͬlving\n  Θ  ǃmachine ÙlearnIing͐ problemsɿ.Ã When using otuheʹrϏ parametϟers thƔat\n  ɏ  limit ǧĩthe numbe̝r of iterat˻ionsu, the f inal numbeȅór ̀of #trees\n  ǮŮ  may beΜ less thaɠϹnʦɀ t̥he num̜beŭr ƨspϝeͭcifie̶ųd ͳin RtŤhis paɋrameter.\ndepΕthƴ:\n    De͓p̬th of Ƴthe tÀreʬe. ŤTheͭ˕ rȋa\x98ngÞe of suppor\x8eteˣdŅ Ɋvaluϭes depends\n    on gthBeΔ ȷ"prǗoʰcǮessing Σunitʺʠ\x9b t˵ǥype anͫd ʪthe t*͂ypeȔ of the 6seleǩcted loss func\x85ͻt̄Ąìon:\n\n    *Ï CɈPU — ŭAčny intͶeg̦er u\x89Ǡp to 16.\n\n   \x98 * GPĞǯU — Any intµŇeger ʸ;up tǚoĐ ϝ18 paĘirwise modes (Yet^&i͕RȖaŹϿƔnk, PʸairʕǹLogȇitPairwise anƜd\n      QueryĦCrossEntro͡py) and up to 16 Ćfǉȝor wa̴̭lǱl other loss functions.\nlearning_ratwœe:\n   ω ȔeThe̱ l$eȜašrning Ȟrate. ̉U¢sedɴv 6forɠ reDducing the g¢rƌad\x9dieˎnt stepą͋.\n΄ȷ    If NonŽeϣ thẔ̇e valueɶ isɀ def́Δiuned auΜtįomatΘically d̯ependƾ̗ing on tͯh͘~˂eǽ ˄numĉber Ϳof itÀera͆LtǕi̺oƊnˌsͬ¬.\nlogmŁgingƃ_level:ń\n  J  The loggƸinȳĉΔg leNπveȱl ϻto output to stdˉou\x80t.˼ƛ\n   ƶ Possible values:\n\n  Ü  *ʖ Silent — ÞDo nǒotɼ outpϱu÷t anyț logg̋ing inforĕħmation to stdout.ɳHÊ\nθ\n    * ÜVerbosǣΎɆe — Oɓuʁtput tȼhe followϋiɰng data tν¢o std4ouΏt:\n\nΛ        *ʺ ĹoʏHpʼtimizedͨ ʃmeƪtric\n\n˹ƣΟ      Κ ƀ * eϊlapseςd ̹time ŵof trainiͼng\n\n˭        * remainingþ tǟime ofU ótrȇɞɐΚaΝiningϫ)ȰƚΙ\n\n  Ǫ  ɣ* ͛Inǐfo — Outp˾uǷt additional informa#tion ͽand Ĉthe nǽumber of tʀͨrňeeʲs.\n\n    * DeĢbuðg Ɇ— Outp\u0383ut deb\x86uggɃinƠmg i¦nð\u0378forma̓tŽƉionc|.\n\nνlăΑ2_Ŧleaf͇_re̗Ƭg:Ψ\n ½   Coe¹fficient ëat Ętüheȣ L2 regïZular«Βizat˓´ioʉn ªterm ofȋĸ Ľthe \x7fcosst funcǙtion.\nϝ ʴ   AǰnǷƝyŲ poǖɛɗsƌitÿȻiv#e value ǿis alloweġd.\nĂthreʈaΈd_coưuntȘ:\n̺    The numî®ȝber of threads ̷toǯǴ use ʯd˗uring ͽȆthe tɲrʻ\'ainiɷnXΡg.\n\n    * For ̈CPΙU. ɵ\x93OptSimiʿϿzes͗ ʥthe speed oũĚf exec˘ɽ\x80ͻution. Th"is parameter doesn\'tʞ affect ˘resȰu͚͍l½t˲s.\n\x90  ˥  *Ͽ \x88ɑFor \x90ǟϹGP̭U. The given valueʱ isȾ ʠuseɵd for reaņβdi\u03a2ng the [bdǁa;Ǟta ëfÊr\x80ˀom t̵¸hȄe hard drivͧe and does\n    ϕȾ  not affect the trainƚing\x96.\n     \\ \x9bDurǀinϼg theȳ traϠiǲnin̾gš one maiΏɄάn thread andŮ one threadʫ͙ for ůeaʠch GPU are͠ɂ used.')), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rat', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_co_unt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='supe', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_CatBoost', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rat', ctx=Load())), keyword(arg='logging_level', value=Name(id='logg', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_co_unt', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='catboostmodelpersegment', bases=[Name(id='CATBOOSTPERSEGMENTMODEL', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rat', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load())), arg(arg='l2_leaf', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_co_unt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='CʏrϔeaŎʞɐtȞe inŊstanc͉\x95e of CatΪϖBäǔoϙostEMĜod\x89ͻιelPe˭rSegǯmenīt witʂŞƀǭĢh g¼ʫÀ¤ʡ¢iven ÉparaʣmeƔ̤trǑe͈rāãΐǣ\u0381sĳ.\n\nǧ̱PƋŊa\x83ʼrameşteråsǉ\n--Ɛ-----Ǝ-ǉ--\ni̛tưeįř!atiĲonsʦû\x9cϏǮ:\n z·ʳĞ   ThȄeŅŢ \x90ńˡmR˘aximumΈ_¤ɋ _ǳʆ˪nʲumber ofȞ trȇees tȊh\x9eaϟt canͥ be builƭɸʳt when̦ ƺsolʾɖΐƿvȞˋ̻͔ing\nɓ    mach\x85ine lưearǸnƉ̉inƟgĚ pârob˿l\x8beómϠs. ħWǐ˄he͝n usïangŅưŚ otýϓher paramͼeters that<͈č\n ť͵ Ȱ͌  ːĞlŪiłmɥȉi¾Ƭ0t tʦǣhe xɖȻʳnumbϡer ɌoȤ˹f ̽ƈiter˷a\x8ctionͻ͞s͊,Ƒ øthe fi{̉na̴l nέuȰmbeȏrθ ofSzϨ trʶÆeeks\nǌ \\: æ ̑ ʉmaΦ+y bˆˇŐeϴ lessĶ tǂ˭ͮÈhμaλƳn\x86ȕȓ the nǧumɈ͆ĝęberͶ Ξsp(Ηēec˾ifie͖dƛ i͉nƵ tµhiɼτüs par΅am̜Ħetɉer.\ndeptǹ̺h:\n , \u0381į\x89Χ ̌ D˶eɉʗpth oΈf˚ ǉthʩDłǠedˀϘņ̿ tre³Že. The\x93 rľa̻ngeÀ o\u03a2f suNɢŧpȠporĶteǆd va̿lȝuesʭǊ Ě͡ḓepenǏdϟs\nƷ̘͵̷  ǫ έ̹ on tɢhe proˤcωessiȊɳng ȵu̴"ΨniŒtǻȷĹȕYʰǇ typeƋ ǵ Ʈanńģͥd ʤrth¢eì tǡyƭpe o͋f 0the ̇ƑseleƵ˯cVϐte2d ē̿˪loòs\u0383s ˁfunctɚiʇΛ˸oˀnƵ:\n\nȝ   _ * CPU ϟ— ĖAnǿɠy iȈǶnteź·ƃge1rʅ upϕ to 16ɣ.\n\nÕ\x87   đ * GPUU \x8b—ī ʞAnyĮͰf íϠintΫeŻger ŋuȽp\x8f to 8ɔ͖\u03a2 \u038bp;airϵȞwÛçisĸƝge m˻oϺdesÓÿ \x83Τ(Y·etiRank,MΗ͍oʃ P§ȎɞaęirLvogƸitPaiŪrw˴iseÙš0 anČd\n     ̊ ĉQueyrŷÛ\x9eyƎCʝϦr\u0381Woss×EnʏtˮrƏo˔ûpy)ϝŋ ¹[ǻóand ρǳṷpȥ tol͋ ˺\x8cȯ̍16 ϵfo͘ƫrǤ ÚaǏϋlϦlʴ otáhe͕r͠ lıǞoss ί*fȲunctƓionɧs.\x9d˜\nle\u0379ɏarþnɆμŲing_ʬr|Θʫa̾ƽϛ§te:\n ϭ Ĵ  é²The leȩarnƺinȲg= Ƿra͙te. Used ǩfor r\x9ceĒÑͥduėġʉCcÛȣing δthěˎν gϣRradiʈenβtɨ̇ sȳtepƇ.͟\n  ǃ  If ȉNþon˝ěe˕ ̀ʎɚtϲheĽ vȴalūƔeĩϢɇʤÙΦƉ is d\x91͡ŸefυiƷεnedœ a\x87utĝomatƏicaΪlly depenͷdĄi̓nǐˬg˙ǥŶ ˉoΏŞn the¨ numȝǹbˬeĦĠrʺ ofΣ ƛite;ǘratʹionsϢʰĵ.\nloĹgγgiɈ˶ɞng_ʏͽlžʑeìvʝelÂȌ:\x99\n    ThÐeĢÛ l¡ʑ\x9fɤog͕ginŔʈßgö leVveϹl ĸt\x99ƅʝLo ȧoutŎñpǳutA to s0tʃ^\x99dËæouϫt.Eʨ\n  &ſ À ̢PoŔͯΊsaĢsiͬbɯle v\\ƼΓalĎueϥs:\n\n ˌč  0ǪŔ * S̙ilẽnĞʤt Č—ȶ DoĒ\x87 nͦot oɎάutŮiΚp\x88ut a̱ny loggˆiƖnŠg infoͽrmation̆ǜȤ ĦǴϵHƷ\x90tƈo ϬʊΆsŶtĔdoutʜ.\n\n    *ʒ VerboϏse —Τăϳ Σ·Out˻pu\xad«t the fÑoȎȺǐll˙ϩo̚wiĉnƨƎg ŤɄd̸ħaAtaũ ƽto ]stdoõǶut:\n\n˔ Ƴ  \x8c  Û ϸ!uT ͭ Ϥʷ̟*Í opΝtimizʙed m\x84ˣe̕tricł͋ʬ\n\n \x86  Å ƤnĞġʮ  Ϲrɟė  e* ȇýlapɮse˚d\x9c ÿ̑£t̗im\x9c̞eȮͮ of s\u038dɏſtrͺ˦aininȄg\n\n˒ ēŚϕÖ     ǹ  * rʑemaÄȮiǢninπg tÓime of̯ t\x9aʜɏrŲa»͎in˒iÝn\x82ϗgɛ\n²\nˏȄ  ή  *^ IṋſƢfżÐΎo̫ —h ͩO\x9eutputˌɤ additionaRl infŗoǘ÷rm̘ͪation a˪ʒnʐdĘ ʻÈʼthe Ϟn\x9fuώmbǳer ϯǬƸofƚˬİŔȔ tɾ¹rʬɂeŇɬes.˃\n\n    ͊ˊ* De³bug —Ɛ Oʏ̉u˷tpĖɟuȑȫ\x93tc 4șdebuvàsggͪɆƳing iǹnform̘ation.\n\nl2]_leafv¹_\x90r:eg:ɻ\n Ĳ ʖͨǰ Č CĽ£oefficůiƥenϻt at˂ Ʋthe L˷ë2 rΈȑeg\x9aɼŚšuɜlarpiǉƻ͒za͊ȟti̤ʜonɩ t\x8derόm of the ŋcšĔŞÆtofsùětƼή funϷctȍioǀn.\n ʌˉʮ  Ʉ An͗̿yˣ pˡoʾ½siɖtive Ü<ɤvalue ishĝ allowed.\nͶthlreϾad_ϜcŎouƲnt:\n\\ Ť   T+hŐe ůn˄uüÜmbe͠DrǗ oɶf ÓtȋhrˉeaǂdýsÍȥĩɽ;ƁĽť tʇoúͥ ϱ˭ŽuƳse duriϡ͎7Űng ôϸ˜£the ˾Ǘtʔr˾aiɱnin˄ϙÈg.\nŹȇ\n    Ȁ* Fo@Ãr CÿP̈ɷU. ȢO͍ptcimi\x8e¢zʭeɟs ƞtheͭϝő Æspee\xadd ńɌ\x97ȰɿofŴ˝Λ e˱ŋ̨bxπ ecutionȏν. ϫTh́ɬiȝ¿s ȋparaȷmƤetψerϵȢ doÒesn\'tθ ˑʀ˵affƽectϾ ǊresuΆ͢Ûltͽs.\nγ Τ   * Fɐorƍ İθGPȱ}zɑUʙ̋ʻϗǗ. Tķ+Æhe give̷έni valƒuɰeȩ i̲̕sτ\x9e Ϧuˆǐsed \x8eţžfor˖ ɒread\x80i͚ng3 tƣ\x8aheɁ dėata fromö tÉhē hard dÀŪrivʂe a\x81nd ŃȡdσȍoØeμs\n     ɨ noΒĳýt aǲπƏff͆ectɌ tϛȶhe tȜraθiǁning.\n ɏ z  χ  ˂DuĔʱͶʬrŅόȺˈǁiΗ͝nȆg øtʔνhe± Įtrɛainiſ͟ȬnŮgŶ one Âmain t\x86hƑÌrțeaʹd ÍÐͥaȁnd Ϋʃ³o̼ĴnΪe ˹thrlȒeadʽ ƽøėf̈o˷rʊ ūÐeaôch BͧGPU ζaŻ\u0379ɗreû\x9aϐ ˼uĥs͙e˿Ťd.')), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rat', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_co_unt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='supe', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rat', ctx=Load())), keyword(arg='logging_level', value=Name(id='logg', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_co_unt', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelPerSegment is deprecated; will be deleted in etna==2.0. Use CatBoostPerSegmentModel instead.'))])]), ClassDef(name='CatBoostModelMultiSegment', bases=[Name(id='CatBoostMultiSegmentModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='Cl\x8c\x83asʃȑs for hħoǳldiAɚnʛg ãCatʡǐboǞČoėÊst modeεl \u0381ðfor allι seͷgm\u0381eͩnƔtsªɯ.Â̋\nΕ\nWarnings\n-----ƮƫΤ---\nCa\x9btBoos\x81ΥtĹMÕ͑odɸPÕelMuıltǔɪʰãi˂SʻeƘŁgme͙nȰt is deprʹeĻcaϳt\x91edȱ; wa͔ikZǾll beœ deleted iµn ųe+t˶na==2.0ϛʏ.\nʣUsΥɶ²Ê͖e Ɣetͳna̘.modeȍls.ÐCatBooÕstMuêÝOltiSegːmentModɁeɃƂˎơ̦lΗʢ in˼ste\x99ɔíaʆd.\n\nExǀampĐleϣͳs\n-ͼ---ɝ͖ǹ----\u0381\n>>>Ÿ fǛrom˫ etnaŐ.dataĮsets ʾimpoϗrt ȯgeɶnerateȔ_perioƎdiˉc_dŷf\n>>γ>= fromǪ̥̏ʴţ etna˟.dkatasǰets ͖impʏoṙt TȋSDatΈas͊šet\nǣ>ϩ>ŭ>ǡ0\x94 fWro\x88m· eʝtna.moϠdƞelsɫ imporÑĔİt CΠϳat+B̲̊oosĜtµMoϾdelMulκtiSʖ9eOgmeğnt\n>>>Δ ĉfrom etna.t͍ĚΝransfor(ms impĞor\x92ϸ̯t LagTrɴʝansfɁorÄm\nˌã>>> ʄclǳδ̇assic_ͽdf\u038dƤ = Ǐgene\xa0ratͳe§̤_p˵̙eǯʾriodi˹ʈc_df(\n.̍..ț ǅ    pDeȰrʧiodpsέ=5yē1ǴΒ0̝0,ȴ\n...  ̧ ʶƇ  staòrʛtĜ_tʙimɅe="π202˚0-0\x83ʮ1͗-đ01\x99",\n...     ʊn_segmŘenļts=4,\n... "͚  ´ ǹ perioãd=ˀ7ʁ,˂˷Ç\n...Έ  \u038b   Bsigma˺=3\nʯ..ń.ʗϣ¢ )\nɏ˳h>>> df͝ = TSD aͽtóasͧet.to_ŉ\u0383Ǵƛd̽ataset(˜df˧=cl%assͅi\u0381c_̚-ƻdAfƗ)\n>>O> ts = TƳSDƸataƧ\x86set(θĳdfʝ, freq=Ň˭"D")ǒ\n>>͇> horizon ?= 27\n>>> trͰaʧnsfoϡrmϯs = [ͰǷ\n...   ά ɣ LǂagTraͻnsƤψf̞hɋFȓor,m(in_coʉƹlumnʹ="tarɊget"ɰ, lag\x84s]͡=[hori«z̓ʼon, ȿhoǅrizon+1,ǘ ĠċhoriĻzon+ɰ2])\n.ɘŀΩ.j. ]\n>>ʅȄ> tȬs.fĽit_trans̒šɧforɈĺm(trĨansformsȁ=ζ\x9ctranssformsƌ)\nΝ>>>ͷ ˈfutϰɪͮure =ʾ ts.maĽıke_fu Ȗtƥure(horizon)\n>>> moďŐćɞe͊l =ͮ C\x97atBɕƢoȄoȍs\xa0tModceńlMuͨˤltiSeϸgm\x8aent(ôÉ)\n>>Ć>\x81ß˃ mode%l.fΩit×(ts=ts)͔\nCΑatɌʑ́ɎBooâstModeζlÊMultiSegϗ×menəΞt(iterations =Ƅ ŤɝN˕oneΏ,Ņ ĹdeƘͭpth κʘ= Noτne\x96, lea˘rning_rate \x88= ɘNon\xa0e,\nĘ϶l͠AoggiLng_leveƾl = \'SilenůtįȂ\', lͪ2_leaϰfˡ_reg Ϧê= Noʉïne, threλǻŉɒŗad_cĈouůnt = ȸϼNone, )\n>¹>> forecalst = modcel.fń%orȓ˖ecast(fuʢ¿tur¯eƔ)\n͍˳>>> pd.opɷ\x9bτϩ΄tions.dƒisplͳay.flǒo̬at_Ʋʻformat = \'{:,.2f̾}\'.fo˧rmat\n>ǎ>> ûfoĜreõcast[:, ϫ:,̸Ʉ¿ "ta̜rɊgeʈɄŘtö"].ɓrounǘd()\nseágm˻ʽ̴ent   ͖ǎȏ sɪʵʯe\x9agmχeͅnt_Ȧ10 ©ǆs@eűgmƮʲenŞ©t_1 seɉgment_2ʣ̈́ sɋegmenľϬt_͈Î3\nf¾eature Ń   ʨ s \x94 tυaɺrgeϨt  ǐ  ƇtaËǰrgetà  ȡ  tϘargetƇ    targǈet\ntimestˮamp\nʁ2020-04-1ǳʬċ0 Ǖ ɘ    9ș.0Ŷ0   ˡ̉  ͘ɡ ϥ9ů\u0379.00Ǖ ̛    ͉ 4.00  ǲɱ0 Ǘ O  ĸʶ6.00\n2+020-04-Ȉ1Q1 ΉƓ   ʑ͊  5.00   ˨  ƉÈ 2ʐ@.0Ä0   žϲ   7.ǔ00  ʨÎ    9.00\nɓ2ɀ0Ɍ2ΉWϫ\x810Βƹͥ-04̤-Ȝ12   ˈ  -ů0.\x9f0v\x97ƛ0     Ǿ 4.00  ʠ    ʐ7.0˞0  ˌƂ ˳  Δɝ ˺9\x95.00\n2020-0ɔ4-13     ͑ 0.00ű ˙˳ʼ  ϋ Ť  5.0ɯN0      9ɐ.00 ø   ĕȥʏǥƃ ūͮΫ 7ü˳.00\n2Ͷχʄ020-04-14 ï     ǟ1.00 ʶ    ̀  Ŭƛ2.0\x9fν0Ġ      1.00     ͛ 6.00ɇ\nɟĖ20ɮ2ͺō̪ȕͿ0-ˀ0ŋ4ʥȧ͕-15    ĝ  5.0˃ɷ0ó É     7.j00     Ȩ̺ 4.00    ƀ  7ŅƂϭ.0(¬˩"0\n2020-04-16  ƿ şǏ   8.0Ɓ0      6.00ɔ Ɛ     2Ť.00 Ĵ  Πǥ ³  0Ͽ.0Ɓǡ0')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='s_elf'), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='depth', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='learning_rat', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='logg', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load())), arg(arg='l2_leaf', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load())), arg(arg='thread_co_unt', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Silent'), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='depth', ctx=Store())], value=Name(id='depth', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='learning_rate', ctx=Store())], value=Name(id='learning_rat', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='logging_level', ctx=Store())], value=Name(id='logg', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='l2_leaf_reg', ctx=Store())], value=Name(id='l2_leaf', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='thread_count', ctx=Store())], value=Name(id='thread_co_unt', ctx=Load())), Assign(targets=[Attribute(value=Name(id='s_elf', ctx=Load()), attr='kwargs', ctx=Store())], value=Name(id='kwargs', ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='supe', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='iterations', value=Name(id='iterations', ctx=Load())), keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='learning_rate', value=Name(id='learning_rat', ctx=Load())), keyword(arg='logging_level', value=Name(id='logg', ctx=Load())), keyword(arg='thread_count', value=Name(id='thread_co_unt', ctx=Load())), keyword(arg='l2_leaf_reg', value=Name(id='l2_leaf', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[])], decorator_list=[Call(func=Name(id='deprecated', ctx=Load()), args=[], keywords=[keyword(arg='reason', value=Constant(value='CatBoostModelMultiSegment is deprecated; will be deleted in etna==2.0. Use CatBoostMultiSegmentModel instead.'))])])], type_ignores=[])