Module(body=[ImportFrom(module='typing', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='Optional')], level=0), ImportFrom(module='etna.models.base', names=[alias(name='PredictionIntervalContextIgnorantAbstractModel')], level=0), ImportFrom(module='tbats.tbats.Model', names=[alias(name='Model')], level=0), ImportFrom(module='tbats.abstract', names=[alias(name='ContextInterface')], level=0), ImportFrom(module='typing', names=[alias(name='Tuple')], level=0), ImportFrom(module='tbats.bats', names=[alias(name='BATS')], level=0), ImportFrom(module='tbats.tbats', names=[alias(name='TBATS')], level=0), Import(names=[alias(name='pandas', asname='pd')]), ImportFrom(module='etna.models.base', names=[alias(name='BaseAdapter')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PerSegmentModelMixin')], level=0), ImportFrom(module='tbats.abstract', names=[alias(name='Estimator')], level=0), ImportFrom(module='etna.models.mixins', names=[alias(name='PredictionIntervalContextIgnorantModelMixin')], level=0), ImportFrom(module='etna.models.utils', names=[alias(name='determine_num_steps')], level=0), ClassDef(name='_TBATSAdapter', bases=[Name(id='BaseAdapter', ctx=Load())], keywords=[], body=[Expr(value=Constant(value=' ')), FunctionDef(name='get_', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()))], decorator_list=[], returns=Name(id='Model', ctx=Load())), FunctionDef(name='predictr', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='ŊΤ   ϱ ű  Ư   Ļ   ǜ ρ   ')), Raise(exc=Call(func=Name(id='notimplementederror', ctx=Load()), args=[Constant(value="Method predict isn't currently implemented!")], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='forecast', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='prediction_interval', annotation=Name(id='bool', ctx=Load())), arg(arg='quantiles', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='float', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value='Model is not fitted! Fit the model before calling predict method!')], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), ops=[LtE()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='notimplementederror', ctx=Load()), args=[Constant(value="It is not possible to make in-sample predictions with BATS/TBATS model! In-sample predictions aren't supported by current implementation.")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='_steps_to_forecast', ctx=Store())], value=Call(func=Name(id='determine_num_steps', ctx=Load()), args=[], keywords=[keyword(arg='start_timestamp', value=Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Load())), keyword(arg='end_timestamp', value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), keyword(arg='freq', value=Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Load()))])), Assign(targets=[Name(id='steps_to_skip', ctx=Store())], value=BinOp(left=Name(id='_steps_to_forecast', ctx=Load()), op=Sub(), right=Subscript(value=Attribute(value=Name(id='df', ctx=Load()), attr='shape', ctx=Load()), slice=Constant(value=0), ctx=Load()))), Assign(targets=[Name(id='y_pr', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load()), args=[], keywords=[])), If(test=Name(id='prediction_interval', ctx=Load()), body=[For(target=Name(id='qu', ctx=Store()), iter=Name(id='quantiles', ctx=Load()), body=[Assign(targets=[Tuple(elts=[Name(id='pred', ctx=Store()), Name(id='c_onfidence_intervals', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='_steps_to_forecast', ctx=Load())), keyword(arg='confidence_level', value=Name(id='qu', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pr', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load())), If(test=Compare(left=Name(id='qu', ctx=Load()), ops=[Lt()], comparators=[BinOp(left=Constant(value=1), op=Div(), right=Constant(value=2))]), body=[Assign(targets=[Subscript(value=Name(id='y_pr', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='qu', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='c_onfidence_intervals', ctx=Load()), slice=Constant(value='lower_bound'), ctx=Load()))], orelse=[Assign(targets=[Subscript(value=Name(id='y_pr', ctx=Load()), slice=JoinedStr(values=[Constant(value='target_'), FormattedValue(value=Name(id='qu', ctx=Load()), conversion=-1, format_spec=JoinedStr(values=[Constant(value='.4g')]))]), ctx=Store())], value=Subscript(value=Name(id='c_onfidence_intervals', ctx=Load()), slice=Constant(value='upper_bound'), ctx=Load()))])], orelse=[])], orelse=[Assign(targets=[Name(id='pred', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Load()), attr='forecast', ctx=Load()), args=[], keywords=[keyword(arg='steps', value=Name(id='_steps_to_forecast', ctx=Load()))])), Assign(targets=[Subscript(value=Name(id='y_pr', ctx=Load()), slice=Constant(value='target'), ctx=Store())], value=Name(id='pred', ctx=Load()))]), Assign(targets=[Name(id='y_pr', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='y_pr', ctx=Load()), attr='iloc', ctx=Load()), slice=Slice(lower=Name(id='steps_to_skip', ctx=Load())), ctx=Load()), attr='reset_index', ctx=Load()), args=[], keywords=[keyword(arg='drop', value=Constant(value=True))])), Return(value=Name(id='y_pr', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='model', annotation=Name(id='Estimator', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='  ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Name(id='model', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store()), annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Constant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Constant(value=None))], decorator_list=[]), FunctionDef(name='fit', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='df', annotation=Attribute(value=Name(id='pd', ctx=Load()), attr='DataFrame', ctx=Load())), arg(arg='regressors', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='st', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Ξ Ď  Ď  Ǵ ')), Assign(targets=[Name(id='fr_eq', ctx=Store())], value=Call(func=Attribute(value=Name(id='pd', ctx=Load()), attr='infer_freq', ctx=Load()), args=[Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load())], keywords=[keyword(arg='warn', value=Constant(value=False))])), If(test=Compare(left=Name(id='fr_eq', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Constant(value="Can't determine frequency of a given dataframe")], keywords=[]))], orelse=[]), Assign(targets=[Name(id='target', ctx=Store())], value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='target'), ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fitted_model', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='fit', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_last_train_timestamp', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Name(id='df', ctx=Load()), slice=Constant(value='timestamp'), ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_freq', ctx=Store())], value=Name(id='fr_eq', ctx=Load())), Return(value=Name(id='self', ctx=Load()))], decorator_list=[])], decorator_list=[]), ClassDef(name='BATSModelywi', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='use_box_cox', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='i_nt', ctx=Load()), Name(id='i_nt', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='i_nt', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_e', annotation=Name(id='bool', ctx=Load())), arg(arg='show_warnings', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='i_nt', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='st', ctx=Load())), arg(arg='co', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='BATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='use_box_cox', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_e', ctx=Load())), keyword(arg='show_warnings', value=Name(id='show_warnings', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='co', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[]), ClassDef(name='TBATSModel', bases=[Name(id='PerSegmentModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantModelMixin', ctx=Load()), Name(id='PredictionIntervalContextIgnorantAbstractModel', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='PClassŅŖĆ fȬáorƕ holdʳi˜ƳΝnˇgʑĬ `ʀse\x9bgͷmenʌt inϾt̩śàer4͞Çvβal ɖ̦TBȠATύǎƸS moƏ˦dȸeǖȣlǉŜǋ.')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='use_box_cox', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='box_cox_bounds', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Tuple(elts=[Name(id='i_nt', ctx=Load()), Name(id='i_nt', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='use_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='use_damped_trend', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='bool', ctx=Load()), ctx=Load())), arg(arg='seasonal_periods', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='i_nt', ctx=Load()), ctx=Load()), ctx=Load())), arg(arg='use_arma_e', annotation=Name(id='bool', ctx=Load())), arg(arg='show_warnings', annotation=Name(id='bool', ctx=Load())), arg(arg='n_jobs', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='i_nt', ctx=Load()), ctx=Load())), arg(arg='multiprocessing_start_method', annotation=Name(id='st', ctx=Load())), arg(arg='co', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Name(id='ContextInterface', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Tuple(elts=[Constant(value=0), Constant(value=1)], ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value=True), Constant(value=None), Constant(value='spawn'), Constant(value=None)]), body=[Expr(value=Constant(value="Creǘaˌte TBͮATSModel with Sgʘ\xad̓iˌϢven parametȊerǒs.\n  \n\nParamǨeterϿ͐Ĥs\n-ʹ----˛--Ǐϖ-ʯŬ--ń\nuse_box_cox: boxol or NHone, opt̳˃ional (defaΥulʛt=None\x82)\n¿  If Box-Cox traŋʋͻnsfȥ̓ormation oɮf¨ original se˟riƯes shɒͣouldͷ be ɿappl\\i˻eŤd.\n  When Nàone b˞ϗoth cases shall be considereɃd a\u0380nd bɿetter iǺs selected ʽbǟy AIC.#tgUKMaGjHdsvWFkLweiQ#qUzPuXG\nÖƽÆbox_ϬƶϜc²ǐox_boϗundȀs: tuple, ŭshaphe=(2,)ɚ, optiona̧l (Rdefault=(o0,̪ 1))Ω\n   Ì Minimal aϕnd˘ maxiâmaǣȒl Box-Cox parameter values.\nu̿se_treζnčd: b`o̔onl or Noneʒ, oģϯptioͩnʎal (̐def˔ğault/ϊ=Nonŝe)\n   \n  ʢ  Indicates whȡethƾer to includƓȰe aL˸\x83 ǞĖtrend or nΨot.\n  ʾWhen Noǈne boʣth̹ ēca¶ʸses shalɚl b.e consƖiderͣeɆǖdȤ and !˵betterƣSĬ˙ ̓i̇ˍóΙs sel3e:cteßd ̝by˓ AIC˭.\n \n  \nuǍs˰eɰǟ_dampeʞdƃ_trenpd: boolϥ !or None, Ąop˻tional (dǘefaultÃĄ=None)\n\n\n  Indiμ~ϓcat»eϐʘs͠ wheètheř̻ toŁʴ include ɱa daĝΓmǓ¥ping parameɏterǼ in theǄ trenɧd oƙr not.\n   Ţ ȀAǂppȜliȎeʊϜs oɌnly when tͽrenˤd is used.\n  W>heŢn None both cases ºshall be consiϣdered anɗd˲ beƫtÕ̾ˆter is seδlected byϋ ̉ƸAICɯ.\n\nsÔeasoǸnaʎάl_̈́periods: ˜iterable ȕor aĘrraÖy\xad-lʐikÌe of f͵loats, optional ϰ(Ȓdʀefaulkt=No\x93ne)ɚ\n   \n\n͞  Length o˻f 6each of the periodsĞ (amount of observationȖs in Ɏʠeach period).\nǑ Ω   TϮɄßBˡATS ¬acŇcepts ǷƟin\x86́tȹ anėd fȓloat vaʈlues her͖e.\n  WhenȄ NoneδǇ or eɣmpĠty aŘrraäy,Êźʌ ˍnonϙ-seasonLϝal model shřa½ll be 6fitöted.\nËuse_arma_eɑrÃrors:ʃĆ bЀoǵ\x85oμl,ŵ oÑptionalĽ (default=True)\n  ˮ  When TruΏe BATSq w͓Ϗi÷ll ̵tsry to impȚƼrЀove the mo̟̭deãl byǻ mũƚodelling res̻%ÜiduaȀls witƵ8ϨhŲ ARMA.\n   ǲ Best ƤϰmodelŒɚ ΏwiNll be selected bŮΆym AIC.ćɾ\n  IЀf9˔ ƯFalse, ARMA ÇĪresiduals modeϜling wiǟll ÀnotɌ be ćϱolnsãider˭ed.\n\n   \n   \n\nsh(Ōo¥w_warning̿s: booaχl, optiżonalɳ \x9d(defaultʑ=True)\n  If warnings ̍shǝould beŦ showϝnƆ or noŵt.Â\n  Al˙so see Moƿdel.warning's ŵɳvariable ythat contains a\u038dll model relat(ed warnŢiȑnŎgs.\nn_jobs: ̥int, oÅptɱiʸoȄϥnal̏ (defąult\x8fɬ=NonØͪe)\n   \n  How many jobʨs to run in pa\u0379͓rallel when fitƣtinϙg ϣBATS m˘odel.\nƯ  WhĂȅen not ɷproɔÑvidedż BŵATSɿ sha˨llȀ try tzo utilize a¯ll atvaiKlablĮe cpu cores.\n  \n«multipr͊Êoceͳssing_ǎstart̓_method: ̑str, Ńoptional (defaul΄tơ='s̀pa¤wώnƣ')\n̬  \x92ͷ  How threads Éshou\u0379ƭldǆ Ƅbe started˕.\n  ύǊ˄ɖSee httpǦs:/\u0382/dϷocs.pΕkyth̐on.org/3/libr̨aryæ/Ͷm\x8e×ͤultǭiǌprocąessing.htˊmlxǐ#cʮontǟexXįtsΧ-anγd-Ǟst̺şart-mǿʊethoĉϮâds\ncon˼text: abstract.ContextInterface, òȑoptional (ìdefaͰuΧlt=ćNone)\n  Fo^ύĥr aƻdvanced uʳsϋers onƍlψy¹. Provide this̾ toͯ ŏv˞erridɉȝe Μdͨef(aultν behˢľaviǊors")), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Name(id='TBATS', ctx=Load()), args=[], keywords=[keyword(arg='use_box_cox', value=Name(id='use_box_cox', ctx=Load())), keyword(arg='box_cox_bounds', value=Name(id='box_cox_bounds', ctx=Load())), keyword(arg='use_trend', value=Name(id='use_trend', ctx=Load())), keyword(arg='use_damped_trend', value=Name(id='use_damped_trend', ctx=Load())), keyword(arg='seasonal_periods', value=Name(id='seasonal_periods', ctx=Load())), keyword(arg='use_arma_errors', value=Name(id='use_arma_e', ctx=Load())), keyword(arg='show_warnings', value=Name(id='show_warnings', ctx=Load())), keyword(arg='n_jobs', value=Name(id='n_jobs', ctx=Load())), keyword(arg='multiprocessing_start_method', value=Name(id='multiprocessing_start_method', ctx=Load())), keyword(arg='context', value=Name(id='co', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='base_model', value=Call(func=Name(id='_TBATSAdapter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load())], keywords=[]))]))], decorator_list=[])], decorator_list=[])], type_ignores=[])